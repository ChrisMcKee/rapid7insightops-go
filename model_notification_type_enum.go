/*
InsightOps REST API

### Overview  Our REST API lets you use InsightOps through HTTP requests. Currently, the REST API allows you to perform the majority of the actions available through the UI, and has some additional functionality that is not available through the UI. You may use this API to automate common tasks (for example, via shell scripts), and to generally interact with InsightOps programmatically.  This page precisely describes the REST API and serves as a reference for the API. Each HTTP method and each URL endpoint is documented in a self-contained unit so that users only need to read about the HTTP methods relevant to them.  ### Terminology  * A **log entry** is an individual log event. * A **log** is a collection of log entries, or a single log stream. * A **log set** is a logical-only collection of logs, i.e. logs can be in multiple logsets and deleting a logset only deletes the relation between logs, not the logs themselves. * [Log Entry Query Language](https://docs.rapid7.com/insightops/log-search) (**LEQL**) is the query language used in Insight Ops to search log data.

API version: latest
Contact: support@rapid7.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package insightops

import (
	"encoding/json"
	"fmt"
)

// NotificationTypeEnum the model 'NotificationTypeEnum'
type NotificationTypeEnum string

// List of notification_type_enum
const (
	MAILTO    NotificationTypeEnum = "mailto"
	PAGERDUTY NotificationTypeEnum = "pagerduty"
	WEBHOOK   NotificationTypeEnum = "webhook"
	SLACK     NotificationTypeEnum = "slack"
	SQS       NotificationTypeEnum = "sqs"
)

// All allowed values of NotificationTypeEnum enum
var AllowedNotificationTypeEnumEnumValues = []NotificationTypeEnum{
	"mailto",
	"pagerduty",
	"webhook",
	"slack",
	"sqs",
}

func (v *NotificationTypeEnum) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := NotificationTypeEnum(value)
	for _, existing := range AllowedNotificationTypeEnumEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid NotificationTypeEnum", value)
}

// NewNotificationTypeEnumFromValue returns a pointer to a valid NotificationTypeEnum
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewNotificationTypeEnumFromValue(v string) (*NotificationTypeEnum, error) {
	ev := NotificationTypeEnum(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for NotificationTypeEnum: valid values are %v", v, AllowedNotificationTypeEnumEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v NotificationTypeEnum) IsValid() bool {
	for _, existing := range AllowedNotificationTypeEnumEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to notification_type_enum value
func (v NotificationTypeEnum) Ptr() *NotificationTypeEnum {
	return &v
}

type NullableNotificationTypeEnum struct {
	value *NotificationTypeEnum
	isSet bool
}

func (v NullableNotificationTypeEnum) Get() *NotificationTypeEnum {
	return v.value
}

func (v *NullableNotificationTypeEnum) Set(val *NotificationTypeEnum) {
	v.value = val
	v.isSet = true
}

func (v NullableNotificationTypeEnum) IsSet() bool {
	return v.isSet
}

func (v *NullableNotificationTypeEnum) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableNotificationTypeEnum(val *NotificationTypeEnum) *NullableNotificationTypeEnum {
	return &NullableNotificationTypeEnum{value: val, isSet: true}
}

func (v NullableNotificationTypeEnum) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableNotificationTypeEnum) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
