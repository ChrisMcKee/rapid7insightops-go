/*
InsightOps REST API

### Overview  Our REST API lets you use InsightOps through HTTP requests. Currently, the REST API allows you to perform the majority of the actions available through the UI, and has some additional functionality that is not available through the UI. You may use this API to automate common tasks (for example, via shell scripts), and to generally interact with InsightOps programmatically.  This page precisely describes the REST API and serves as a reference for the API. Each HTTP method and each URL endpoint is documented in a self-contained unit so that users only need to read about the HTTP methods relevant to them.  ### Terminology  * A **log entry** is an individual log event. * A **log** is a collection of log entries, or a single log stream. * A **log set** is a logical-only collection of logs, i.e. logs can be in multiple logsets and deleting a logset only deletes the relation between logs, not the logs themselves. * [Log Entry Query Language](https://docs.rapid7.com/insightops/log-search) (**LEQL**) is the query language used in Insight Ops to search log data.

API version: latest
Contact: support@rapid7.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package insightops

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// SavedQueriesAPIService SavedQueriesAPI service
type SavedQueriesAPIService service

type ApiDeleteSavedQueryIdRequest struct {
	ctx          context.Context
	ApiService   *SavedQueriesAPIService
	savedQueryId string
}

func (r ApiDeleteSavedQueryIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSavedQueryIdExecute(r)
}

/*
DeleteSavedQueryId Delete A Saved Query

For more context on saved queries, as well as instructions on handling rate limits consult [this section's introduction](#tag/Saved-Queries).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param savedQueryId \\ The id of the saved query.
	@return ApiDeleteSavedQueryIdRequest
*/
func (a *SavedQueriesAPIService) DeleteSavedQueryId(ctx context.Context, savedQueryId string) ApiDeleteSavedQueryIdRequest {
	return ApiDeleteSavedQueryIdRequest{
		ApiService:   a,
		ctx:          ctx,
		savedQueryId: savedQueryId,
	}
}

// Execute executes the request
func (a *SavedQueriesAPIService) DeleteSavedQueryIdExecute(r ApiDeleteSavedQueryIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavedQueriesAPIService.DeleteSavedQueryId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query/saved_queries/{saved_query_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"saved_query_id"+"}", url.PathEscape(parameterValueTostring(r.savedQueryId, "savedQueryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSavedQueryIdRequest struct {
	ctx          context.Context
	ApiService   *SavedQueriesAPIService
	savedQueryId string
}

func (r ApiGetSavedQueryIdRequest) Execute() (*SavedQuery, *http.Response, error) {
	return r.ApiService.GetSavedQueryIdExecute(r)
}

/*
GetSavedQueryId Retrieve A Saved Query

For more context on saved queries, as well as instructions on handling rate limits consult [this section's introduction](#tag/Saved-Queries).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param savedQueryId \\ The id of the saved query.
	@return ApiGetSavedQueryIdRequest
*/
func (a *SavedQueriesAPIService) GetSavedQueryId(ctx context.Context, savedQueryId string) ApiGetSavedQueryIdRequest {
	return ApiGetSavedQueryIdRequest{
		ApiService:   a,
		ctx:          ctx,
		savedQueryId: savedQueryId,
	}
}

// Execute executes the request
//
//	@return SavedQuery
func (a *SavedQueriesAPIService) GetSavedQueryIdExecute(r ApiGetSavedQueryIdRequest) (*SavedQuery, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SavedQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavedQueriesAPIService.GetSavedQueryId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query/saved_queries/{saved_query_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"saved_query_id"+"}", url.PathEscape(parameterValueTostring(r.savedQueryId, "savedQueryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSavedQueriesRequest struct {
	ctx        context.Context
	ApiService *SavedQueriesAPIService
}

func (r ApiListSavedQueriesRequest) Execute() (*ListSavedQueries200Response, *http.Response, error) {
	return r.ApiService.ListSavedQueriesExecute(r)
}

/*
ListSavedQueries List All Saved Queries

For more context on saved queries, as well as instructions on handling rate limits consult [this section's introduction](#tag/Saved-Queries).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListSavedQueriesRequest
*/
func (a *SavedQueriesAPIService) ListSavedQueries(ctx context.Context) ApiListSavedQueriesRequest {
	return ApiListSavedQueriesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ListSavedQueries200Response
func (a *SavedQueriesAPIService) ListSavedQueriesExecute(r ApiListSavedQueriesRequest) (*ListSavedQueries200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListSavedQueries200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavedQueriesAPIService.ListSavedQueries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query/saved_queries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchSavedQueryIdRequest struct {
	ctx             context.Context
	ApiService      *SavedQueriesAPIService
	savedQueryId    string
	patchSavedQuery *PatchSavedQuery
}

func (r ApiPatchSavedQueryIdRequest) PatchSavedQuery(patchSavedQuery PatchSavedQuery) ApiPatchSavedQueryIdRequest {
	r.patchSavedQuery = &patchSavedQuery
	return r
}

func (r ApiPatchSavedQueryIdRequest) Execute() (*SavedQuery, *http.Response, error) {
	return r.ApiService.PatchSavedQueryIdExecute(r)
}

/*
PatchSavedQueryId Modify A Saved Query

Replace one or more individual details of a saved query with the details specified in the JSON request body.
Cannot be used to remove the time range for a saved query (by replacing the time range with null value).

For more context on saved queries, as well as instructions on handling rate limits consult [this section's introduction](#tag/Saved-Queries).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param savedQueryId \\ The id of the saved query.
	@return ApiPatchSavedQueryIdRequest
*/
func (a *SavedQueriesAPIService) PatchSavedQueryId(ctx context.Context, savedQueryId string) ApiPatchSavedQueryIdRequest {
	return ApiPatchSavedQueryIdRequest{
		ApiService:   a,
		ctx:          ctx,
		savedQueryId: savedQueryId,
	}
}

// Execute executes the request
//
//	@return SavedQuery
func (a *SavedQueriesAPIService) PatchSavedQueryIdExecute(r ApiPatchSavedQueryIdRequest) (*SavedQuery, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SavedQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavedQueriesAPIService.PatchSavedQueryId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query/saved_queries/{saved_query_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"saved_query_id"+"}", url.PathEscape(parameterValueTostring(r.savedQueryId, "savedQueryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchSavedQuery == nil {
		return localVarReturnValue, nil, reportError("patchSavedQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchSavedQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSavedQueryRootRequest struct {
	ctx              context.Context
	ApiService       *SavedQueriesAPIService
	createSavedQuery *CreateSavedQuery
}

func (r ApiPostSavedQueryRootRequest) CreateSavedQuery(createSavedQuery CreateSavedQuery) ApiPostSavedQueryRootRequest {
	r.createSavedQuery = &createSavedQuery
	return r
}

func (r ApiPostSavedQueryRootRequest) Execute() (*SavedQuery, *http.Response, error) {
	return r.ApiService.PostSavedQueryRootExecute(r)
}

/*
PostSavedQueryRoot Create A Saved Query

For more context on saved queries, as well as instructions on handling rate limits consult [this section's introduction](#tag/Saved-Queries).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostSavedQueryRootRequest
*/
func (a *SavedQueriesAPIService) PostSavedQueryRoot(ctx context.Context) ApiPostSavedQueryRootRequest {
	return ApiPostSavedQueryRootRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SavedQuery
func (a *SavedQueriesAPIService) PostSavedQueryRootExecute(r ApiPostSavedQueryRootRequest) (*SavedQuery, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SavedQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavedQueriesAPIService.PostSavedQueryRoot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query/saved_queries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createSavedQuery == nil {
		return localVarReturnValue, nil, reportError("createSavedQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createSavedQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutSavedQueryIdRequest struct {
	ctx              context.Context
	ApiService       *SavedQueriesAPIService
	savedQueryId     string
	createSavedQuery *CreateSavedQuery
}

func (r ApiPutSavedQueryIdRequest) CreateSavedQuery(createSavedQuery CreateSavedQuery) ApiPutSavedQueryIdRequest {
	r.createSavedQuery = &createSavedQuery
	return r
}

func (r ApiPutSavedQueryIdRequest) Execute() (*SavedQuery, *http.Response, error) {
	return r.ApiService.PutSavedQueryIdExecute(r)
}

/*
PutSavedQueryId Replace A Saved Query

Replace a saved query with the details specified in the JSON request body. If the saved query you are replacing
contains a time range and the request body does not contain a time range, then the existing time range is retained.

For more context on saved queries, as well as instructions on handling rate limits consult [this section's introduction](#tag/Saved-Queries).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param savedQueryId \\ The id of the saved query.
	@return ApiPutSavedQueryIdRequest
*/
func (a *SavedQueriesAPIService) PutSavedQueryId(ctx context.Context, savedQueryId string) ApiPutSavedQueryIdRequest {
	return ApiPutSavedQueryIdRequest{
		ApiService:   a,
		ctx:          ctx,
		savedQueryId: savedQueryId,
	}
}

// Execute executes the request
//
//	@return SavedQuery
func (a *SavedQueriesAPIService) PutSavedQueryIdExecute(r ApiPutSavedQueryIdRequest) (*SavedQuery, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SavedQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavedQueriesAPIService.PutSavedQueryId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query/saved_queries/{saved_query_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"saved_query_id"+"}", url.PathEscape(parameterValueTostring(r.savedQueryId, "savedQueryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createSavedQuery == nil {
		return localVarReturnValue, nil, reportError("createSavedQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createSavedQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUseSavedQueryRequest struct {
	ctx             context.Context
	ApiService      *SavedQueriesAPIService
	savedQueryId    string
	from            *int32
	to              *int32
	timeRange       *string
	perPage         *int32
	kvpInfo         *bool
	mostRecentFirst *bool
}

// \\ The start of the time range for the query, as a UNIX timestamp in milliseconds.
func (r ApiUseSavedQueryRequest) From(from int32) ApiUseSavedQueryRequest {
	r.from = &from
	return r
}

// \\ The end of the time range for the query, as a UNIX timestamp in milliseconds.
func (r ApiUseSavedQueryRequest) To(to int32) ApiUseSavedQueryRequest {
	r.to = &to
	return r
}

// \\ An alternative to the &#x60;from&#x60; and &#x60;to&#x60; query parameters. Supported values: * &#x60;yesterday&#x60; * &#x60;today&#x60; * &#x60;last x timeunits&#x60; where x is the number of time unit back from the current server time. Supported time units (case insensitive):     - min(s) or minute(s)     - hr(s) or hour(s)     - day(s)     - week(s)     - month(s)     - year(s)  If &#x60;time_range&#x60; is used, then the &#x60;from&#x60; and &#x60;to&#x60; query parameters must not be used.
func (r ApiUseSavedQueryRequest) TimeRange(timeRange string) ApiUseSavedQueryRequest {
	r.timeRange = &timeRange
	return r
}

// \\ Number of log entries to return per page, up to 500(the maximum allowed).
func (r ApiUseSavedQueryRequest) PerPage(perPage int32) ApiUseSavedQueryRequest {
	r.perPage = &perPage
	return r
}

// \\ When set to true, the &#x60;events&#x60; object that is returned will additionally contain information about all the key-value pairs in each returned log entry.
func (r ApiUseSavedQueryRequest) KvpInfo(kvpInfo bool) ApiUseSavedQueryRequest {
	r.kvpInfo = &kvpInfo
	return r
}

// \\ When set to &#x60;true&#x60;, the query returns the most recent events first. When set to &#x60;false&#x60;, it returns the oldest events first.
func (r ApiUseSavedQueryRequest) MostRecentFirst(mostRecentFirst bool) ApiUseSavedQueryRequest {
	r.mostRecentFirst = &mostRecentFirst
	return r
}

func (r ApiUseSavedQueryRequest) Execute() (*GetQueryLogs200Response, *http.Response, error) {
	return r.ApiService.UseSavedQueryExecute(r)
}

/*
UseSavedQuery Use a Saved Query (logs specified)

Run a saved query.

This endpoint can only be used for saved queries which *have* the logs for the query already specified.
For saved queries which *don't have* the logs already specified, use the
[/query/logs/{log_keys}/{saved_query_id}](#operation/useSavedQueryNoLogs) endpoint.

The saved queries used here may or may not have the time range specified.
If unspecified, the time range must be indicated in the URL query parameters.
If the time range *is specified* by the saved query, the time range cannnot be overridden in the query parameters.

### Query Types
There are two types of queries, which return different response body structures:
* **Event Search** queries do not contain a `calculate` function and return a list of log lines in the
response. When the number of log lines matching your query is large, the response will be paginated and you will
need to send further requests to retrieve the other pages of log lines (more details on this below).
* **Statistical Search** queries contain a `calculate` function and return a number rather
than a list of log lines. These queries do not require you to handle any pagination. Additionally, the response body
will have a different structure depending on whether the query contains a `groupby` clause or not.

### Polling, Pagination & Rate Limiting
For instructions on polling a query until it is completed, handling pagination, and handling rate limits, consult
[the introduction to the "Query Log Data" section](#tag/Query-Log-Data).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param savedQueryId \\ The id of the saved query.
	@return ApiUseSavedQueryRequest
*/
func (a *SavedQueriesAPIService) UseSavedQuery(ctx context.Context, savedQueryId string) ApiUseSavedQueryRequest {
	return ApiUseSavedQueryRequest{
		ApiService:   a,
		ctx:          ctx,
		savedQueryId: savedQueryId,
	}
}

// Execute executes the request
//
//	@return GetQueryLogs200Response
func (a *SavedQueriesAPIService) UseSavedQueryExecute(r ApiUseSavedQueryRequest) (*GetQueryLogs200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetQueryLogs200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavedQueriesAPIService.UseSavedQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query/saved_query/{saved_query_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"saved_query_id"+"}", url.PathEscape(parameterValueTostring(r.savedQueryId, "savedQueryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.from == nil {
		return localVarReturnValue, nil, reportError("from is required and must be specified")
	}
	if r.to == nil {
		return localVarReturnValue, nil, reportError("to is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "", "")
	if r.timeRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_range", r.timeRange, "", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "", "")
	} else {
		var defaultValue int32 = 50
		r.perPage = &defaultValue
	}
	if r.kvpInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "kvp_info", r.kvpInfo, "", "")
	}
	if r.mostRecentFirst != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "most_recent_first", r.mostRecentFirst, "", "")
	} else {
		var defaultValue bool = false
		r.mostRecentFirst = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUseSavedQueryNoLogsRequest struct {
	ctx             context.Context
	ApiService      *SavedQueriesAPIService
	logKeys         string
	savedQueryId    string
	from            *int32
	to              *int32
	timeRange       *string
	perPage         *int32
	kvpInfo         *bool
	mostRecentFirst *bool
}

// \\ The start of the time range for the query, as a UNIX timestamp in milliseconds.
func (r ApiUseSavedQueryNoLogsRequest) From(from int32) ApiUseSavedQueryNoLogsRequest {
	r.from = &from
	return r
}

// \\ The end of the time range for the query, as a UNIX timestamp in milliseconds.
func (r ApiUseSavedQueryNoLogsRequest) To(to int32) ApiUseSavedQueryNoLogsRequest {
	r.to = &to
	return r
}

// \\ An alternative to the &#x60;from&#x60; and &#x60;to&#x60; query parameters. Supported values: * &#x60;yesterday&#x60; * &#x60;today&#x60; * &#x60;last x timeunits&#x60; where x is the number of time unit back from the current server time. Supported time units (case insensitive):     - min(s) or minute(s)     - hr(s) or hour(s)     - day(s)     - week(s)     - month(s)     - year(s)  If &#x60;time_range&#x60; is used, then the &#x60;from&#x60; and &#x60;to&#x60; query parameters must not be used.
func (r ApiUseSavedQueryNoLogsRequest) TimeRange(timeRange string) ApiUseSavedQueryNoLogsRequest {
	r.timeRange = &timeRange
	return r
}

// \\ Number of log entries to return per page, up to 500(the maximum allowed).
func (r ApiUseSavedQueryNoLogsRequest) PerPage(perPage int32) ApiUseSavedQueryNoLogsRequest {
	r.perPage = &perPage
	return r
}

// \\ When set to true, the &#x60;events&#x60; object that is returned will additionally contain information about all the key-value pairs in each returned log entry.
func (r ApiUseSavedQueryNoLogsRequest) KvpInfo(kvpInfo bool) ApiUseSavedQueryNoLogsRequest {
	r.kvpInfo = &kvpInfo
	return r
}

// \\ When set to &#x60;true&#x60;, the query returns the most recent events first. When set to &#x60;false&#x60;, it returns the oldest events first.
func (r ApiUseSavedQueryNoLogsRequest) MostRecentFirst(mostRecentFirst bool) ApiUseSavedQueryNoLogsRequest {
	r.mostRecentFirst = &mostRecentFirst
	return r
}

func (r ApiUseSavedQueryNoLogsRequest) Execute() (*GetQueryLogs200Response, *http.Response, error) {
	return r.ApiService.UseSavedQueryNoLogsExecute(r)
}

/*
UseSavedQueryNoLogs Use a Saved Query (logs unspecified)

Run a saved query on the logs matching the specified **{log_keys}**.

This endpoint can only be used for saved queries which *don't have* the logs for the query already specified.
For saved queries which *have* the logs already specified, use the
[/query/saved_query/{saved_query_id}](#operation/useSavedQuery) endpoint.

The saved queries used here may or may not have the time range specified.
If unspecified, the time range must be indicated in the URL query parameters.
If the time range *is specified* by the saved query, the time range cannnot be overridden in the query parameters.

### Query Types
There are two types of queries, which return different response body structures:
* **Event Search** queries do not contain a `calculate` function and return a list of log lines in the
response. When the number of log lines matching your query is large, the response will be paginated and you will
need to send further requests to retrieve the other pages of log lines (more details on this below).
* **Statistical Search** queries contain a `calculate` function and return a number rather
than a list of log lines. These queries do not require you to handle any pagination. Additionally, the response body
will have a different structure depending on whether the query contains a `groupby` clause or not.

### Polling, Pagination & Rate Limiting
For instructions on polling a query until it is completed, handling pagination, and handling rate limits, consult
[the introduction to the "Query Log Data" section](#tag/Query-Log-Data).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param logKeys \\ The keys of the logs to be queried, separated by the ':' character.
	@param savedQueryId \\ The id of the saved query.
	@return ApiUseSavedQueryNoLogsRequest
*/
func (a *SavedQueriesAPIService) UseSavedQueryNoLogs(ctx context.Context, logKeys string, savedQueryId string) ApiUseSavedQueryNoLogsRequest {
	return ApiUseSavedQueryNoLogsRequest{
		ApiService:   a,
		ctx:          ctx,
		logKeys:      logKeys,
		savedQueryId: savedQueryId,
	}
}

// Execute executes the request
//
//	@return GetQueryLogs200Response
func (a *SavedQueriesAPIService) UseSavedQueryNoLogsExecute(r ApiUseSavedQueryNoLogsRequest) (*GetQueryLogs200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetQueryLogs200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavedQueriesAPIService.UseSavedQueryNoLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query/logs/{log_keys}/{saved_query_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"log_keys"+"}", url.PathEscape(parameterValueTostring(r.logKeys, "logKeys")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"saved_query_id"+"}", url.PathEscape(parameterValueTostring(r.savedQueryId, "savedQueryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.from == nil {
		return localVarReturnValue, nil, reportError("from is required and must be specified")
	}
	if r.to == nil {
		return localVarReturnValue, nil, reportError("to is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "", "")
	if r.timeRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_range", r.timeRange, "", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "", "")
	} else {
		var defaultValue int32 = 50
		r.perPage = &defaultValue
	}
	if r.kvpInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "kvp_info", r.kvpInfo, "", "")
	}
	if r.mostRecentFirst != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "most_recent_first", r.mostRecentFirst, "", "")
	} else {
		var defaultValue bool = false
		r.mostRecentFirst = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
