/*
InsightOps REST API

### Overview  Our REST API lets you use InsightOps through HTTP requests. Currently, the REST API allows you to perform the majority of the actions available through the UI, and has some additional functionality that is not available through the UI. You may use this API to automate common tasks (for example, via shell scripts), and to generally interact with InsightOps programmatically.  This page precisely describes the REST API and serves as a reference for the API. Each HTTP method and each URL endpoint is documented in a self-contained unit so that users only need to read about the HTTP methods relevant to them.  ### Terminology  * A **log entry** is an individual log event. * A **log** is a collection of log entries, or a single log stream. * A **log set** is a logical-only collection of logs, i.e. logs can be in multiple logsets and deleting a logset only deletes the relation between logs, not the logs themselves. * [Log Entry Query Language](https://docs.rapid7.com/insightops/log-search) (**LEQL**) is the query language used in Insight Ops to search log data.

API version: latest
Contact: support@rapid7.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package insightops

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// BasicDetectionRulesAPIService BasicDetectionRulesAPI service
type BasicDetectionRulesAPIService service

type ApiDeleteLabelByIdRequest struct {
	ctx        context.Context
	ApiService *BasicDetectionRulesAPIService
	labelId    string
}

func (r ApiDeleteLabelByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteLabelByIdExecute(r)
}

/*
DeleteLabelById Delete a Label

For more context on basic detection rules, notification, notification targets, and labels,
as well as instructions on handling rate limits, consult [this section's introduction](#tag/Basic-Detection-Rules).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param labelId \\ The ID of the label to be queried.
	@return ApiDeleteLabelByIdRequest
*/
func (a *BasicDetectionRulesAPIService) DeleteLabelById(ctx context.Context, labelId string) ApiDeleteLabelByIdRequest {
	return ApiDeleteLabelByIdRequest{
		ApiService: a,
		ctx:        ctx,
		labelId:    labelId,
	}
}

// Execute executes the request
func (a *BasicDetectionRulesAPIService) DeleteLabelByIdExecute(r ApiDeleteLabelByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BasicDetectionRulesAPIService.DeleteLabelById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/management/labels/{label_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"label_id"+"}", url.PathEscape(parameterValueTostring(r.labelId, "labelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteManagementTagActionByIdRequest struct {
	ctx        context.Context
	ApiService *BasicDetectionRulesAPIService
	actionId   string
}

func (r ApiDeleteManagementTagActionByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteManagementTagActionByIdExecute(r)
}

/*
DeleteManagementTagActionById Delete a Notification

For more context on basic detection rules, notification, notification targets, and labels,
as well as instructions on handling rate limits, consult [this section's introduction](#tag/Basic-Detection-Rules).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param actionId \\ The id of the notification.
	@return ApiDeleteManagementTagActionByIdRequest
*/
func (a *BasicDetectionRulesAPIService) DeleteManagementTagActionById(ctx context.Context, actionId string) ApiDeleteManagementTagActionByIdRequest {
	return ApiDeleteManagementTagActionByIdRequest{
		ApiService: a,
		ctx:        ctx,
		actionId:   actionId,
	}
}

// Execute executes the request
func (a *BasicDetectionRulesAPIService) DeleteManagementTagActionByIdExecute(r ApiDeleteManagementTagActionByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BasicDetectionRulesAPIService.DeleteManagementTagActionById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/management/actions/{action_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"action_id"+"}", url.PathEscape(parameterValueTostring(r.actionId, "actionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteManagementTagByIdRequest struct {
	ctx        context.Context
	ApiService *BasicDetectionRulesAPIService
	tagId      string
}

func (r ApiDeleteManagementTagByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteManagementTagByIdExecute(r)
}

/*
DeleteManagementTagById Delete a Basic Detection Rule

For more context on basic detection rules, notification, notification targets, and labels,
as well as instructions on handling rate limits, consult [this section's introduction](#tag/Basic-Detection-Rules).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tagId \\ The id of the change detection rule.
	@return ApiDeleteManagementTagByIdRequest
*/
func (a *BasicDetectionRulesAPIService) DeleteManagementTagById(ctx context.Context, tagId string) ApiDeleteManagementTagByIdRequest {
	return ApiDeleteManagementTagByIdRequest{
		ApiService: a,
		ctx:        ctx,
		tagId:      tagId,
	}
}

// Execute executes the request
func (a *BasicDetectionRulesAPIService) DeleteManagementTagByIdExecute(r ApiDeleteManagementTagByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BasicDetectionRulesAPIService.DeleteManagementTagById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/management/tags/{rule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"tag_id"+"}", url.PathEscape(parameterValueTostring(r.tagId, "tagId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteManagementTargetByIdRequest struct {
	ctx        context.Context
	ApiService *BasicDetectionRulesAPIService
	targetId   string
}

func (r ApiDeleteManagementTargetByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteManagementTargetByIdExecute(r)
}

/*
DeleteManagementTargetById Delete a Target

For more context on basic detection rules, notification, notification targets, and labels,
as well as instructions on handling rate limits, consult [this section's introduction](#tag/Basic-Detection-Rules).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param targetId \\ The id of the notification target.
	@return ApiDeleteManagementTargetByIdRequest
*/
func (a *BasicDetectionRulesAPIService) DeleteManagementTargetById(ctx context.Context, targetId string) ApiDeleteManagementTargetByIdRequest {
	return ApiDeleteManagementTargetByIdRequest{
		ApiService: a,
		ctx:        ctx,
		targetId:   targetId,
	}
}

// Execute executes the request
func (a *BasicDetectionRulesAPIService) DeleteManagementTargetByIdExecute(r ApiDeleteManagementTargetByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BasicDetectionRulesAPIService.DeleteManagementTargetById")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/management/targets/{target_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"target_id"+"}", url.PathEscape(parameterValueTostring(r.targetId, "targetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetLabelByIdRequest struct {
	ctx        context.Context
	ApiService *BasicDetectionRulesAPIService
	labelId    string
}

func (r ApiGetLabelByIdRequest) Execute() (*LabelResponse, *http.Response, error) {
	return r.ApiService.GetLabelByIdExecute(r)
}

/*
GetLabelById Retrieve a Label

For more context on basic detection rules, notification, notification targets, and labels,
as well as instructions on handling rate limits, consult [this section's introduction](#tag/Basic-Detection-Rules).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param labelId \\ The ID of the label to be queried.
	@return ApiGetLabelByIdRequest
*/
func (a *BasicDetectionRulesAPIService) GetLabelById(ctx context.Context, labelId string) ApiGetLabelByIdRequest {
	return ApiGetLabelByIdRequest{
		ApiService: a,
		ctx:        ctx,
		labelId:    labelId,
	}
}

// Execute executes the request
//
//	@return LabelResponse
func (a *BasicDetectionRulesAPIService) GetLabelByIdExecute(r ApiGetLabelByIdRequest) (*LabelResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LabelResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BasicDetectionRulesAPIService.GetLabelById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/management/labels/{label_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"label_id"+"}", url.PathEscape(parameterValueTostring(r.labelId, "labelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLabelsRequest struct {
	ctx        context.Context
	ApiService *BasicDetectionRulesAPIService
}

func (r ApiGetLabelsRequest) Execute() (*LabelsResponse, *http.Response, error) {
	return r.ApiService.GetLabelsExecute(r)
}

/*
GetLabels List all Labels

For more context on basic detection rules, notification, notification targets, and labels,
as well as instructions on handling rate limits, consult [this section's introduction](#tag/Basic-Detection-Rules).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLabelsRequest
*/
func (a *BasicDetectionRulesAPIService) GetLabels(ctx context.Context) ApiGetLabelsRequest {
	return ApiGetLabelsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return LabelsResponse
func (a *BasicDetectionRulesAPIService) GetLabelsExecute(r ApiGetLabelsRequest) (*LabelsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LabelsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BasicDetectionRulesAPIService.GetLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/management/labels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetManagementAlertNotificationSettingsRequest struct {
	ctx        context.Context
	ApiService *BasicDetectionRulesAPIService
}

func (r ApiGetManagementAlertNotificationSettingsRequest) Execute() (*GetManagementAlertNotificationSettings200Response, *http.Response, error) {
	return r.ApiService.GetManagementAlertNotificationSettingsExecute(r)
}

/*
GetManagementAlertNotificationSettings List All Notifications

For more context on basic detection rules, notification, notification targets, and labels,
as well as instructions on handling rate limits, consult [this section's introduction](#tag/Basic-Detection-Rules).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetManagementAlertNotificationSettingsRequest
*/
func (a *BasicDetectionRulesAPIService) GetManagementAlertNotificationSettings(ctx context.Context) ApiGetManagementAlertNotificationSettingsRequest {
	return ApiGetManagementAlertNotificationSettingsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetManagementAlertNotificationSettings200Response
func (a *BasicDetectionRulesAPIService) GetManagementAlertNotificationSettingsExecute(r ApiGetManagementAlertNotificationSettingsRequest) (*GetManagementAlertNotificationSettings200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetManagementAlertNotificationSettings200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BasicDetectionRulesAPIService.GetManagementAlertNotificationSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/management/actions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetManagementTagActionByIdRequest struct {
	ctx        context.Context
	ApiService *BasicDetectionRulesAPIService
	actionId   string
}

func (r ApiGetManagementTagActionByIdRequest) Execute() (*PostManagementTagActions201Response, *http.Response, error) {
	return r.ApiService.GetManagementTagActionByIdExecute(r)
}

/*
GetManagementTagActionById Retrieve a Notification

For more context on basic detection rules, notification, notification targets, and labels,
as well as instructions on handling rate limits, consult [this section's introduction](#tag/Basic-Detection-Rules).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param actionId \\ The id of the notification.
	@return ApiGetManagementTagActionByIdRequest
*/
func (a *BasicDetectionRulesAPIService) GetManagementTagActionById(ctx context.Context, actionId string) ApiGetManagementTagActionByIdRequest {
	return ApiGetManagementTagActionByIdRequest{
		ApiService: a,
		ctx:        ctx,
		actionId:   actionId,
	}
}

// Execute executes the request
//
//	@return PostManagementTagActions201Response
func (a *BasicDetectionRulesAPIService) GetManagementTagActionByIdExecute(r ApiGetManagementTagActionByIdRequest) (*PostManagementTagActions201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PostManagementTagActions201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BasicDetectionRulesAPIService.GetManagementTagActionById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/management/actions/{action_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"action_id"+"}", url.PathEscape(parameterValueTostring(r.actionId, "actionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetManagementTagActionTargetsRequest struct {
	ctx        context.Context
	ApiService *BasicDetectionRulesAPIService
	actionId   string
}

func (r ApiGetManagementTagActionTargetsRequest) Execute() (*GetManagementTagActionTargets200Response, *http.Response, error) {
	return r.ApiService.GetManagementTagActionTargetsExecute(r)
}

/*
GetManagementTagActionTargets List All Targets Attached To A Notification

Given the ID of a notification, returns all notification targets currently attached to that notification.
For more context on basic detection rules, notification, notification targets, and labels,
as well as instructions on handling rate limits, consult [this section's introduction](#tag/Basic-Detection-Rules).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param actionId \\ The id of the notification.
	@return ApiGetManagementTagActionTargetsRequest
*/
func (a *BasicDetectionRulesAPIService) GetManagementTagActionTargets(ctx context.Context, actionId string) ApiGetManagementTagActionTargetsRequest {
	return ApiGetManagementTagActionTargetsRequest{
		ApiService: a,
		ctx:        ctx,
		actionId:   actionId,
	}
}

// Execute executes the request
//
//	@return GetManagementTagActionTargets200Response
func (a *BasicDetectionRulesAPIService) GetManagementTagActionTargetsExecute(r ApiGetManagementTagActionTargetsRequest) (*GetManagementTagActionTargets200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetManagementTagActionTargets200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BasicDetectionRulesAPIService.GetManagementTagActionTargets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/management/actions/{action_id}/targets"
	localVarPath = strings.Replace(localVarPath, "{"+"action_id"+"}", url.PathEscape(parameterValueTostring(r.actionId, "actionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetManagementTagByIdRequest struct {
	ctx        context.Context
	ApiService *BasicDetectionRulesAPIService
	tagId      string
}

func (r ApiGetManagementTagByIdRequest) Execute() (*PostManagementTags201Response, *http.Response, error) {
	return r.ApiService.GetManagementTagByIdExecute(r)
}

/*
GetManagementTagById Retrieve a Basic Detection Rule

For more context on basic detection rules, notification, notification targets, and labels,
as well as instructions on handling rate limits, consult [this section's introduction](#tag/Basic-Detection-Rules).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tagId \\ The id of the change detection rule.
	@return ApiGetManagementTagByIdRequest
*/
func (a *BasicDetectionRulesAPIService) GetManagementTagById(ctx context.Context, tagId string) ApiGetManagementTagByIdRequest {
	return ApiGetManagementTagByIdRequest{
		ApiService: a,
		ctx:        ctx,
		tagId:      tagId,
	}
}

// Execute executes the request
//
//	@return PostManagementTags201Response
func (a *BasicDetectionRulesAPIService) GetManagementTagByIdExecute(r ApiGetManagementTagByIdRequest) (*PostManagementTags201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PostManagementTags201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BasicDetectionRulesAPIService.GetManagementTagById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/management/tags/{rule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"tag_id"+"}", url.PathEscape(parameterValueTostring(r.tagId, "tagId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetManagementTagsRequest struct {
	ctx        context.Context
	ApiService *BasicDetectionRulesAPIService
}

func (r ApiGetManagementTagsRequest) Execute() (*GetManagementTags200Response, *http.Response, error) {
	return r.ApiService.GetManagementTagsExecute(r)
}

/*
GetManagementTags List All Tags

For more context on basic detection rules, notification, notification targets, and labels,
as well as instructions on handling rate limits, consult [this section's introduction](#tag/Basic-Detection-Rules).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetManagementTagsRequest
*/
func (a *BasicDetectionRulesAPIService) GetManagementTags(ctx context.Context) ApiGetManagementTagsRequest {
	return ApiGetManagementTagsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetManagementTags200Response
func (a *BasicDetectionRulesAPIService) GetManagementTagsExecute(r ApiGetManagementTagsRequest) (*GetManagementTags200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetManagementTags200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BasicDetectionRulesAPIService.GetManagementTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/management/tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetManagementTargetByIdRequest struct {
	ctx        context.Context
	ApiService *BasicDetectionRulesAPIService
	targetId   string
}

func (r ApiGetManagementTargetByIdRequest) Execute() (*TargetResponse, *http.Response, error) {
	return r.ApiService.GetManagementTargetByIdExecute(r)
}

/*
GetManagementTargetById Retrieve a Target

For more context on basic detection rules, notification, notification targets, and labels,
as well as instructions on handling rate limits, consult [this section's introduction](#tag/Basic-Detection-Rules).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param targetId \\ The id of the notification target.
	@return ApiGetManagementTargetByIdRequest
*/
func (a *BasicDetectionRulesAPIService) GetManagementTargetById(ctx context.Context, targetId string) ApiGetManagementTargetByIdRequest {
	return ApiGetManagementTargetByIdRequest{
		ApiService: a,
		ctx:        ctx,
		targetId:   targetId,
	}
}

// Execute executes the request
//
//	@return TargetResponse
func (a *BasicDetectionRulesAPIService) GetManagementTargetByIdExecute(r ApiGetManagementTargetByIdRequest) (*TargetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TargetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BasicDetectionRulesAPIService.GetManagementTargetById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/management/targets/{target_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"target_id"+"}", url.PathEscape(parameterValueTostring(r.targetId, "targetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetManagementTargetsRequest struct {
	ctx        context.Context
	ApiService *BasicDetectionRulesAPIService
}

func (r ApiGetManagementTargetsRequest) Execute() (*TargetResponse, *http.Response, error) {
	return r.ApiService.GetManagementTargetsExecute(r)
}

/*
GetManagementTargets List All Targets

For more context on basic detection rules, notification, notification targets, and labels,
as well as instructions on handling rate limits, consult [this section's introduction](#tag/Basic-Detection-Rules).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetManagementTargetsRequest
*/
func (a *BasicDetectionRulesAPIService) GetManagementTargets(ctx context.Context) ApiGetManagementTargetsRequest {
	return ApiGetManagementTargetsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return TargetResponse
func (a *BasicDetectionRulesAPIService) GetManagementTargetsExecute(r ApiGetManagementTargetsRequest) (*TargetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TargetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BasicDetectionRulesAPIService.GetManagementTargets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/management/targets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchLabelByIdRequest struct {
	ctx        context.Context
	ApiService *BasicDetectionRulesAPIService
	labelId    string
	patchLabel *PatchLabel
}

func (r ApiPatchLabelByIdRequest) PatchLabel(patchLabel PatchLabel) ApiPatchLabelByIdRequest {
	r.patchLabel = &patchLabel
	return r
}

func (r ApiPatchLabelByIdRequest) Execute() (*LabelResponse, *http.Response, error) {
	return r.ApiService.PatchLabelByIdExecute(r)
}

/*
PatchLabelById Update a Label

For more context on basic detection rules, notification, notification targets, and labels,
as well as instructions on handling rate limits, consult [this section's introduction](#tag/Basic-Detection-Rules).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param labelId \\ The ID of the label to be queried.
	@return ApiPatchLabelByIdRequest
*/
func (a *BasicDetectionRulesAPIService) PatchLabelById(ctx context.Context, labelId string) ApiPatchLabelByIdRequest {
	return ApiPatchLabelByIdRequest{
		ApiService: a,
		ctx:        ctx,
		labelId:    labelId,
	}
}

// Execute executes the request
//
//	@return LabelResponse
func (a *BasicDetectionRulesAPIService) PatchLabelByIdExecute(r ApiPatchLabelByIdRequest) (*LabelResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LabelResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BasicDetectionRulesAPIService.PatchLabelById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/management/labels/{label_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"label_id"+"}", url.PathEscape(parameterValueTostring(r.labelId, "labelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchLabel == nil {
		return localVarReturnValue, nil, reportError("patchLabel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchLabel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchManagementTagActionByIdRequest struct {
	ctx                             context.Context
	ApiService                      *BasicDetectionRulesAPIService
	actionId                        string
	postManagementTagActionsRequest *PostManagementTagActionsRequest
}

func (r ApiPatchManagementTagActionByIdRequest) PostManagementTagActionsRequest(postManagementTagActionsRequest PostManagementTagActionsRequest) ApiPatchManagementTagActionByIdRequest {
	r.postManagementTagActionsRequest = &postManagementTagActionsRequest
	return r
}

func (r ApiPatchManagementTagActionByIdRequest) Execute() (*PostManagementTagActions201Response, *http.Response, error) {
	return r.ApiService.PatchManagementTagActionByIdExecute(r)
}

/*
PatchManagementTagActionById Modify a Notification

For more context on basic detection rules, notification, notification targets, and labels,
as well as instructions on handling rate limits, consult [this section's introduction](#tag/Basic-Detection-Rules).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param actionId \\ The id of the notification.
	@return ApiPatchManagementTagActionByIdRequest
*/
func (a *BasicDetectionRulesAPIService) PatchManagementTagActionById(ctx context.Context, actionId string) ApiPatchManagementTagActionByIdRequest {
	return ApiPatchManagementTagActionByIdRequest{
		ApiService: a,
		ctx:        ctx,
		actionId:   actionId,
	}
}

// Execute executes the request
//
//	@return PostManagementTagActions201Response
func (a *BasicDetectionRulesAPIService) PatchManagementTagActionByIdExecute(r ApiPatchManagementTagActionByIdRequest) (*PostManagementTagActions201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PostManagementTagActions201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BasicDetectionRulesAPIService.PatchManagementTagActionById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/management/actions/{action_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"action_id"+"}", url.PathEscape(parameterValueTostring(r.actionId, "actionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postManagementTagActionsRequest == nil {
		return localVarReturnValue, nil, reportError("postManagementTagActionsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postManagementTagActionsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchManagementTagActionTargetByIdRequest struct {
	ctx                                       context.Context
	ApiService                                *BasicDetectionRulesAPIService
	actionId                                  string
	patchManagementTagActionTargetByIdRequest *PatchManagementTagActionTargetByIdRequest
}

func (r ApiPatchManagementTagActionTargetByIdRequest) PatchManagementTagActionTargetByIdRequest(patchManagementTagActionTargetByIdRequest PatchManagementTagActionTargetByIdRequest) ApiPatchManagementTagActionTargetByIdRequest {
	r.patchManagementTagActionTargetByIdRequest = &patchManagementTagActionTargetByIdRequest
	return r
}

func (r ApiPatchManagementTagActionTargetByIdRequest) Execute() (*PatchManagementTagActionTargetByIdRequest, *http.Response, error) {
	return r.ApiService.PatchManagementTagActionTargetByIdExecute(r)
}

/*
PatchManagementTagActionTargetById Modify the Targets Attached To A Notification

Using the ID of a notification, modify the notification target that is attached to it.
This endpoint only allows updating a notification to have one notification target attached to it.
To attach multiple targets to a notification you can use the ["management/actions"](#operation/patchManagementTagActionById) endpoint.
For more context on basic detection rules, notification, notification targets, and labels,
as well as instructions on handling rate limits, consult [this section's introduction](#tag/Basic-Detection-Rules).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param actionId \\ The id of the notification.
	@return ApiPatchManagementTagActionTargetByIdRequest
*/
func (a *BasicDetectionRulesAPIService) PatchManagementTagActionTargetById(ctx context.Context, actionId string) ApiPatchManagementTagActionTargetByIdRequest {
	return ApiPatchManagementTagActionTargetByIdRequest{
		ApiService: a,
		ctx:        ctx,
		actionId:   actionId,
	}
}

// Execute executes the request
//
//	@return PatchManagementTagActionTargetByIdRequest
func (a *BasicDetectionRulesAPIService) PatchManagementTagActionTargetByIdExecute(r ApiPatchManagementTagActionTargetByIdRequest) (*PatchManagementTagActionTargetByIdRequest, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PatchManagementTagActionTargetByIdRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BasicDetectionRulesAPIService.PatchManagementTagActionTargetById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/management/actions/{action_id}/targets"
	localVarPath = strings.Replace(localVarPath, "{"+"action_id"+"}", url.PathEscape(parameterValueTostring(r.actionId, "actionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchManagementTagActionTargetByIdRequest == nil {
		return localVarReturnValue, nil, reportError("patchManagementTagActionTargetByIdRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchManagementTagActionTargetByIdRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchManagementTagByIdRequest struct {
	ctx                           context.Context
	ApiService                    *BasicDetectionRulesAPIService
	tagId                         string
	patchManagementTagByIdRequest *PatchManagementTagByIdRequest
}

func (r ApiPatchManagementTagByIdRequest) PatchManagementTagByIdRequest(patchManagementTagByIdRequest PatchManagementTagByIdRequest) ApiPatchManagementTagByIdRequest {
	r.patchManagementTagByIdRequest = &patchManagementTagByIdRequest
	return r
}

func (r ApiPatchManagementTagByIdRequest) Execute() (*PostManagementTags201Response, *http.Response, error) {
	return r.ApiService.PatchManagementTagByIdExecute(r)
}

/*
PatchManagementTagById Modify a Basic Detection Rule

For more context on basic detection rules, notification, notification targets, and labels,
as well as instructions on handling rate limits, consult [this section's introduction](#tag/Basic-Detection-Rules).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tagId \\ The id of the change detection rule.
	@return ApiPatchManagementTagByIdRequest
*/
func (a *BasicDetectionRulesAPIService) PatchManagementTagById(ctx context.Context, tagId string) ApiPatchManagementTagByIdRequest {
	return ApiPatchManagementTagByIdRequest{
		ApiService: a,
		ctx:        ctx,
		tagId:      tagId,
	}
}

// Execute executes the request
//
//	@return PostManagementTags201Response
func (a *BasicDetectionRulesAPIService) PatchManagementTagByIdExecute(r ApiPatchManagementTagByIdRequest) (*PostManagementTags201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PostManagementTags201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BasicDetectionRulesAPIService.PatchManagementTagById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/management/tags/{rule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"tag_id"+"}", url.PathEscape(parameterValueTostring(r.tagId, "tagId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.patchManagementTagByIdRequest == nil {
		return localVarReturnValue, nil, reportError("patchManagementTagByIdRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchManagementTagByIdRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostLabelsRequest struct {
	ctx         context.Context
	ApiService  *BasicDetectionRulesAPIService
	createLabel *CreateLabel
}

func (r ApiPostLabelsRequest) CreateLabel(createLabel CreateLabel) ApiPostLabelsRequest {
	r.createLabel = &createLabel
	return r
}

func (r ApiPostLabelsRequest) Execute() (*LabelResponse, *http.Response, error) {
	return r.ApiService.PostLabelsExecute(r)
}

/*
PostLabels Create a Label

For more context on basic detection rules, notification, notification targets, and labels,
as well as instructions on handling rate limits, consult [this section's introduction](#tag/Basic-Detection-Rules).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostLabelsRequest
*/
func (a *BasicDetectionRulesAPIService) PostLabels(ctx context.Context) ApiPostLabelsRequest {
	return ApiPostLabelsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return LabelResponse
func (a *BasicDetectionRulesAPIService) PostLabelsExecute(r ApiPostLabelsRequest) (*LabelResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LabelResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BasicDetectionRulesAPIService.PostLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/management/labels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createLabel == nil {
		return localVarReturnValue, nil, reportError("createLabel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createLabel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostManagementTagActionsRequest struct {
	ctx                             context.Context
	ApiService                      *BasicDetectionRulesAPIService
	postManagementTagActionsRequest *PostManagementTagActionsRequest
}

func (r ApiPostManagementTagActionsRequest) PostManagementTagActionsRequest(postManagementTagActionsRequest PostManagementTagActionsRequest) ApiPostManagementTagActionsRequest {
	r.postManagementTagActionsRequest = &postManagementTagActionsRequest
	return r
}

func (r ApiPostManagementTagActionsRequest) Execute() (*PostManagementTagActions201Response, *http.Response, error) {
	return r.ApiService.PostManagementTagActionsExecute(r)
}

/*
PostManagementTagActions Create a Notification

For more context on basic detection rules, notification, notification targets, and labels,
as well as instructions on handling rate limits, consult [this section's introduction](#tag/Basic-Detection-Rules).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostManagementTagActionsRequest
*/
func (a *BasicDetectionRulesAPIService) PostManagementTagActions(ctx context.Context) ApiPostManagementTagActionsRequest {
	return ApiPostManagementTagActionsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PostManagementTagActions201Response
func (a *BasicDetectionRulesAPIService) PostManagementTagActionsExecute(r ApiPostManagementTagActionsRequest) (*PostManagementTagActions201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PostManagementTagActions201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BasicDetectionRulesAPIService.PostManagementTagActions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/management/actions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postManagementTagActionsRequest == nil {
		return localVarReturnValue, nil, reportError("postManagementTagActionsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postManagementTagActionsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostManagementTagsRequest struct {
	ctx                       context.Context
	ApiService                *BasicDetectionRulesAPIService
	postManagementTagsRequest *PostManagementTagsRequest
}

func (r ApiPostManagementTagsRequest) PostManagementTagsRequest(postManagementTagsRequest PostManagementTagsRequest) ApiPostManagementTagsRequest {
	r.postManagementTagsRequest = &postManagementTagsRequest
	return r
}

func (r ApiPostManagementTagsRequest) Execute() (*PostManagementTags201Response, *http.Response, error) {
	return r.ApiService.PostManagementTagsExecute(r)
}

/*
PostManagementTags Create A Basic Detection Rule

For more context on basic detection rules, notification, notification targets, and labels,
as well as instructions on handling rate limits, consult [this section's introduction](#tag/Basic-Detection-Rules).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostManagementTagsRequest
*/
func (a *BasicDetectionRulesAPIService) PostManagementTags(ctx context.Context) ApiPostManagementTagsRequest {
	return ApiPostManagementTagsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PostManagementTags201Response
func (a *BasicDetectionRulesAPIService) PostManagementTagsExecute(r ApiPostManagementTagsRequest) (*PostManagementTags201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PostManagementTags201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BasicDetectionRulesAPIService.PostManagementTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/management/tags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postManagementTagsRequest == nil {
		return localVarReturnValue, nil, reportError("postManagementTagsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postManagementTagsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostManagementTargetsRequest struct {
	ctx             context.Context
	ApiService      *BasicDetectionRulesAPIService
	createPutTarget *CreatePutTarget
}

func (r ApiPostManagementTargetsRequest) CreatePutTarget(createPutTarget CreatePutTarget) ApiPostManagementTargetsRequest {
	r.createPutTarget = &createPutTarget
	return r
}

func (r ApiPostManagementTargetsRequest) Execute() (*TargetResponse, *http.Response, error) {
	return r.ApiService.PostManagementTargetsExecute(r)
}

/*
PostManagementTargets Create a Target

For more context on basic detection rules, notification, notification targets, and labels,
as well as instructions on handling rate limits, consult [this section's introduction](#tag/Basic-Detection-Rules).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostManagementTargetsRequest
*/
func (a *BasicDetectionRulesAPIService) PostManagementTargets(ctx context.Context) ApiPostManagementTargetsRequest {
	return ApiPostManagementTargetsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return TargetResponse
func (a *BasicDetectionRulesAPIService) PostManagementTargetsExecute(r ApiPostManagementTargetsRequest) (*TargetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TargetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BasicDetectionRulesAPIService.PostManagementTargets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/management/targets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createPutTarget == nil {
		return localVarReturnValue, nil, reportError("createPutTarget is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createPutTarget
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutLabelByIdRequest struct {
	ctx        context.Context
	ApiService *BasicDetectionRulesAPIService
	labelId    string
	putLabel   *PutLabel
}

func (r ApiPutLabelByIdRequest) PutLabel(putLabel PutLabel) ApiPutLabelByIdRequest {
	r.putLabel = &putLabel
	return r
}

func (r ApiPutLabelByIdRequest) Execute() (*LabelResponse, *http.Response, error) {
	return r.ApiService.PutLabelByIdExecute(r)
}

/*
PutLabelById Replace a Label

For more context on basic detection rules, notification, notification targets, and labels,
as well as instructions on handling rate limits, consult [this section's introduction](#tag/Basic-Detection-Rules).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param labelId \\ The ID of the label to be queried.
	@return ApiPutLabelByIdRequest
*/
func (a *BasicDetectionRulesAPIService) PutLabelById(ctx context.Context, labelId string) ApiPutLabelByIdRequest {
	return ApiPutLabelByIdRequest{
		ApiService: a,
		ctx:        ctx,
		labelId:    labelId,
	}
}

// Execute executes the request
//
//	@return LabelResponse
func (a *BasicDetectionRulesAPIService) PutLabelByIdExecute(r ApiPutLabelByIdRequest) (*LabelResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LabelResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BasicDetectionRulesAPIService.PutLabelById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/management/labels/{label_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"label_id"+"}", url.PathEscape(parameterValueTostring(r.labelId, "labelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.putLabel == nil {
		return localVarReturnValue, nil, reportError("putLabel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.putLabel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutManagementTagActionByIdRequest struct {
	ctx                             context.Context
	ApiService                      *BasicDetectionRulesAPIService
	actionId                        string
	postManagementTagActionsRequest *PostManagementTagActionsRequest
}

func (r ApiPutManagementTagActionByIdRequest) PostManagementTagActionsRequest(postManagementTagActionsRequest PostManagementTagActionsRequest) ApiPutManagementTagActionByIdRequest {
	r.postManagementTagActionsRequest = &postManagementTagActionsRequest
	return r
}

func (r ApiPutManagementTagActionByIdRequest) Execute() (*PostManagementTagActions201Response, *http.Response, error) {
	return r.ApiService.PutManagementTagActionByIdExecute(r)
}

/*
PutManagementTagActionById Replace a Notification

For more context on basic detection rules, notification, notification targets, and labels,
as well as instructions on handling rate limits, consult [this section's introduction](#tag/Basic-Detection-Rules).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param actionId \\ The id of the notification.
	@return ApiPutManagementTagActionByIdRequest
*/
func (a *BasicDetectionRulesAPIService) PutManagementTagActionById(ctx context.Context, actionId string) ApiPutManagementTagActionByIdRequest {
	return ApiPutManagementTagActionByIdRequest{
		ApiService: a,
		ctx:        ctx,
		actionId:   actionId,
	}
}

// Execute executes the request
//
//	@return PostManagementTagActions201Response
func (a *BasicDetectionRulesAPIService) PutManagementTagActionByIdExecute(r ApiPutManagementTagActionByIdRequest) (*PostManagementTagActions201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PostManagementTagActions201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BasicDetectionRulesAPIService.PutManagementTagActionById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/management/actions/{action_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"action_id"+"}", url.PathEscape(parameterValueTostring(r.actionId, "actionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postManagementTagActionsRequest == nil {
		return localVarReturnValue, nil, reportError("postManagementTagActionsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postManagementTagActionsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutManagementTagByIdRequest struct {
	ctx                         context.Context
	ApiService                  *BasicDetectionRulesAPIService
	tagId                       string
	putManagementTagByIdRequest *PutManagementTagByIdRequest
}

func (r ApiPutManagementTagByIdRequest) PutManagementTagByIdRequest(putManagementTagByIdRequest PutManagementTagByIdRequest) ApiPutManagementTagByIdRequest {
	r.putManagementTagByIdRequest = &putManagementTagByIdRequest
	return r
}

func (r ApiPutManagementTagByIdRequest) Execute() (*PostManagementTags201Response, *http.Response, error) {
	return r.ApiService.PutManagementTagByIdExecute(r)
}

/*
PutManagementTagById Replace a Basic Detection Rule

For more context on basic detection rules, notification, notification targets, and labels,
as well as instructions on handling rate limits, consult [this section's introduction](#tag/Basic-Detection-Rules).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tagId \\ The id of the change detection rule.
	@return ApiPutManagementTagByIdRequest
*/
func (a *BasicDetectionRulesAPIService) PutManagementTagById(ctx context.Context, tagId string) ApiPutManagementTagByIdRequest {
	return ApiPutManagementTagByIdRequest{
		ApiService: a,
		ctx:        ctx,
		tagId:      tagId,
	}
}

// Execute executes the request
//
//	@return PostManagementTags201Response
func (a *BasicDetectionRulesAPIService) PutManagementTagByIdExecute(r ApiPutManagementTagByIdRequest) (*PostManagementTags201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PostManagementTags201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BasicDetectionRulesAPIService.PutManagementTagById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/management/tags/{rule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"tag_id"+"}", url.PathEscape(parameterValueTostring(r.tagId, "tagId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.putManagementTagByIdRequest == nil {
		return localVarReturnValue, nil, reportError("putManagementTagByIdRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.putManagementTagByIdRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutManagementTargetByIdRequest struct {
	ctx             context.Context
	ApiService      *BasicDetectionRulesAPIService
	targetId        string
	createPutTarget *CreatePutTarget
}

func (r ApiPutManagementTargetByIdRequest) CreatePutTarget(createPutTarget CreatePutTarget) ApiPutManagementTargetByIdRequest {
	r.createPutTarget = &createPutTarget
	return r
}

func (r ApiPutManagementTargetByIdRequest) Execute() (*TargetResponse, *http.Response, error) {
	return r.ApiService.PutManagementTargetByIdExecute(r)
}

/*
PutManagementTargetById Replace a Target

For more context on basic detection rules, notification, notification targets, and labels,
as well as instructions on handling rate limits, consult [this section's introduction](#tag/Basic-Detection-Rules).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param targetId \\ The id of the notification target.
	@return ApiPutManagementTargetByIdRequest
*/
func (a *BasicDetectionRulesAPIService) PutManagementTargetById(ctx context.Context, targetId string) ApiPutManagementTargetByIdRequest {
	return ApiPutManagementTargetByIdRequest{
		ApiService: a,
		ctx:        ctx,
		targetId:   targetId,
	}
}

// Execute executes the request
//
//	@return TargetResponse
func (a *BasicDetectionRulesAPIService) PutManagementTargetByIdExecute(r ApiPutManagementTargetByIdRequest) (*TargetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TargetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BasicDetectionRulesAPIService.PutManagementTargetById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/management/targets/{target_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"target_id"+"}", url.PathEscape(parameterValueTostring(r.targetId, "targetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createPutTarget == nil {
		return localVarReturnValue, nil, reportError("createPutTarget is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createPutTarget
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
