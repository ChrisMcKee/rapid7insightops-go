openapi: 3.0.2
info:
  contact:
    email: support@rapid7.com
  description: |
    ### Overview

    Our REST API lets you use InsightOps through HTTP requests.
    Currently, the REST API allows you to perform the majority of the actions available through the UI, and has some
    additional functionality that is not available through the UI.
    You may use this API to automate common tasks (for example, via shell scripts), and to generally interact with InsightOps
    programmatically.

    This page precisely describes the REST API and serves as a reference for the API.
    Each HTTP method and each URL endpoint is documented in a self-contained unit
    so that users only need to read about the HTTP methods relevant to them.

    ### Terminology

    * A **log entry** is an individual log event.
    * A **log** is a collection of log entries, or a single log stream.
    * A **log set** is a logical-only collection of logs, i.e. logs can be in multiple logsets and deleting a logset only deletes the relation between logs, not the logs themselves.
    * [Log Entry Query Language](https://docs.rapid7.com/insightops/log-search) (**LEQL**) is the query language used in
    Insight Ops to search log data.
  title: InsightOps REST API
  version: latest
servers:
- description: Europe
  url: https://eu.rest.logs.insight.rapid7.com
- description: United States (Users are automatically assigned to one of 3 US regions)
  url: https://us.rest.logs.insight.rapid7.com
- description: United States (Users are automatically assigned to one of 3 US regions)
  url: https://us2.rest.logs.insight.rapid7.com
- description: United States (Users are automatically assigned to one of 3 US regions)
  url: https://us3.rest.logs.insight.rapid7.com
- description: Canada
  url: https://ca.rest.logs.insight.rapid7.com
- description: Australia
  url: https://au.rest.logs.insight.rapid7.com
- description: Japan
  url: https://ap.rest.logs.insight.rapid7.com
tags:
- description: "You can perform queries on your log data by using the LEQL query language.\
    \ For information on LEQL consult the\n[LEQL documentation page](https://docs.rapid7.com/insightidr/use-a-search-language/),\
    \ and our \n[LEQL example queries](https://docs.rapid7.com/insightidr/example-queries/).\n\
    \n### Query Types\nThere are two fundamentally different types of queries, which\
    \ return different response body structures:\n* **Event Search** queries do not\
    \ contain a `calculate` clause and return a list of log lines in the\nresponse.\
    \ When the number of log lines matching your query is large, the response will\
    \ be paginated, and you will \nneed to send further requests to retrieve the following\
    \ pages of log lines (more details on this below).\n* **Statistical Search** queries\
    \ contain a `calculate` clause and return a number rather \nthan a list of log\
    \ lines. These queries do not require you to handle any pagination. Additionally,\
    \ the response body\nwill have a different structure depending on whether the\
    \ query contains a `groupby` clause.\n\n### Polling In-Progress Queries\nIn many\
    \ cases the initial response will not contain the complete results, instead the\
    \ response will indicate that\nthe query was created and is in progress. The query\
    \ must then be polled until it is completed.\n\nIf the query must be polled, there\
    \ will be a `\"links\"` array in the response which contains a link object that\
    \ has \n`\"rel\"` equal to `\"Self\"` (see response schemas below).\n\nTo poll\
    \ the in-progress query, make a `GET` request to the value of `\"href\"` in that\
    \ link object. \nFor example, if the response looks like\n```\n{\n...,\n  \"links\"\
    : [\n    {\n      \"rel\": \"Self\",\n      \"href\": \"https://eu.rest.logs.insight.rapid7.com/log_search/query/b79b0082-6255-4f85-b2e6-0041b179b1ff:1:38cdc7c1fb508f8e384536b77ce495fda2185be0::d472eb0c00d8aeddbc2b5386ad0d7c560323d443:\"\
    \n    }\n  ],\n...\n}\n```\nThen you must make a `GET` request to \n```\nhttps://eu.rest.logs.insight.rapid7.com/log_search/query/b79b0082-6255-4f85-b2e6-0041b179b1ff:1:38cdc7c1fb508f8e384536b77ce495fda2185be0::d472eb0c00d8aeddbc2b5386ad0d7c560323d443:\n\
    ```\n\nIf further polls are needed, then the response to your polling request\
    \ will once again contain a `\"links\"` array in the \nresponse with link object\
    \ that has `\"rel\"` equal to `\"Self\"`. \n\nPolling links must be polled **at\
    \ least every 20 seconds**, \nor they will expire. However they should also not\
    \ be polled too frequently, or you risk being rate limited \n(more details on\
    \ rate limiting below).\n\nA query is completed and requires no further polling\
    \ when there is either no `\"links\"` array in the response, or\nthere is no link\
    \ object with `\"rel\"` equal to `\"Self\"`.\n\n### Pagination\n\nAny search queries\
    \ with over 50 results (by default) will return a paginated response. If there\
    \ is another page\nof results, then there will be a `\"links\"` array in the response\
    \ which has `\"rel\"` equal to `\"Next\"`. For example\nif the response looks\
    \ like\n```\n{\n...,\n\"links\": [\n  {\n    \"rel\": \"Next\",\n    \"href\"\
    : \"https://eu.rest.logs.insight.rapid7.com/log_search/query/logs/17e958e2-0000-0000-0000-000000000000?from=1684763133211&to=1684763203000&per_page=1&sequence_number=3237198280324534273&next_page=true\"\
    \n  }\n],\n...\n}\n```\nThen you can fetch the next page of results by making\
    \ a `GET` request to\n```\nhttps://eu.rest.logs.insight.rapid7.com/log_search/query/logs/17e958e2-0000-0000-0000-000000000000?from=1684763133211&to=1684763203000&per_page=1&sequence_number=3237198280324534273&next_page=true\n\
    ```\n\nNote that a new query is launched when fetching the next page of results,\
    \ and hence you may need to poll the \n`\"Self\"` link until the query is completed.\
    \ It is only possible to paginate forwards, backward pagination is not supported.\n\
    \n\n### Rate Limits\nBy default, users are limited to making 1,500 queries and\
    \ 10,000 polling requests within a 15 minute window.\nFor every query request\
    \ or polling request you make, the response will contain an `X-RateLimit-Remaining`\
    \ header\nwhich tells you how many further requests you can make within this 15\
    \ minute window before hitting the limit.\n\nThe API will return responses with\
    \ status code 429 when this limit is reached, and will contain an `X-RateLimit-Reset`\
    \ \nheader, which tells you the number of seconds you must wait before your limit\
    \ is reset.\n\nNote that if you are rate limited while making a polling request,\
    \ then the polling link will likely expire before\nthe limit is reset, and you\
    \ will need to make the initial query request again after the limit is reset.\n"
  name: Query Log Data
- description: "Logs are a collection of timestamped log entries.\nYou can search\
    \ your logs and use numerical functions to dig deeper into your log data. (See\
    \ the [\"Query Log Data\"](#tag/Query-Log-Data) section).\nNotifications can be\
    \ set up to trigger when certain behaviours occur in the log data (see the [\"\
    Basic Detection Rules\"](#tag/Basic-Detection-Rules) section).\nAdditionally,\
    \ the log entries may be [downloaded](#tag/Download-Log-Data), [backed up to S3](#tag/Backup-Your-Log-Data-To-S3),\
    \ \nand [exported to CSV](#tag/Export-Log-Data-To-CSV).\n\nFor your convenience,\
    \ logs are grouped into log sets. The same log may belong to multiple log sets.\n\
    [Read more about logs, log sets and Log Search](https://docs.rapid7.com/insightops/using-log-search/).\n\
    \n### Rate Limits\nBy default, users are limited to making 1500 requests to the\
    \ \"/management\" namespace within a 15 minute window.\nFor every request you\
    \ make, the response contains an `X-RateLimit-Remaining` header, which tells you\
    \ how many \nadditional requests you can make within this 15 minute window before\
    \ hitting the limit.\n\nThe API returns responses with status code 429 when this\
    \ limit is reached, and contains an `X-RateLimit-Reset`\nheader, which tells you\
    \ the number of seconds you must wait before your limit is reset.\n"
  name: Logs & Log Sets
- description: "Basic detection rules allow you to receive notifications when certain\
    \ behaviours occurs in your log data.\nThere are three types of basic detection\
    \ rules: log pattern detections rules, log inactivity detection rules, and log\
    \ change detection rules.\n[Read more about basic detection rules](https://docs.rapid7.com/insightidr/create-and-manage-custom-alerts).\n\
    \nIn the REST API, a basic detection rule is made up of are three components:\n\
    \  * The rule itself (labeled as \"tags\" in the JSON payloads).\n  * One or more\
    \ notifications that are attached to rules and define the notification behaviour\
    \ (labeled as \"actions\" in the JSON payloads).\n  * One or more notification\
    \ targets that are attached to notifications and define the destination for the\
    \ notification (labeled as \"targets\" in the JSON payloads).\n\nAdditionally,\
    \ pattern detection rules may have one or more labels attached to them. \nThese\
    \ labels are returned together with log entries when you search your log data,\
    \ \nand can be used to filter your data when performing a search. If you choose\
    \ to use pattern detection rules to \nonly apply labels, notifications do not\
    \ need to be attached.\n\n### Rate Limits\nBy default, users are limited to making\
    \ 1500 requests to the \"/management\" namespace within a 15 minute window.\n\
    For every request you make, the response contains an `X-RateLimit-Remaining` header,\
    \ which tells you how many \nadditional requests you can make within this 15 minute\
    \ window before hitting the limit.\n\nThe API returns responses with status code\
    \ 429 when this limit is reached, and contains an `X-RateLimit-Reset`\nheader,\
    \ which tells you the number of seconds you must wait before your limit is reset.\n"
  name: Basic Detection Rules
- description: "A LEQL variable is a placeholder in a LEQL query that represents one\
    \ or more values that you can use when you\n[query your log data](#tag/Query-Log-Data)\
    \ or configure [basic detection rules](#tag/Basic-Detection-Rules). \nBy storing\
    \ and reusing values, you can streamline your queries to make them shorter and\
    \ easier to enter. \n[Read more about LEQL variables](https://docs.rapid7.com/insightidr/use-variables-in-queries/).\n\
    \n### Rate Limits\nBy default, users are limited to making 1500 requests to the\
    \ \"/management\" namespace within a 15 minute window.\nFor every request you\
    \ make, the response contains an `X-RateLimit-Remaining` header, which tells you\
    \ how many \nadditional requests you can make within this 15 minute window before\
    \ hitting the limit.\n\nThe API returns responses with status code 429 when this\
    \ limit is reached, and contains an `X-RateLimit-Reset`\nheader, which tells you\
    \ the number of seconds you must wait before your limit is reset.\n"
  name: LEQL Variables
- description: "The details of a Log Search query can be stored as a saved query so\
    \ those details do not have to be entered \nmanually the next time you run the\
    \ query. A saved query consists of 3 parts:\n* **A LEQL statement**\n* **A time\
    \ range (optional)** - If omitted, the time range must be specified when you use\
    \ the saved query.\n* **Logs to query (optional)** - If omitted, logs must be\
    \ specified when you use the saved query.\n\n### Rate Limits\nBy default, users\
    \ are limited to making 1,500 requests to the \"/query\" namespace within a 15\
    \ minute window.\nFor every request you make, the response contains an `X-RateLimit-Remaining`\
    \ header, which tells you how many \nadditional requests you can make within this\
    \ 15 minute window before hitting the limit.\n\nThe API returns responses with\
    \ status code 429 when this limit is reached, and contains an `X-RateLimit-Reset`\n\
    header, which tells you the number of seconds you must wait before your limit\
    \ is reset.\n"
  name: Saved Queries
- description: "You can query your log data using the LEQL query language. For information\
    \ on LEQL consult the\n[LEQL documentation page](https://docs.rapid7.com/insightidr/use-a-search-language/),\
    \ and our \n[LEQL example queries](https://docs.rapid7.com/insightidr/example-queries/).\n\
    \n**Statistical queries** are those that contain a `calculate` clause and return\
    \ a number rather than a list\nof log lines. \n\nPre-computed queries compute\
    \ the results for a statistical search in real time, as log entries are\nreceived\
    \ by the Log Search system. This means that results are available immediately\
    \ and can be returned much \nfaster than a conventional search. For this reason\
    \ you may consider using a pre-computed query if:\n* You regularly perform a statistical\
    \ search with the same LEQL statement on the same logs\n* Your statistical search\
    \ typically takes a long time to return results.\n\nUsers are limited to creating\
    \ 10 pre-computed queries. \nUnlike regular Log Search queries, there is no need\
    \ to poll queries until they are complete, or handle pagination.\n\n### Rate Limits\
    \   \nBy default, users are limited to making 1,500 requests to the \"/query\"\
    \ namespace (for fetching the results for a \nPre-Computed Query) within a 15\
    \ minute window, and 1,500 requests to the \"/management\" \n(for creating and\
    \ modifying a Pre-Computed Query) namespace within a 15 minute window.\nFor every\
    \ request you make, the response contains an `X-RateLimit-Remaining` header, which\
    \ tells you how many \nadditional requests you can make within this 15 minute\
    \ window before hitting the limit.\n\nThe API returns responses with status code\
    \ 429 when this limit is reached, and contains an `X-RateLimit-Reset`\nheader,\
    \ which tells you the number of seconds you must wait before your limit is reset.\n"
  name: Pre-Computed Queries
- description: "You can download your log data in plain text with the REST API.\n\
    The download includes all the LEQL query's results, or, if no query is provided,\n\
    all log entries are included in the download. For information on LEQL consult\
    \ the\n[LEQL documentation page](https://docs.rapid7.com/insightidr/use-a-search-language/),\
    \ and our \n[LEQL example queries](https://docs.rapid7.com/insightidr/example-queries/).\n\
    \n### Rate Limits\nBy default, users are limited to making 300 download requests\
    \ within a 15 minute window.\nFor every request you make, the response contains\
    \ an `X-RateLimit-Remaining` header, which tells you how many \nadditional requests\
    \ you can make within this 15 minute window before hitting the limit.\n\nThe API\
    \ returns responses with status code 429 when this limit is reached, and contains\
    \ an `X-RateLimit-Reset`\nheader, which tells you the number of seconds you must\
    \ wait before your limit is reset.\n"
  name: Download Log Data
- description: "You can export log data as a CSV file to share with stakeholders at\
    \ your convenience. \n[Read more about exporting your log entries as a CSV file](https://docs.rapid7.com/insightidr/log-search/#export-your-data).\n\
    \nThe API below allows you view the progress of export jobs and obtain the links\
    \ to download the CSV file for any \ncompleted export jobs. Only one export job\
    \ can be processed at a time for an organization.\n\nTo initiate an export job,\
    \ use the **/query** endpoints and specify the **export_format** query parameter\
    \ \n(See the [\"Query Log Data\"](#tag/Query-Log-Data) section).\n\n### Rate Limits\n\
    By default, users are limited to making 500 export requests within a 15 minute\
    \ window.\nFor every request you make, the response contains an `X-RateLimit-Remaining`\
    \ header, which tells you how many \nadditional requests you can make within this\
    \ 15 minute window before hitting the limit.\n\nThe API returns responses with\
    \ status code 429 when this limit is reached, and contains an `X-RateLimit-Reset`\n\
    header, which tells you the number of seconds you must wait before your limit\
    \ is reset.\n"
  name: Export Log Data To CSV
- description: "You can use the **/usage/organizations** endpoints to view the amount\
    \ of log data that you have stored, in bytes, for any time range, across:\n* All\
    \ of your organization's log data\n* Individual logs\n\n### Rate Limits\nBy default,\
    \ users are limited to making 500 requests to the \"/usage\" namespace within\
    \ a 15 minute window.\nFor every request you make, the response contains an `X-RateLimit-Remaining`\
    \ header, which tells you how many \nadditional requests you can make within this\
    \ 15 minute window before hitting the limit.\n\nThe API returns responses with\
    \ status code 429 when this limit is reached, and contains an `X-RateLimit-Reset`\n\
    header, which tells you the number of seconds you must wait before your limit\
    \ is reset.\n"
  name: Explore The Size of Your Log Data
- description: "Data archiving allows you to retain a copy of your log data using\
    \ the storage capabilities of Amazon S3. \n[Read more about data archiving](https://docs.rapid7.com/insightidr/data-archiving/).\n\
    To use the data archiving feature, you will need to grant Rapid7 access to your\
    \ organization's bucket.\n[Instructions can be found here](https://docs.rapid7.com/insightidr/data-archiving/#configure-an-amazon-s3-bucket).\n\
    \nThere are two types of archiving available.\n* **Daily archiving** - Occurs\
    \ once a day and sends all of the log data received in the past day to your S3\
    \ bucket in a compressed file format.\n* **Historical archiving** - Occurs on\
    \ demand and sends all of the log data in your specified time range to your S3\
    \ bucket in a compressed file format.\n  The process of archiving a large amount\
    \ of data can take several days, thus this process is limited to only twice each\
    \ year.\n\n### Rate Limits\nBy default, users are limited to making 1500 requests\
    \ to the \"/management\" namespace within a 15 minute window.\nFor every request\
    \ you make, the response contains an `X-RateLimit-Remaining` header, which tells\
    \ you how many \nadditional requests you can make within this 15 minute window\
    \ before hitting the limit.\n\nThe API returns responses with status code 429\
    \ when this limit is reached, and contains an `X-RateLimit-Reset`\nheader, which\
    \ tells you the number of seconds you must wait before your limit is reset.\n"
  name: Backup Your Log Data To S3
- description: "[Keys](https://docs.rapid7.com/insightidr/ls-glossary/#key) are constants\
    \ that define the data in your logs.\nFor example, the key could be `geoip_country_name`\
    \ and a value that pertains to that category might be `United States`.\n[Read\
    \ more about common keys for various logs](https://docs.rapid7.com/insightidr/keys-to-use-in-your-queries/).\n\
    \nThe API allows you to fetch the most commonly occurring keys that appear for\
    \ any given log, sorted in order from least common to most common.\nIf there have\
    \ been more than 1000 distinct keys in that log's data, then only the 1000 most\
    \ common keys will be returned.\nEach key is returned together with a `weight`,\
    \ which is a number representing how commonly occurring the key is. \nThe weight\
    \ of a key is determined by the number of times the key has occurred, combined\
    \ with how long ago the occurrences happened\n(recent occurrences impact the weight\
    \ of a key more than older occurrences do).\n\n### Rate Limits\nBy default, users\
    \ are limited to making 1500 requests to the \"/management\" namespace within\
    \ a 15 minute window.\nFor every request you make, the response contains an `X-RateLimit-Remaining`\
    \ header, which tells you how many \nadditional requests you can make within this\
    \ 15 minute window before hitting the limit.\n\nThe API returns responses with\
    \ status code 429 when this limit is reached, and contains an `X-RateLimit-Reset`\n\
    header, which tells you the number of seconds you must wait before your limit\
    \ is reset.\n"
  name: Retrieve The Most Common Keys Within Your Log Data
- description: |
    Use the Live Tail API to start a real-time feed of log entries matching a query.
    The query may be performed on any collection of logs (Live Tail on *log sets* is not supported), either by
    providing a LEQL query, or by using a saved query.

    Queries are submitted using the methods and the endpoints described below.
    The endpoints will respond with
    * A `200 OK` response, with a link to poll the live tail feed in the response body.

    Each time a Live Tail feed is polled, all log entries ingested since the last poll, and which match the query are returned.
    A Live Tail feed must be polled **at least every 20 seconds**, or it will expire.
    If there are more than `per_page` results (50 by default) since the last poll,
    only `per_page` results will be returned, and the next page of results is returned the next time the Live Tail feed is polled.
  name: Watch Incoming Log Data In Realtime
- description: |2

    [Audit Logging](https://docs.rapid7.com/insight/audit-logging/) allows you to track and record activity (both user driven and automated) for investigative purposes.
    For every auditable action, you can see what the action was, the time that the action occurred, and who completed the action.
  name: Audit API
paths:
  /query:
    get:
      operationId: getQueryEndpoints
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/ListEndpoints/value
              schema:
                $ref: '#/components/schemas/ListEndpointsResponse'
          description: Endpoints in Response Body.
      summary: List All Endpoints
      tags:
      - Query Log Data
  /query/logs/{log_keys}:
    get:
      description: |
        Submit the query specified in the query parameters for the log with that **{log_key}**.
        For instructions on polling a query until it is completed, handling pagination, and handling rate limits, consult
        [this section's introduction](#tag/Query-Log-Data).
      operationId: getQueryLogs
      parameters:
      - description: |
          \
          The key of the log to be queried.

          Supplying multiple ':' separated log keys is deprecated;
          users should instead 'POST' the query as a JSON payload to [/query/logs](#operation/postQueryLogs).
        example: /query/logs/565c1b7b-c08b-4c87-a42a-ab08bad56071
        in: path
        name: log_keys
        required: true
        schema:
          type: string
      - description: |
          \
          A valid LEQL query to run against the log.
          If omitted, the query retrieves all log entries in the specified time range.
        example: where(foo=bar)
        in: query
        name: query
        required: false
        schema:
          type: string
      - description: |
          \
          The start of the time range for the query, as a UNIX timestamp in milliseconds.
        example: 1450557004000
        in: query
        name: from
        required: true
        schema:
          type: integer
      - description: |
          \
          The end of the time range for the query, as a UNIX timestamp in milliseconds.
        example: 1460557604000
        in: query
        name: to
        required: true
        schema:
          type: integer
      - description: |
          \
          An alternative to the `from` and `to` query parameters. Supported values:
          * `yesterday`
          * `today`
          * `last x timeunits` where x is the number of time unit back from the current server time. Supported time units (case insensitive):
              - min(s) or minute(s)
              - hr(s) or hour(s)
              - day(s)
              - week(s)
              - month(s)
              - year(s)

          If `time_range` is used, then the `from` and `to` query parameters must not be used.
        example: last 5 minutes
        in: query
        name: time_range
        required: false
        schema:
          type: string
      - description: |
          \
          Only entries which have a label with this UUID will be returned.
          This only works with non-statistical queries (i.e. no 'groupby' or 'calculate' clauses).
        example: 00000000-0000-0000-0000-000000000001
        in: query
        name: label
        required: false
        schema:
          type: string
      - description: |
          \
          A set of ':' separated label UUIDs. Only entries which have a label matching one of these UUIDs will be returned.
          This only works with non-statistical queries (i.e. no 'groupby' or 'calculate' clauses).
          Takes precedence over the 'label' parameter.
        example: 00000000-0000-0000-0000-000000000001:21b21bb8-8869-4e2c-98df-684892e4e112
        in: query
        name: labels
        required: false
        schema:
          type: string
      - description: |
          \
          Number of log entries to return per page, up to 500(the maximum allowed).
        example: 100
        in: query
        name: per_page
        required: false
        schema:
          default: 50
          type: integer
      - description: |
          \
          If included, the query results will be exported to the given format.

          * Currently only `csv` is supported.
          * This parameter is only for non-statistical search queries (i.e. no 'calculate' and/or 'groupby' clauses).
          * Results are limited to the first 1 million log entries, and only one export job may run per account at a time.

          The response will be a 202, and the response body will contain a link for polling the export job (on the **/exports/{id}** endpoint).
        example: csv
        in: query
        name: export_format
        required: false
        schema:
          type: string
      - description: |
          \
          When set to true, the `events` object that is returned will additionally contain information about
          all the key-value pairs in each returned log entry.
        example: true
        in: query
        name: kvp_info
        required: false
        schema:
          type: boolean
      - description: |
          \
          When set to `true`, the query returns the most recent events first. When set to `false`, it returns the oldest events first.
        example: true
        in: query
        name: most_recent_first
        required: false
        schema:
          default: false
          type: boolean
      - description: |
          \
          If this query parameter is included, the query results will additionally include all log entries received in the
          `from` millisecond which have sequence numbers larger than the one specified.

          Sequence numbers are identifiers used to distinguish between log entries received in the same millisecond.
          If a log entry was split up into several log entries during ingestion, then those chunks are ordered by sequence number.
        in: query
        name: sequence_number
        required: false
        schema:
          type: integer
      responses:
        "200":
          content:
            application/json:
              examples:
                EventsResponseSimple:
                  $ref: "#/components/examples/~1query~1logs~1{log_keys}"
                EventsResponsePagination:
                  $ref: "#/components/examples/~1query~1logs~1{log_keys}"
                StatisticalResponseSimple:
                  $ref: "#/components/examples/~1query~1logs~1{log_keys}"
                StatisticalResponseTimeSeriesMultiGroupBy:
                  $ref: "#/components/examples/~1query~1logs~1{log_keys}"
              schema:
                $ref: '#/components/schemas/getQueryLogs_200_response'
          description: Results in Response Body.
          headers:
            x-beyond-retention:
              $ref: "#/components/headers/~1query~1logs~1{log_keys}"
            x-beyond-retention-message:
              $ref: "#/components/headers/~1query~1logs~1{log_keys}"
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1logs~1{log_keys}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1logs~1{log_keys}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1logs~1{log_keys}"
        "202":
          content:
            application/json:
              examples:
                EventsContinue:
                  $ref: "#/components/examples/~1query~1logs~1{log_keys}"
                EventsContinueExportCSV:
                  $ref: "#/components/examples/~1query~1logs~1{log_keys}"
                StatsContinueInitial:
                  $ref: "#/components/examples/~1query~1logs~1{log_keys}"
              schema:
                $ref: '#/components/schemas/getQueryLogs_202_response'
          description: Query in Progress. Links in Response Body.
          headers:
            x-beyond-retention:
              $ref: "#/components/headers/~1query~1logs~1{log_keys}"
            x-beyond-retention-message:
              $ref: "#/components/headers/~1query~1logs~1{log_keys}"
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1logs~1{log_keys}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1logs~1{log_keys}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1logs~1{log_keys}"
        "400":
          description: Invalid Query Request.
        "401":
          description: Unauthorized.
        "404":
          description: Log Not Found.
        "415":
          description: Non-JSON request body was given (not that the endpoint takes
            a request body).
        "429":
          content:
            text/plain:
              example: API rate limit exceeded
              schema:
                type: string
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1logs~1{log_keys}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1logs~1{log_keys}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1logs~1{log_keys}"
            Retry-After:
              $ref: "#/components/headers/~1query~1logs~1{log_keys}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Query Individual Logs
      tags:
      - Query Log Data
      x-code-samples:
      - lang: Shell
        label: curl
        source: |
          curl -H 'x-api-key: b865a2555-ab43-4297-a894-a9b5bffb6395' \
          -G \
          --data-urlencode query="where(number<100) calculate(count)" \
          --data from=1609755026007 \
          --data to=1609927826007 \
          https://us.rest.logs.insight.rapid7.com/query/logs/f558ea24-c213-8b99-9a33-8a498121677a
      - lang: Python
        label: Python3.10
        source: "import json\nimport time            \nfrom requests import Response,\
          \ Session\nfrom requests.adapters import HTTPAdapter\nfrom urllib3.util.retry\
          \ import Retry\n\nAPI_KEY = 'YOUR API KEY'\nLOG_KEY = 'YOUR LOG KEY'\nFROM_TS_MILLIS\
          \ = 1684762903000  # Unix epoch\nTO_TS_MILLIS = 1684763203000  # Unix epoch\n\
          DATA_STORAGE_REGION = 'eu'  # Swap for your region\nQUERY = ''\n\n\nclass\
          \ RateLimitedException(Exception):\n    def __init__(self, message: str,\
          \ secs_until_reset: int):\n        super().__init__(message)\n        self.secs_until_reset\
          \ = secs_until_reset\n\n\ndef is_query_in_progress(query_response: Response)\
          \ -> bool:\n    if 'links' not in query_response.json():\n        return\
          \ False\n    elif 'Next' in [link['rel'] for link in query_response.json()['links']]:\n\
          \        return False\n    elif 'Self' in [link['rel'] for link in query_response.json()['links']]:\n\
          \        return True\n    raise Exception('LogSearch query returned an invalid\
          \ response body according to their spec '\n                    '- contains\
          \ a \"links\" object, which does not contain a link with either '\n    \
          \                '\"rel\" equal to \"Next\" or \"Self\"')\n\n\ndef poll_request_to_completion(logsearch_session:\
          \ Session,\n                               query_in_progress_response: Response)\
          \ -> Response:\n    \"\"\"\n    \"continuation\" polls expire after 10 seconds,\
          \ so we must not wait too long between\n    requests. However we must not\
          \ poll too frequently for long-running queries or we\n    risk being rate\
          \ limited.\n    \"\"\"\n    if query_in_progress_response.status_code ==\
          \ 429:\n        secs_until_reset = query_in_progress_response.headers.get('X-RateLimit-Reset')\n\
          \        raise RateLimitedException(\n            f'Log Search API Key was\
          \ rate limited. Seconds until rate limit reset: {secs_until_reset}',\n \
          \           int(secs_until_reset)\n        )\n\n    if not is_query_in_progress(query_in_progress_response):\n\
          \        return query_in_progress_response\n\n    poll_delay_secs = 0.5\n\
          \    max_poll_delay_secs = 6\n    links = {link['rel']: link['href'] for\
          \ link in query_in_progress_response.json()['links']}\n    while 'Self'\
          \ in links:\n        time.sleep(poll_delay_secs)\n\n        resp = logsearch_session.get(links['Self'],\
          \ headers={'x-api-key': API_KEY})\n\n        if resp.status_code == 429:\n\
          \            secs_until_reset = resp.headers.get('X-RateLimit-Reset')\n\
          \            raise RateLimitedException(\n             f'Log Search API\
          \ Key was rate limited. Seconds until rate limit reset: {secs_until_reset}',\n\
          \             int(secs_until_reset)\n            )\n\n        if not is_query_in_progress(resp):\n\
          \            return resp\n\n        poll_delay_secs = min(poll_delay_secs\
          \ * 2, max_poll_delay_secs)\n        links = {link['rel']: link['href']\
          \ for link in resp.json()['links']}\n\n\ndef has_next_page(query_response:\
          \ Response) -> bool:\n    return 'links' in query_response.json() and \\\
          \n           'Next' in [link['rel'] for link in query_response.json()['links']]\n\
          \n\ndef get_next_page_of_results(logsearch_session: Session, resp: Response)\
          \ -> Response:\n    links = {link['rel']: link['href'] for link in resp.json()['links']}\n\
          \    return logsearch_session.get(links['Next'], headers={'x-api-key': API_KEY})\n\
          \n\ndef perform_query(logsearch_session: Session) -> Response:\n    try:\n\
          \        resp = poll_request_to_completion(\n            logsearch_session,\n\
          \            logsearch_session.get(f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/query/logs/{LOG_KEY}',\n\
          \                                  headers={'x-api-key': API_KEY},\n   \
          \                               params={'from': FROM_TS_MILLIS, 'to': TO_TS_MILLIS,\
          \ 'query': QUERY})\n        )\n        print(json.dumps(resp.json(), indent=4))\n\
          \        return resp\n    except RateLimitedException as e:\n        print(f'Log\
          \ Search API Key was rate limited. Sleeping for {e.secs_until_reset} seconds')\n\
          \        time.sleep(e.secs_until_reset)\n        return perform_query(logsearch_session)\n\
          \n\nsession = Session()\nsession.mount(\n    f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',\n\
          \    HTTPAdapter(max_retries=(\n        Retry(total=3,\n              backoff_factor=1,\n\
          \              status_forcelist=[500, 502, 503, 504],\n              respect_retry_after_header=False)\
          \  # Rate limiting must be handled explicitly\n    ))\n)\n\nquery_results_page\
          \ = perform_query(session)\n\nwhile has_next_page(query_results_page):\n\
          \    try:\n        print('Fetching next page of results')\n        query_results_page\
          \ = poll_request_to_completion(\n            session,\n            get_next_page_of_results(session,\
          \ query_results_page)\n        )\n        print(json.dumps(query_results_page.json(),\
          \ indent=4))\n    except RateLimitedException as e:\n        print(f'Log\
          \ Search API Key was rate limited. Sleeping for {e.secs_until_reset} seconds')\n\
          \        time.sleep(e.secs_until_reset)\n"
  /query/logs:
    post:
      description: |
        Submit the query specified in the (JSON) request body and the URL query parameters.

        An arbitrary collection of logs can be specified in the request body.

        For instructions on polling a query until it is completed, handling pagination, and handling rate limits, consult
        [this section's introduction](#tag/Query-Log-Data).
      operationId: postQueryLogs
      parameters:
      - description: |
          \
          Number of log entries to return per page, up to 500(the maximum allowed).
        example: 100
        in: query
        name: per_page
        required: false
        schema:
          default: 50
          type: integer
      - description: |
          \
          If included, the query results will be exported to the given format.

          * Currently only `csv` is supported.
          * This parameter is only for non-statistical search queries (i.e. no 'calculate' and/or 'groupby' clauses).
          * Results are limited to the first 1 million log entries, and only one export job may run per account at a time.

          The response will be a 202, and the response body will contain a link for polling the export job (on the **/exports/{id}** endpoint).
        example: csv
        in: query
        name: export_format
        required: false
        schema:
          type: string
      - description: |
          \
          When set to true, the `events` object that is returned will additionally contain information about
          all the key-value pairs in each returned log entry.
        example: true
        in: query
        name: kvp_info
        required: false
        schema:
          type: boolean
      - description: |
          \
          When set to `true`, the query returns the most recent events first. When set to `false`, it returns the oldest events first.
        example: true
        in: query
        name: most_recent_first
        required: false
        schema:
          default: false
          type: boolean
      - description: |
          \
          A set of ':' separated label UUIDs. Only entries which have a label matching one of these UUIDs will be returned.
          This only works with non-statistical queries (i.e. no 'groupby' or 'calculate' clauses).
          Takes precedence over the 'label' parameter.
        example: 00000000-0000-0000-0000-000000000001:21b21bb8-8869-4e2c-98df-684892e4e112
        in: query
        name: labels
        required: false
        schema:
          type: string
      - description: |
          \
          If this query parameter is included, the query results will additionally include all log entries received in the
          `from` millisecond which have sequence numbers larger than the one specified.

          Sequence numbers are identifiers used to distinguish between log entries received in the same millisecond.
          If a log entry was split up into several log entries during ingestion, then those chunks are ordered by sequence number.
        in: query
        name: sequence_number
        required: false
        schema:
          type: integer
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/postQueryLogs_request'
        description: |
          The JSON payload must contain:
          * a non-empty array of the log keys for the logs that will be queried
          * a `leql` object, containing a value for either of the following (but **not** for both):
            - `leql.during.time_range`
            - `leql.during.from` and `leql.during.to`

            The `leql.statement` can be empty or omitted.
        required: true
      responses:
        "200":
          content:
            application/json:
              examples:
                EventsResponseSimple:
                  $ref: '#/components/examples/EventsResponseSimple'
                EventsResponsePagination:
                  $ref: '#/components/examples/EventsResponsePagination'
                StatisticalResponseSimple:
                  $ref: '#/components/examples/StatisticalResponseSimple'
                StatisticalResponseTimeSeriesMultiGroupBy:
                  $ref: '#/components/examples/StatisticalResponseTimeSeriesMultiGroupBy'
              schema:
                $ref: '#/components/schemas/getQueryLogs_200_response'
          description: Results in Response Body.
          headers:
            x-beyond-retention:
              $ref: '#/components/headers/x-beyond-retention'
            x-beyond-retention-message:
              $ref: '#/components/headers/x-beyond-retention-message'
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
        "202":
          content:
            application/json:
              examples:
                EventsContinue:
                  $ref: '#/components/examples/EventsContinue'
                EventsContinueExportCSV:
                  $ref: '#/components/examples/EventsContinueExportCSV'
                StatsContinueInitial:
                  $ref: '#/components/examples/StatsContinueInitial'
              schema:
                $ref: '#/components/schemas/getQueryLogs_202_response'
          description: Query in Progress. Links in Response Body.
          headers:
            x-beyond-retention:
              $ref: '#/components/headers/x-beyond-retention'
            x-beyond-retention-message:
              $ref: '#/components/headers/x-beyond-retention-message'
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
        "400":
          description: Malformed JSON Request Body.
        "401":
          description: Unauthorized.
        "404":
          description: Log Not Found.
        "415":
          description: Data not specified as JSON.
        "429":
          content:
            text/plain:
              example: API rate limit exceeded
              schema:
                type: string
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Query Multiple Logs
      tags:
      - Query Log Data
      x-code-samples:
      - lang: Shell
        label: curl
        source: "curl -H 'x-api-key: b865a2555-ab43-4297-a894-a9b5bffb6395' \\\n-H\
          \ 'Content-Type: application/json' \\\n-X POST \\\n--data '{\"logs\": [\"\
          565c1b7b-c08b-4c87-a42a-ab08bad56071\",\"c78579a8-8b20-4e6a-d4c0-5287198a263b\"\
          ],\"leql\":{\"during\":{\"time_range\":\"last 1 hour\"},\"statement\":\"\
          where(931dde6c60>=800)\"}}' \\\nhttps://us.rest.logs.insight.rapid7.com/query/logs?\\\
          \nkvp_info=true&\\\nmost_recent_first=true&\\          \nper_page=1\n"
      - lang: Python
        label: Python3.10
        source: |
          import json
          import time
          from requests import Response, Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY'
          LOG_KEY = 'YOUR LOG KEY'
          FROM_TS_MILLIS = 1684762903000  # Unix epoch
          TO_TS_MILLIS = 1684763203000  # Unix epoch
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          QUERY = ''


          class RateLimitedException(Exception):
              def __init__(self, message: str, secs_until_reset: int):
                  super().__init__(message)
                  self.secs_until_reset = secs_until_reset


          def is_query_in_progress(query_response: Response) -> bool:
              if 'links' not in query_response.json():
                  return False
              elif 'Next' in [link['rel'] for link in query_response.json()['links']]:
                  return False
              elif 'Self' in [link['rel'] for link in query_response.json()['links']]:
                  return True
              raise Exception('LogSearch query returned an invalid response body according to their spec '
                              '- contains a "links" object, which does not contain a link with either '
                              '"rel" equal to "Next" or "Self"')


          def poll_request_to_completion(logsearch_session: Session,
                                         query_in_progress_response: Response) -> Response:
              """
              "continuation" polls expire after 10 seconds, so we must not wait too long between
              requests. However we must not poll too frequently for long-running queries or we
              risk being rate limited.
              """
              if query_in_progress_response.status_code == 429:
                  secs_until_reset = query_in_progress_response.headers.get('X-RateLimit-Reset')
                  raise RateLimitedException(
                      f'Log Search API Key was rate limited. Seconds until rate limit reset: {secs_until_reset}',
                      int(secs_until_reset)
                  )

              if not is_query_in_progress(query_in_progress_response):
                  return query_in_progress_response

              poll_delay_secs = 0.5
              max_poll_delay_secs = 6
              links = {link['rel']: link['href'] for link in query_in_progress_response.json()['links']}
              while 'Self' in links:
                  time.sleep(poll_delay_secs)

                  resp = logsearch_session.get(links['Self'], headers={'x-api-key': API_KEY})

                  if resp.status_code == 429:
                      secs_until_reset = resp.headers.get('X-RateLimit-Reset')
                      raise RateLimitedException(
                       f'Log Search API Key was rate limited. Seconds until rate limit reset: {secs_until_reset}',
                       int(secs_until_reset)
                      )

                  if not is_query_in_progress(resp):
                      return resp

                  poll_delay_secs = min(poll_delay_secs * 2, max_poll_delay_secs)
                  links = {link['rel']: link['href'] for link in resp.json()['links']}


          def has_next_page(query_response: Response) -> bool:
              return 'links' in query_response.json() and \
                     'Next' in [link['rel'] for link in query_response.json()['links']]


          def get_next_page_of_results(logsearch_session: Session, resp: Response) -> Response:
              links = {link['rel']: link['href'] for link in resp.json()['links']}
              return logsearch_session.get(links['Next'], headers={'x-api-key': API_KEY})


          def perform_query(logsearch_session: Session) -> Response:
              try:
                  resp = poll_request_to_completion(
                      logsearch_session,
                      logsearch_session.post(f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/query/logs',
                                             headers={'x-api-key': API_KEY},
                                             json={
                                                 'logs': [LOG_KEY],
                                                 'leql': {
                                                     'during': {'from': FROM_TS_MILLIS, 'to': TO_TS_MILLIS},
                                                     'statement': QUERY
                                                 }
                                             })
                  )
                  print(json.dumps(resp.json(), indent=4))
                  return resp
              except RateLimitedException as e:
                  print(f'Log Search API Key was rate limited. Sleeping for {e.secs_until_reset} seconds')
                  time.sleep(e.secs_until_reset)
                  return perform_query(logsearch_session)


          session = Session()
          session.mount(
              f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
              HTTPAdapter(max_retries=(
                  Retry(total=3,
                        backoff_factor=1,
                        status_forcelist=[500, 502, 503, 504],
                        respect_retry_after_header=False)  # Rate limiting must be handled explicitly
              ))
          )

          query_results_page = perform_query(session)

          while has_next_page(query_results_page):
              try:
                  print('Fetching next page of results')
                  query_results_page = poll_request_to_completion(
                      session,
                      get_next_page_of_results(session, query_results_page)
                  )
                  print(json.dumps(query_results_page.json(), indent=4))
              except RateLimitedException as e:
                  print(f'Log Search API Key was rate limited. Sleeping for {e.secs_until_reset} seconds')
                  time.sleep(e.secs_until_reset)
  /query/logsets:
    get:
      description: |
        Submit the query specified in the query parameters for the log sets matching the given names.

        For instructions on polling a query until it is completed, handling pagination, and handling rate limits, consult
        [this section's introduction](#tag/Query-Log-Data).
      operationId: queryLogsetsByName
      parameters:
      - description: |
          \
          A valid LEQL query to run against the log.
          If omitted, the query retrieves all log entries in the specified time range.
        example: where(foo=bar)
        in: query
        name: query
        required: false
        schema:
          type: string
      - description: |
          \
          The name of the log set to be queried.
          Multiple log sets can be queried by providing this parameter multiple times,
          which results in the query running on the *union* of all contained logs.
          If any of the provided log set names do not exist, a 404 error response is returned.
        example: Internal Logs
        in: query
        name: logset_name
        required: true
        schema:
          type: string
      - description: |
          \
          The start of the time range for the query, as a UNIX timestamp in milliseconds.
        example: 1450557004000
        in: query
        name: from
        required: true
        schema:
          type: integer
      - description: |
          \
          The end of the time range for the query, as a UNIX timestamp in milliseconds.
        example: 1460557604000
        in: query
        name: to
        required: true
        schema:
          type: integer
      - description: |
          \
          An alternative to the `from` and `to` query parameters. Supported values:
          * `yesterday`
          * `today`
          * `last x timeunits` where x is the number of time unit back from the current server time. Supported time units (case insensitive):
              - min(s) or minute(s)
              - hr(s) or hour(s)
              - day(s)
              - week(s)
              - month(s)
              - year(s)

          If `time_range` is used, then the `from` and `to` query parameters must not be used.
        example: last 5 minutes
        in: query
        name: time_range
        required: false
        schema:
          type: string
      - description: |
          \
          Only entries which have a label with this UUID will be returned.
          This only works with non-statistical queries (i.e. no 'groupby' or 'calculate' clauses).
        example: 00000000-0000-0000-0000-000000000001
        in: query
        name: label
        required: false
        schema:
          type: string
      - description: |
          \
          A set of ':' separated label UUIDs. Only entries which have a label matching one of these UUIDs will be returned.
          This only works with non-statistical queries (i.e. no 'groupby' or 'calculate' clauses).
          Takes precedence over the 'label' parameter.
        example: 00000000-0000-0000-0000-000000000001:21b21bb8-8869-4e2c-98df-684892e4e112
        in: query
        name: labels
        required: false
        schema:
          type: string
      - description: |
          \
          Number of log entries to return per page, up to 500(the maximum allowed).
        example: 100
        in: query
        name: per_page
        required: false
        schema:
          default: 50
          type: integer
      - description: |
          \
          When set to true, the `events` object that is returned will additionally contain information about
          all the key-value pairs in each returned log entry.
        example: true
        in: query
        name: kvp_info
        required: false
        schema:
          type: boolean
      - description: |
          \
          When set to `true`, the query returns the most recent events first. When set to `false`, it returns the oldest events first.
        example: true
        in: query
        name: most_recent_first
        required: false
        schema:
          default: false
          type: boolean
      - description: |
          \
          If this query parameter is included, the query results will additionally include all log entries received in the
          `from` millisecond which have sequence numbers larger than the one specified.

          Sequence numbers are identifiers used to distinguish between log entries received in the same millisecond.
          If a log entry was split up into several log entries during ingestion, then those chunks are ordered by sequence number.
        in: query
        name: sequence_number
        required: false
        schema:
          type: integer
      responses:
        "200":
          content:
            application/json:
              examples:
                EventsResponseSimple:
                  $ref: '#/components/examples/EventsResponseSimple'
                EventsResponsePagination:
                  $ref: '#/components/examples/EventsResponsePagination'
                StatisticalResponseSimple:
                  $ref: '#/components/examples/StatisticalResponseSimple'
                StatisticalResponseTimeSeriesMultiGroupBy:
                  $ref: '#/components/examples/StatisticalResponseTimeSeriesMultiGroupBy'
              schema:
                $ref: '#/components/schemas/getQueryLogs_200_response'
          description: Results in Response Body.
          headers:
            x-beyond-retention:
              $ref: '#/components/headers/x-beyond-retention'
            x-beyond-retention-message:
              $ref: '#/components/headers/x-beyond-retention-message'
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
        "202":
          content:
            application/json:
              examples:
                EventsContinue:
                  $ref: '#/components/examples/EventsContinue'
                StatsContinueInitial:
                  $ref: '#/components/examples/StatsContinueInitial'
              schema:
                $ref: '#/components/schemas/getQueryLogs_202_response'
          description: Query in Progress. Links in Response Body.
          headers:
            x-beyond-retention:
              $ref: '#/components/headers/x-beyond-retention'
            x-beyond-retention-message:
              $ref: '#/components/headers/x-beyond-retention-message'
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
        "400":
          description: Invalid Query Request.
        "401":
          description: Unauthorized.
        "404":
          description: Log Not Found.
        "415":
          description: Non-JSON request body was given (Note that the endpoint does
            not take a request body).
        "429":
          content:
            text/plain:
              example: API rate limit exceeded
              schema:
                type: string
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Query Multiple Log Sets
      tags:
      - Query Log Data
      x-code-samples:
      - lang: Shell
        label: curl
        source: |
          curl -H 'x-api-key: b865a2555-ab43-4297-a894-a9b5bffb6395' \
          -G \
          --data-urlencode query="where(931dde6c60>=800)" \
          --data logset_name=HostService \
          --data-urlencode logset_name="Internal Logs" \
          --data from=1609755026007 \
          --data to=1609927826007 \
          --data labels=00000000-0000-0000-0000-000000000002:00000000-0000-0000-0000-000000000001 \
          --data per_page=100 \
          https://us.rest.logs.insight.rapid7.com/query/logsets
      - lang: Python
        label: Python3.10
        source: |
          import json
          import time
          from requests import Response, Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY'
          LOGSET_NAME = "YOUR LOGSET'S NAME"
          FROM_TS_MILLIS = 1684762903000  # Unix epoch
          TO_TS_MILLIS = 1684763203000  # Unix epoch
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          QUERY = ''


          class RateLimitedException(Exception):
              def __init__(self, message: str, secs_until_reset: int):
                  super().__init__(message)
                  self.secs_until_reset = secs_until_reset


          def is_query_in_progress(query_response: Response) -> bool:
              if 'links' not in query_response.json():
                  return False
              elif 'Next' in [link['rel'] for link in query_response.json()['links']]:
                  return False
              elif 'Self' in [link['rel'] for link in query_response.json()['links']]:
                  return True
              raise Exception('LogSearch query returned an invalid response body according to their spec '
                              '- contains a "links" object, which does not contain a link with either '
                              '"rel" equal to "Next" or "Self"')


          def poll_request_to_completion(logsearch_session: Session,
                                         query_in_progress_response: Response) -> Response:
              """
              "continuation" polls expire after 10 seconds, so we must not wait too long between
              requests. However we must not poll too frequently for long-running queries or we
              risk being rate limited.
              """
              if query_in_progress_response.status_code == 429:
                  secs_until_reset = query_in_progress_response.headers.get('X-RateLimit-Reset')
                  raise RateLimitedException(
                      f'Log Search API Key was rate limited. Seconds until rate limit reset: {secs_until_reset}',
                      int(secs_until_reset)
                  )

              if not is_query_in_progress(query_in_progress_response):
                  return query_in_progress_response

              poll_delay_secs = 0.5
              max_poll_delay_secs = 6
              links = {link['rel']: link['href'] for link in query_in_progress_response.json()['links']}
              while 'Self' in links:
                  time.sleep(poll_delay_secs)

                  resp = logsearch_session.get(links['Self'], headers={'x-api-key': API_KEY})

                  if resp.status_code == 429:
                      secs_until_reset = resp.headers.get('X-RateLimit-Reset')
                      raise RateLimitedException(
                       f'Log Search API Key was rate limited. Seconds until rate limit reset: {secs_until_reset}',
                       int(secs_until_reset)
                      )

                  if not is_query_in_progress(resp):
                      return resp

                  poll_delay_secs = min(poll_delay_secs * 2, max_poll_delay_secs)
                  links = {link['rel']: link['href'] for link in resp.json()['links']}


          def has_next_page(query_response: Response) -> bool:
              return 'links' in query_response.json() and \
                     'Next' in [link['rel'] for link in query_response.json()['links']]


          def get_next_page_of_results(logsearch_session: Session, resp: Response) -> Response:
              links = {link['rel']: link['href'] for link in resp.json()['links']}
              return logsearch_session.get(links['Next'], headers={'x-api-key': API_KEY})


          def perform_query(logsearch_session: Session) -> Response:
              try:
                  resp = poll_request_to_completion(
                      logsearch_session,
                      logsearch_session.get(f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/query/logsets',
                                  headers={'x-api-key': API_KEY},
                                  params={'logset_name': LOGSET_NAME,
                                          'from': FROM_TS_MILLIS,
                                          'to': TO_TS_MILLIS,
                                          'query': QUERY})
                  )
                  print(json.dumps(resp.json(), indent=4))
                  return resp
              except RateLimitedException as e:
                  print(f'Log Search API Key was rate limited. Sleeping for {e.secs_until_reset} seconds')
                  time.sleep(e.secs_until_reset)
                  return perform_query(logsearch_session)


          session = Session()
          session.mount(
              f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
              HTTPAdapter(max_retries=(
                  Retry(total=3,
                        backoff_factor=1,
                        status_forcelist=[500, 502, 503, 504],
                        respect_retry_after_header=False)  # Rate limiting must be handled explicitly
              ))
          )

          query_results_page = perform_query(session)

          while has_next_page(query_results_page):
              try:
                  print('Fetching next page of results')
                  query_results_page = poll_request_to_completion(
                      session,
                      get_next_page_of_results(session, query_results_page)
                  )
                  print(json.dumps(query_results_page.json(), indent=4))
              except RateLimitedException as e:
                  print(f'Log Search API Key was rate limited. Sleeping for {e.secs_until_reset} seconds')
                  time.sleep(e.secs_until_reset)
  /query/logsets/{id}:
    get:
      description: |
        Submit the query specified in the query parameters for the log set with that **{logset_id}**.
        Only one log set id may be provided.

        For instructions on polling a query until it is completed, handling pagination, and handling rate limits, consult
        [this section's introduction](#tag/Query-Log-Data).
      operationId: queryLogsetsById
      parameters:
      - description: |
          \
          The id of the log set to be queried.
        example: 4a8869fa-0843-4edd-85f5-bf7d6b80d6c5
        in: path
        name: logset_id
        required: true
        schema:
          type: string
      - description: |
          \
          A valid LEQL query to run against the log.
          If omitted, the query retrieves all log entries in the specified time range.
        example: where(foo=bar)
        in: query
        name: query
        required: false
        schema:
          type: string
      - description: |
          \
          The start of the time range for the query, as a UNIX timestamp in milliseconds.
        example: 1450557004000
        in: query
        name: from
        required: true
        schema:
          type: integer
      - description: |
          \
          The end of the time range for the query, as a UNIX timestamp in milliseconds.
        example: 1460557604000
        in: query
        name: to
        required: true
        schema:
          type: integer
      - description: |
          \
          An alternative to the `from` and `to` query parameters. Supported values:
          * `yesterday`
          * `today`
          * `last x timeunits` where x is the number of time unit back from the current server time. Supported time units (case insensitive):
              - min(s) or minute(s)
              - hr(s) or hour(s)
              - day(s)
              - week(s)
              - month(s)
              - year(s)

          If `time_range` is used, then the `from` and `to` query parameters must not be used.
        example: last 5 minutes
        in: query
        name: time_range
        required: false
        schema:
          type: string
      - description: |
          \
          Only entries which have a label with this UUID will be returned.
          This only works with non-statistical queries (i.e. no 'groupby' or 'calculate' clauses).
        example: 00000000-0000-0000-0000-000000000001
        in: query
        name: label
        required: false
        schema:
          type: string
      - description: |
          \
          A set of ':' separated label UUIDs. Only entries which have a label matching one of these UUIDs will be returned.
          This only works with non-statistical queries (i.e. no 'groupby' or 'calculate' clauses).
          Takes precedence over the 'label' parameter.
        example: 00000000-0000-0000-0000-000000000001:21b21bb8-8869-4e2c-98df-684892e4e112
        in: query
        name: labels
        required: false
        schema:
          type: string
      - description: |
          \
          Number of log entries to return per page, up to 500(the maximum allowed).
        example: 100
        in: query
        name: per_page
        required: false
        schema:
          default: 50
          type: integer
      - description: |
          \
          When set to true, the `events` object that is returned will additionally contain information about
          all the key-value pairs in each returned log entry.
        example: true
        in: query
        name: kvp_info
        required: false
        schema:
          type: boolean
      - description: |
          \
          When set to `true`, the query returns the most recent events first. When set to `false`, it returns the oldest events first.
        example: true
        in: query
        name: most_recent_first
        required: false
        schema:
          default: false
          type: boolean
      - description: |
          \
          If this query parameter is included, the query results will additionally include all log entries received in the
          `from` millisecond which have sequence numbers larger than the one specified.

          Sequence numbers are identifiers used to distinguish between log entries received in the same millisecond.
          If a log entry was split up into several log entries during ingestion, then those chunks are ordered by sequence number.
        in: query
        name: sequence_number
        required: false
        schema:
          type: integer
      responses:
        "200":
          content:
            application/json:
              examples:
                EventsResponseSimple:
                  $ref: "#/components/examples/~1query~1logsets~1{id}"
                EventsResponsePagination:
                  $ref: "#/components/examples/~1query~1logsets~1{id}"
                StatisticalResponseSimple:
                  $ref: "#/components/examples/~1query~1logsets~1{id}"
                StatisticalResponseTimeSeriesMultiGroupBy:
                  $ref: "#/components/examples/~1query~1logsets~1{id}"
              schema:
                $ref: '#/components/schemas/getQueryLogs_200_response'
          description: Results in Response Body.
          headers:
            x-beyond-retention:
              $ref: "#/components/headers/~1query~1logsets~1{id}"
            x-beyond-retention-message:
              $ref: "#/components/headers/~1query~1logsets~1{id}"
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1logsets~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1logsets~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1logsets~1{id}"
        "202":
          content:
            application/json:
              examples:
                EventsContinue:
                  $ref: "#/components/examples/~1query~1logsets~1{id}"
                StatsContinueInitial:
                  $ref: "#/components/examples/~1query~1logsets~1{id}"
              schema:
                $ref: '#/components/schemas/getQueryLogs_202_response'
          description: Query in Progress. Links in Response Body.
          headers:
            x-beyond-retention:
              $ref: "#/components/headers/~1query~1logsets~1{id}"
            x-beyond-retention-message:
              $ref: "#/components/headers/~1query~1logsets~1{id}"
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1logsets~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1logsets~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1logsets~1{id}"
        "400":
          description: Invalid Query Request.
        "401":
          description: Unauthorized.
        "404":
          description: Log Not Found.
        "415":
          description: Non-JSON request body was given (Note that the endpoint does
            not take a request body).
        "429":
          content:
            text/plain:
              example: API rate limit exceeded
              schema:
                type: string
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1logsets~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1logsets~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1logsets~1{id}"
            Retry-After:
              $ref: "#/components/headers/~1query~1logsets~1{id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Query Individual Log Sets
      tags:
      - Query Log Data
      x-code-samples:
      - lang: Shell
        label: curl
        source: |
          curl -H 'x-api-key: b865a2555-ab43-4297-a894-a9b5bffb6395' \
          -G \
          --data-urlencode query="where(931dde6c60>=800)" \
          --data from=1609755026007 \
          --data to=1609927826007 \
          --data labels=00000000-0000-0000-0000-000000000002:00000000-0000-0000-0000-000000000001 \
          --data per_page=1 \
          https://ap.rest.logs.insight.rapid7.com/query/logsets/c1711420-2eb1-69d1-1e15-c17aa921c119
      - lang: Python
        label: Python3.10
        source: |
          import json
          import time
          from requests import Response, Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY'
          LOGSET_ID = 'YOUR LOGSET ID'
          FROM_TS_MILLIS = 1684762903000  # Unix epoch
          TO_TS_MILLIS = 1684763203000  # Unix epoch
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          QUERY = ''


          class RateLimitedException(Exception):
              def __init__(self, message: str, secs_until_reset: int):
                  super().__init__(message)
                  self.secs_until_reset = secs_until_reset


          def is_query_in_progress(query_response: Response) -> bool:
              if 'links' not in query_response.json():
                  return False
              elif 'Next' in [link['rel'] for link in query_response.json()['links']]:
                  return False
              elif 'Self' in [link['rel'] for link in query_response.json()['links']]:
                  return True
              raise Exception('LogSearch query returned an invalid response body according to their spec '
                              '- contains a "links" object, which does not contain a link with either '
                              '"rel" equal to "Next" or "Self"')


          def poll_request_to_completion(logsearch_session: Session,
                                         query_in_progress_response: Response) -> Response:
              """
              "continuation" polls expire after 10 seconds, so we must not wait too long between
              requests. However we must not poll too frequently for long-running queries or we
              risk being rate limited.
              """
              if query_in_progress_response.status_code == 429:
                  secs_until_reset = query_in_progress_response.headers.get('X-RateLimit-Reset')
                  raise RateLimitedException(
                      f'Log Search API Key was rate limited. Seconds until rate limit reset: {secs_until_reset}',
                      int(secs_until_reset)
                  )

              if not is_query_in_progress(query_in_progress_response):
                  return query_in_progress_response

              poll_delay_secs = 0.5
              max_poll_delay_secs = 6
              links = {link['rel']: link['href'] for link in query_in_progress_response.json()['links']}
              while 'Self' in links:
                  time.sleep(poll_delay_secs)

                  resp = logsearch_session.get(links['Self'], headers={'x-api-key': API_KEY})

                  if resp.status_code == 429:
                      secs_until_reset = resp.headers.get('X-RateLimit-Reset')
                      raise RateLimitedException(
                       f'Log Search API Key was rate limited. Seconds until rate limit reset: {secs_until_reset}',
                       int(secs_until_reset)
                      )

                  if not is_query_in_progress(resp):
                      return resp

                  poll_delay_secs = min(poll_delay_secs * 2, max_poll_delay_secs)
                  links = {link['rel']: link['href'] for link in resp.json()['links']}


          def has_next_page(query_response: Response) -> bool:
              return 'links' in query_response.json() and \
                     'Next' in [link['rel'] for link in query_response.json()['links']]


          def get_next_page_of_results(logsearch_session: Session, resp: Response) -> Response:
              links = {link['rel']: link['href'] for link in resp.json()['links']}
              return logsearch_session.get(links['Next'], headers={'x-api-key': API_KEY})


          def perform_query(logsearch_session: Session) -> Response:
              try:
                  resp = poll_request_to_completion(
                      logsearch_session,
                      logsearch_session.get(f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/query/logsets/{LOGSET_ID}',
                                            headers={'x-api-key': API_KEY},
                                            params={'from': FROM_TS_MILLIS, 'to': TO_TS_MILLIS, 'query': QUERY})
                  )
                  print(json.dumps(resp.json(), indent=4))
                  return resp
              except RateLimitedException as e:
                  print(f'Log Search API Key was rate limited. Sleeping for {e.secs_until_reset} seconds')
                  time.sleep(e.secs_until_reset)
                  return perform_query(logsearch_session)

          session = Session()
          session.mount(
              f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
              HTTPAdapter(max_retries=(
                  Retry(total=3,
                        backoff_factor=1,
                        status_forcelist=[500, 502, 503, 504],
                        respect_retry_after_header=False)  # Rate limiting must be handled explicitly
              ))
          )

          query_results_page = perform_query(session)

          while has_next_page(query_results_page):
              try:
                  print('Fetching next page of results')
                  query_results_page = poll_request_to_completion(
                      session,
                      get_next_page_of_results(session, query_results_page)
                  )
                  print(json.dumps(query_results_page.json(), indent=4))
              except RateLimitedException as e:
                  print(f'Log Search API Key was rate limited. Sleeping for {e.secs_until_reset} seconds')
                  time.sleep(e.secs_until_reset)
  /query/saved_query/{saved_query_id}:
    get:
      description: |
        Run a saved query.

        This endpoint can only be used for saved queries which *have* the logs for the query already specified.
        For saved queries which *don't have* the logs already specified, use the
        [/query/logs/{log_keys}/{saved_query_id}](#operation/useSavedQueryNoLogs) endpoint.

        The saved queries used here may or may not have the time range specified.
        If unspecified, the time range must be indicated in the URL query parameters.
        If the time range *is specified* by the saved query, the time range cannnot be overridden in the query parameters.

        ### Query Types
        There are two types of queries, which return different response body structures:
        * **Event Search** queries do not contain a `calculate` function and return a list of log lines in the
        response. When the number of log lines matching your query is large, the response will be paginated and you will
        need to send further requests to retrieve the other pages of log lines (more details on this below).
        * **Statistical Search** queries contain a `calculate` function and return a number rather
        than a list of log lines. These queries do not require you to handle any pagination. Additionally, the response body
        will have a different structure depending on whether the query contains a `groupby` clause or not.

        ### Polling, Pagination & Rate Limiting
        For instructions on polling a query until it is completed, handling pagination, and handling rate limits, consult
        [the introduction to the "Query Log Data" section](#tag/Query-Log-Data).
      operationId: useSavedQuery
      parameters:
      - description: |
          \
          The id of the saved query.
        example: 00000000-0000-00cf-0000-000000000000
        in: path
        name: saved_query_id
        required: true
        schema:
          type: string
      - description: |
          \
          The start of the time range for the query, as a UNIX timestamp in milliseconds.
        example: 1450557004000
        in: query
        name: from
        required: true
        schema:
          type: integer
      - description: |
          \
          The end of the time range for the query, as a UNIX timestamp in milliseconds.
        example: 1460557604000
        in: query
        name: to
        required: true
        schema:
          type: integer
      - description: |
          \
          An alternative to the `from` and `to` query parameters. Supported values:
          * `yesterday`
          * `today`
          * `last x timeunits` where x is the number of time unit back from the current server time. Supported time units (case insensitive):
              - min(s) or minute(s)
              - hr(s) or hour(s)
              - day(s)
              - week(s)
              - month(s)
              - year(s)

          If `time_range` is used, then the `from` and `to` query parameters must not be used.
        example: last 5 minutes
        in: query
        name: time_range
        required: false
        schema:
          type: string
      - description: |
          \
          Number of log entries to return per page, up to 500(the maximum allowed).
        example: 100
        in: query
        name: per_page
        required: false
        schema:
          default: 50
          type: integer
      - description: |
          \
          When set to true, the `events` object that is returned will additionally contain information about
          all the key-value pairs in each returned log entry.
        example: true
        in: query
        name: kvp_info
        required: false
        schema:
          type: boolean
      - description: |
          \
          When set to `true`, the query returns the most recent events first. When set to `false`, it returns the oldest events first.
        example: true
        in: query
        name: most_recent_first
        required: false
        schema:
          default: false
          type: boolean
      responses:
        "200":
          content:
            application/json:
              examples:
                EventsResponseSimple:
                  $ref: "#/components/examples/~1query~1saved_query~1{saved_query_id}"
                EventsResponsePagination:
                  $ref: "#/components/examples/~1query~1saved_query~1{saved_query_id}"
                StatisticalResponseSimple:
                  $ref: "#/components/examples/~1query~1saved_query~1{saved_query_id}"
                StatisticalResponseTimeSeriesMultiGroupBy:
                  $ref: "#/components/examples/~1query~1saved_query~1{saved_query_id}"
              schema:
                $ref: '#/components/schemas/getQueryLogs_200_response'
          description: Results in Response Body.
          headers:
            x-beyond-retention:
              $ref: "#/components/headers/~1query~1saved_query~1{saved_query_id}"
            x-beyond-retention-message:
              $ref: "#/components/headers/~1query~1saved_query~1{saved_query_id}"
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1saved_query~1{saved_query_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1saved_query~1{saved_query_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1saved_query~1{saved_query_id}"
        "202":
          content:
            application/json:
              examples:
                EventsContinue:
                  $ref: "#/components/examples/~1query~1saved_query~1{saved_query_id}"
                StatsContinueInitial:
                  $ref: "#/components/examples/~1query~1saved_query~1{saved_query_id}"
              schema:
                $ref: '#/components/schemas/getQueryLogs_202_response'
          description: Query in Progress. Links in Response Body.
          headers:
            x-beyond-retention:
              $ref: "#/components/headers/~1query~1saved_query~1{saved_query_id}"
            x-beyond-retention-message:
              $ref: "#/components/headers/~1query~1saved_query~1{saved_query_id}"
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1saved_query~1{saved_query_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1saved_query~1{saved_query_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1saved_query~1{saved_query_id}"
        "400":
          description: Saved Query Parameters Invalid.
        "401":
          description: Unauthorized.
        "404":
          description: Saved Query Not Found.
        "415":
          description: Non-JSON request body was given (Note that the endpoint does
            not take a request body).
        "429":
          content:
            text/plain:
              example: API rate limit exceeded
              schema:
                type: string
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1saved_query~1{saved_query_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1saved_query~1{saved_query_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1saved_query~1{saved_query_id}"
            Retry-After:
              $ref: "#/components/headers/~1query~1saved_query~1{saved_query_id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Use a Saved Query (logs specified)
      tags:
      - Saved Queries
      x-code-samples:
      - lang: Shell
        label: curl
        source: |
          curl -H 'x-api-key: b865a2555-ab43-4297-a894-a9b5bffb6395' \
          -G \
          --data-urlencode time_range="last 1 day" \
          --data per_page=1 \
          --data kvp_info=true \
          https://us.rest.logs.insight.rapid7.com/query/saved_query/00000000-0000-01cf-0000-000000000000
      - lang: Python
        label: Python3.10
        source: |
          import json
          import time
          from requests import Response, Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY GOES HERE'
          SAVED_QUERY_ID = 'YOUR SAVED QUERY ID GOES HERE'
          FROM_TS_MILLIS = 1684762903000  # If unspecified in the saved query
          TO_TS_MILLIS = 1684763203000  # If unspecified in the saved query
          DATA_STORAGE_REGION = 'eu'  # Swap for your region


          class RateLimitedException(Exception):
              def __init__(self, message: str, secs_until_reset: int):
                  super().__init__(message)
                  self.secs_until_reset = secs_until_reset


          def is_query_in_progress(query_response: Response) -> bool:
              if 'links' not in query_response.json():
                  return False
              elif 'Next' in [link['rel'] for link in query_response.json()['links']]:
                  return False
              elif 'Self' in [link['rel'] for link in query_response.json()['links']]:
                  return True
              raise Exception('LogSearch query returned an invalid response body according to their spec '
                              '- contains a "links" object, which does not contain a link with either '
                              '"rel" equal to "Next" or "Self"')


          def poll_request_to_completion(logsearch_session: Session,
                                         query_in_progress_response: Response) -> Response:
              """
              "continuation" polls expire after 10 seconds, so we must not wait too long between
              requests. However we must not poll too frequently for long-running queries or we
              risk being rate limited.
              """
              if query_in_progress_response.status_code == 429:
                  secs_until_reset = query_in_progress_response.headers.get('X-RateLimit-Reset')
                  raise RateLimitedException(
                      f'Log Search API Key was rate limited. Seconds until rate limit reset: {secs_until_reset}',
                      int(secs_until_reset)
                  )

              if not is_query_in_progress(query_in_progress_response):
                  return query_in_progress_response

              poll_delay_secs = 0.5
              max_poll_delay_secs = 6
              links = {link['rel']: link['href'] for link in query_in_progress_response.json()['links']}
              while 'Self' in links:
                  time.sleep(poll_delay_secs)

                  resp = logsearch_session.get(links['Self'], headers={'x-api-key': API_KEY})

                  if resp.status_code == 429:
                      secs_until_reset = resp.headers.get('X-RateLimit-Reset')
                      raise RateLimitedException(
                       f'Log Search API Key was rate limited. Seconds until rate limit reset: {secs_until_reset}',
                       int(secs_until_reset)
                      )

                  if not is_query_in_progress(resp):
                      return resp

                  poll_delay_secs = min(poll_delay_secs * 2, max_poll_delay_secs)
                  links = {link['rel']: link['href'] for link in resp.json()['links']}


          def has_next_page(query_response: Response) -> bool:
              return 'links' in query_response.json() and \
                     'Next' in [link['rel'] for link in query_response.json()['links']]


          def get_next_page_of_results(logsearch_session: Session, resp: Response) -> Response:
              links = {link['rel']: link['href'] for link in resp.json()['links']}
              return logsearch_session.get(links['Next'], headers={'x-api-key': API_KEY})


          def perform_query(logsearch_session: Session) -> Response:
              try:
                  resp = poll_request_to_completion(
                      logsearch_session,
                      logsearch_session.get(f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/'
                                            f'query/saved_query/{SAVED_QUERY_ID}',
                                            headers={'x-api-key': API_KEY},
                                            params={'from': FROM_TS_MILLIS, 'to': TO_TS_MILLIS})
                  )
                  print(json.dumps(resp.json(), indent=4))
                  return resp
              except RateLimitedException as e:
                  print(f'Log Search API Key was rate limited. Sleeping for {e.secs_until_reset} seconds')
                  time.sleep(e.secs_until_reset)
                  return perform_query(logsearch_session)


          session = Session()
          session.mount(
              f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
              HTTPAdapter(max_retries=(
                  Retry(total=3,
                        backoff_factor=1,
                        status_forcelist=[500, 502, 503, 504],
                        respect_retry_after_header=False)  # Rate limiting must be handled explicitly
              ))
          )

          query_results_page = perform_query(session)

          while has_next_page(query_results_page):
              try:
                  print('Fetching next page of results')
                  query_results_page = poll_request_to_completion(
                      session,
                      get_next_page_of_results(session, query_results_page)
                  )
                  print(json.dumps(query_results_page.json(), indent=4))
              except RateLimitedException as e:
                  print(f'Log Search API Key was rate limited. Sleeping for {e.secs_until_reset} seconds')
                  time.sleep(e.secs_until_reset)
  /query/logs/{log_keys}/{saved_query_id}:
    get:
      description: |
        Run a saved query on the logs matching the specified **{log_keys}**.

        This endpoint can only be used for saved queries which *don't have* the logs for the query already specified.
        For saved queries which *have* the logs already specified, use the
        [/query/saved_query/{saved_query_id}](#operation/useSavedQuery) endpoint.

        The saved queries used here may or may not have the time range specified.
        If unspecified, the time range must be indicated in the URL query parameters.
        If the time range *is specified* by the saved query, the time range cannnot be overridden in the query parameters.

        ### Query Types
        There are two types of queries, which return different response body structures:
        * **Event Search** queries do not contain a `calculate` function and return a list of log lines in the
        response. When the number of log lines matching your query is large, the response will be paginated and you will
        need to send further requests to retrieve the other pages of log lines (more details on this below).
        * **Statistical Search** queries contain a `calculate` function and return a number rather
        than a list of log lines. These queries do not require you to handle any pagination. Additionally, the response body
        will have a different structure depending on whether the query contains a `groupby` clause or not.

        ### Polling, Pagination & Rate Limiting
        For instructions on polling a query until it is completed, handling pagination, and handling rate limits, consult
        [the introduction to the "Query Log Data" section](#tag/Query-Log-Data).
      operationId: useSavedQueryNoLogs
      parameters:
      - description: |
          \
          The keys of the logs to be queried, separated by the ':' character.
        example: /query/logs/565c1b7b-c08b-4c87-a42a-ab08bad56071
        in: path
        name: log_keys
        required: true
        schema:
          type: string
      - description: |
          \
          The id of the saved query.
        example: 00000000-0000-00cf-0000-000000000000
        in: path
        name: saved_query_id
        required: true
        schema:
          type: string
      - description: |
          \
          The start of the time range for the query, as a UNIX timestamp in milliseconds.
        example: 1450557004000
        in: query
        name: from
        required: true
        schema:
          type: integer
      - description: |
          \
          The end of the time range for the query, as a UNIX timestamp in milliseconds.
        example: 1460557604000
        in: query
        name: to
        required: true
        schema:
          type: integer
      - description: |
          \
          An alternative to the `from` and `to` query parameters. Supported values:
          * `yesterday`
          * `today`
          * `last x timeunits` where x is the number of time unit back from the current server time. Supported time units (case insensitive):
              - min(s) or minute(s)
              - hr(s) or hour(s)
              - day(s)
              - week(s)
              - month(s)
              - year(s)

          If `time_range` is used, then the `from` and `to` query parameters must not be used.
        example: last 5 minutes
        in: query
        name: time_range
        required: false
        schema:
          type: string
      - description: |
          \
          Number of log entries to return per page, up to 500(the maximum allowed).
        example: 100
        in: query
        name: per_page
        required: false
        schema:
          default: 50
          type: integer
      - description: |
          \
          When set to true, the `events` object that is returned will additionally contain information about
          all the key-value pairs in each returned log entry.
        example: true
        in: query
        name: kvp_info
        required: false
        schema:
          type: boolean
      - description: |
          \
          When set to `true`, the query returns the most recent events first. When set to `false`, it returns the oldest events first.
        example: true
        in: query
        name: most_recent_first
        required: false
        schema:
          default: false
          type: boolean
      responses:
        "200":
          content:
            application/json:
              examples:
                EventsResponseSimple:
                  $ref: "#/components/examples/~1query~1logs~1{log_keys}~1{saved_query_id}"
                EventsResponsePagination:
                  $ref: "#/components/examples/~1query~1logs~1{log_keys}~1{saved_query_id}"
                StatisticalResponseSimple:
                  $ref: "#/components/examples/~1query~1logs~1{log_keys}~1{saved_query_id}"
                StatisticalResponseTimeSeriesMultiGroupBy:
                  $ref: "#/components/examples/~1query~1logs~1{log_keys}~1{saved_query_id}"
              schema:
                $ref: '#/components/schemas/getQueryLogs_200_response'
          description: Results in Response Body.
          headers:
            x-beyond-retention:
              $ref: "#/components/headers/~1query~1logs~1{log_keys}~1{saved_query_id}"
            x-beyond-retention-message:
              $ref: "#/components/headers/~1query~1logs~1{log_keys}~1{saved_query_id}"
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1logs~1{log_keys}~1{saved_query_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1logs~1{log_keys}~1{saved_query_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1logs~1{log_keys}~1{saved_query_id}"
        "202":
          content:
            application/json:
              examples:
                EventsContinue:
                  $ref: "#/components/examples/~1query~1logs~1{log_keys}~1{saved_query_id}"
                StatsContinueInitial:
                  $ref: "#/components/examples/~1query~1logs~1{log_keys}~1{saved_query_id}"
              schema:
                $ref: '#/components/schemas/getQueryLogs_202_response'
          description: Query in Progress. Links in Response Body.
          headers:
            x-beyond-retention:
              $ref: "#/components/headers/~1query~1logs~1{log_keys}~1{saved_query_id}"
            x-beyond-retention-message:
              $ref: "#/components/headers/~1query~1logs~1{log_keys}~1{saved_query_id}"
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1logs~1{log_keys}~1{saved_query_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1logs~1{log_keys}~1{saved_query_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1logs~1{log_keys}~1{saved_query_id}"
        "400":
          description: Saved Query Parameters Invalid.
        "401":
          description: Unauthorized.
        "404":
          description: Log or Saved Query Not Found.
        "415":
          description: Non-JSON request body was given (Note that the endpoint does
            not take a request body).
        "429":
          content:
            text/plain:
              example: API rate limit exceeded
              schema:
                type: string
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1logs~1{log_keys}~1{saved_query_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1logs~1{log_keys}~1{saved_query_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1logs~1{log_keys}~1{saved_query_id}"
            Retry-After:
              $ref: "#/components/headers/~1query~1logs~1{log_keys}~1{saved_query_id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Use a Saved Query (logs unspecified)
      tags:
      - Saved Queries
      x-code-samples:
      - lang: Shell
        label: curl
        source: |
          curl -H 'x-api-key: b865a2555-ab43-4297-a894-a9b5bffb6395' \
          -G \
          --data-urlencode time_range="last 1 day" \
          --data per_page=1 \
          --data kvp_info=true \
          https://eu.rest.logs.insight.rapid7.com/query/logs/626c8841-feb2-4a45-32a8-5224e4cc6ecf/00000000-0000-011e-0000-000000000000
      - lang: Python
        label: Python3.10
        source: |
          import json
          import time
          from requests import Response, Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY GOES HERE'
          LOG_KEY = 'YOUR LOG KEY GOES HERE'
          SAVED_QUERY_ID = 'YOUR SAVED QUEYR ID GOES HERE'
          FROM_TS_MILLIS = 1684762903000  # If unspecified in the saved query
          TO_TS_MILLIS = 1684763203000  # If unspecified in the saved query
          DATA_STORAGE_REGION = 'eu'  # Swap for your region


          class RateLimitedException(Exception):
              def __init__(self, message: str, secs_until_reset: int):
                  super().__init__(message)
                  self.secs_until_reset = secs_until_reset


          def is_query_in_progress(query_response: Response) -> bool:
              if 'links' not in query_response.json():
                  return False
              elif 'Next' in [link['rel'] for link in query_response.json()['links']]:
                  return False
              elif 'Self' in [link['rel'] for link in query_response.json()['links']]:
                  return True
              raise Exception('LogSearch query returned an invalid response body according to their spec '
                              '- contains a "links" object, which does not contain a link with either '
                              '"rel" equal to "Next" or "Self"')


          def poll_request_to_completion(logsearch_session: Session,
                                         query_in_progress_response: Response) -> Response:
              """
              "continuation" polls expire after 10 seconds, so we must not wait too long between
              requests. However we must not poll too frequently for long-running queries or we
              risk being rate limited.
              """
              if query_in_progress_response.status_code == 429:
                  secs_until_reset = query_in_progress_response.headers.get('X-RateLimit-Reset')
                  raise RateLimitedException(
                      f'Log Search API Key was rate limited. Seconds until rate limit reset: {secs_until_reset}',
                      int(secs_until_reset)
                  )

              if not is_query_in_progress(query_in_progress_response):
                  return query_in_progress_response

              poll_delay_secs = 0.5
              max_poll_delay_secs = 6
              links = {link['rel']: link['href'] for link in query_in_progress_response.json()['links']}
              while 'Self' in links:
                  time.sleep(poll_delay_secs)

                  resp = logsearch_session.get(links['Self'], headers={'x-api-key': API_KEY})

                  if resp.status_code == 429:
                      secs_until_reset = resp.headers.get('X-RateLimit-Reset')
                      raise RateLimitedException(
                       f'Log Search API Key was rate limited. Seconds until rate limit reset: {secs_until_reset}',
                       int(secs_until_reset)
                      )

                  if not is_query_in_progress(resp):
                      return resp

                  poll_delay_secs = min(poll_delay_secs * 2, max_poll_delay_secs)
                  links = {link['rel']: link['href'] for link in resp.json()['links']}


          def has_next_page(query_response: Response) -> bool:
              return 'links' in query_response.json() and \
                     'Next' in [link['rel'] for link in query_response.json()['links']]


          def get_next_page_of_results(logsearch_session: Session, resp: Response) -> Response:
              links = {link['rel']: link['href'] for link in resp.json()['links']}
              return logsearch_session.get(links['Next'], headers={'x-api-key': API_KEY})


          def perform_query(logsearch_session: Session) -> Response:
              try:
                  resp = poll_request_to_completion(
                      logsearch_session,
                      logsearch_session.get(f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/'
                                  f'query/logs/{LOG_KEY}/{SAVED_QUERY_ID}',
                                  headers={'x-api-key': API_KEY},
                                  params={'from': FROM_TS_MILLIS, 'to': TO_TS_MILLIS})
                  )
                  print(json.dumps(resp.json(), indent=4))
                  return resp
              except RateLimitedException as e:
                  print(f'Log Search API Key was rate limited. Sleeping for {e.secs_until_reset} seconds')
                  time.sleep(e.secs_until_reset)
                  return perform_query(logsearch_session)


          session = Session()
          session.mount(
              f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
              HTTPAdapter(max_retries=(
                  Retry(total=3,
                        backoff_factor=1,
                        status_forcelist=[500, 502, 503, 504],
                        respect_retry_after_header=False)  # Rate limiting must be handled explicitly
              ))
          )

          query_results_page = perform_query(session)

          while has_next_page(query_results_page):
              try:
                  print('Fetching next page of results')
                  query_results_page = poll_request_to_completion(
                      session,
                      get_next_page_of_results(session, query_results_page)
                  )
                  print(json.dumps(query_results_page.json(), indent=4))
              except RateLimitedException as e:
                  print(f'Log Search API Key was rate limited. Sleeping for {e.secs_until_reset} seconds')
                  time.sleep(e.secs_until_reset)
  /query/{id}:
    get:
      description: "Checks the status of the query with the **{continuation_id}**\
        \ generated when the query started.  \nIf the query is complete, the result\
        \ is returned.  \nOtherwise: the progress (in percent) is reported, and a\
        \ partial calculation or some partial search results may be returned.  \n\n\
        It is important to note that if there are more than `per_page` events which\
        \ match the query, then the response will only contain `per_page` events.\
        \  \nThe remaining events can be returned by following the `Next` link in\
        \ the response body.  \n\nTherefore to get all results for a specific time-range\
        \ you will need to create a query, poll it to completion, create a new query\
        \ using the `Next` link for next page, poll etc.\nThere are two types of links\
        \ in poll requests:\n- `Self`: current query/page of results isn't done, continue\
        \ polling\n- `Next`: Current query/page is done, but if you wish to get the\
        \ next/remaining events, create a new query for more events with this link\n\
        There is a code example below for polling logic.\n\nThe `time_range` metadata\
        \ information for the query can only be tracked by the client,\nby providing\
        \ it as a query parameter with every polling request, which will be returned\
        \ as given in the response\n(does not affect the query execution - only metadata\
        \ information).\n\nLinks must be polled at least once **every 20 seconds**\
        \ to avoid expiration. Be cautious of polling too frequently as that can lead\
        \ to rate limiting. \n"
      operationId: pollQuery
      parameters:
      - description: |
          \
          The continuation id generated when the query started.
        example: '0bnc17f4-bbbe-46b1-a843-163c074bd1ad:0:c5be1c97f925ff772263661182974903b83ef305:50:f89f7d5cbeb270abeb18b1c28262cee66047d21d:'
        in: path
        name: id
        required: true
        schema:
          type: string
      - description: |
          \
          An alternative to the `from` and `to` query parameters. Supported values:
          * `yesterday`
          * `today`
          * `last x timeunits` where x is the number of time unit back from the current server time. Supported time units (case insensitive):
              - min(s) or minute(s)
              - hr(s) or hour(s)
              - day(s)
              - week(s)
              - month(s)
              - year(s)

          If `time_range` is used, then the `from` and `to` query parameters must not be used.
        example: last 5 minutes
        in: query
        name: time_range
        required: false
        schema:
          type: string
      responses:
        "200":
          content:
            application/json:
              examples:
                EventsContinue:
                  $ref: "#/components/examples/~1query~1{id}"
                EventsResponseSimple:
                  $ref: "#/components/examples/~1query~1{id}"
                EventsResponsePagination:
                  $ref: "#/components/examples/~1query~1{id}"
                StatsContinueInitial:
                  $ref: "#/components/examples/~1query~1{id}"
                StatisticalResponseSimple:
                  $ref: "#/components/examples/~1query~1{id}"
                StatisticalResponseTimeSeriesMultiGroupBy:
                  $ref: "#/components/examples/~1query~1{id}"
              schema:
                $ref: '#/components/schemas/pollQuery_200_response'
          description: Successful poll. Query is either done or on-going and response
            body may contain partial or full query results.
          headers:
            x-beyond-retention:
              $ref: "#/components/headers/~1query~1{id}"
            x-beyond-retention-message:
              $ref: "#/components/headers/~1query~1{id}"
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1{id}"
        "400":
          description: Invalid Continuation ID.
        "401":
          description: Unauthorized.
        "404":
          description: Query Not Found (Continuation ID may have expired).
        "415":
          description: Non-JSON request body was given (Note that the endpoint does
            not take a request body).
        "429":
          content:
            text/plain:
              example: API rate limit exceeded
              schema:
                type: string
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1{id}"
            Retry-After:
              $ref: "#/components/headers/~1query~1{id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Poll a Query In Progress
      tags:
      - Query Log Data
      x-code-samples:
      - lang: Shell
        label: curl
        source: |
          curl -H 'x-api-key: b865a2555-ab43-4297-a894-a9b5bffb6395' \
          https://ca.rest.logs.insight.rapid7.com/query/c19c7d71-de32-4a6d-92b9-58e12dc38eb9:0:c5be1c97f925ee883347440071863897b83ef305:1:94b844d409485aa4152284708bf65f4b09d931f3:\
          ?time_range=last+1+day
      - lang: Python
        label: Python3
        source: |
          # This script should *NOT* be used in production.
          # It does not handle throttling, retries or statistical searches.
          # It merely runs an event search assuming a happy path to illustrate polling behaviour.
          import time
          import argparse
          import requests
          import typing


          def make_request(*,
                          region: str,
                          query: str,
                          api_key: str,
                          logs: typing.List[str],
                          _from: int,
                          to: int):
              HEADERS = {'x-api-key': api_key}

              ALL_EVENTS = []

              SESSION = requests.Session()
              SESSION.headers.update(HEADERS)

              r = SESSION.post(f'https://{region}.rest.logs.insight.rapid7.com/query/logs/',
                                json={
                                      "leql": {
                                          "during": {
                                              'from': _from,
                                              'to': to,
                                          },
                                          "statement": query,
                                      },
                                      "logs": logs
                                })
              r.raise_for_status()
              response_body = r.json()

              while 'links' in response_body:
                  #   `Self` links = continue polling until you get the result.
                  #   `Next` links = link to create a new query to get further results (e.g. paginated responses),
                  #   if you have 200 loglines and you make a query to list them, you'll by default get 50 and will
                  #   need to hit the `Next` link to get the next 50

                  #Could be `Self` or `Next` link.
                  # we don't care, we want all results for the selected `time_range`.
                  r = SESSION.get(response_body['links'][0]['href'])
                  r.raise_for_status()
                  response_body = r.json()

                  if r.status_code == 200:
                      ALL_EVENTS.extend(response_body.get('events', []))

              print(ALL_EVENTS)


          def main():
              parser = argparse.ArgumentParser(description='Make a request to LogSearch API.')

              parser.add_argument('--region', '-r', required=True, help='API region.')
              parser.add_argument('--query', '-q', default='', help='Query to run. Default is no query.')
              parser.add_argument('--x-api-key', '-x', required=True)
              parser.add_argument('--log', '-l', nargs='+', required=True, help='The logs to search.')
              parser.add_argument('-f', type=int, help='From parameter.')
              parser.add_argument('--to', '-t', type=int, help='To parameter.')

              args = parser.parse_args()

              make_request(region=args.region, query=args.query, api_key=args.x_api_key, logs=args.log, _from=args.f, to=args.to)


          if __name__ == '__main__':
              main()
  /query/saved_queries:
    get:
      description: |
        For more context on saved queries, as well as instructions on handling rate limits consult [this section's introduction](#tag/Saved-Queries).
      operationId: listSavedQueries
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/ListSavedQueries/value
              schema:
                $ref: '#/components/schemas/listSavedQueries_200_response'
          description: Saved Queries in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
        "401":
          description: Unauthorized.
        "415":
          description: Non-JSON request body was given (Note that the endpoint does
            not take a request body).
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: List All Saved Queries
      tags:
      - Saved Queries
      x-code-samples:
      - lang: Shell
        label: curl
        source: |
          curl -H 'x-api-key: b865a2555-ab43-4297-a894-a9b5bffb6395' \
          https://us.rest.logs.insight.rapid7.com/query/saved_queries/
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region


          def list_saved_queries(s: Session) -> None:
              response = s.get(f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/query/saved_queries',
                               headers={'x-api-key': API_KEY})
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              list_saved_queries(session)
    post:
      description: |
        For more context on saved queries, as well as instructions on handling rate limits consult [this section's introduction](#tag/Saved-Queries).
      operationId: postSavedQueryRoot
      requestBody:
        content:
          application/json:
            example:
              $ref: ../../insightops-examples.yml#/components/examples/SavedQueryNoID/value
            schema:
              $ref: '#/components/schemas/create_saved_query'
        required: true
      responses:
        "201":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/SavedQuery/value
              schema:
                $ref: '#/components/schemas/saved_query'
          description: Saved Query Created. ID in Response.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
        "400":
          description: Saved Query Specified in Payload Invalid.
        "401":
          description: Unauthorized.
        "415":
          description: Non-JSON request body was given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Create A Saved Query
      tags:
      - Saved Queries
      x-code-samples:
      - lang: Shell
        label: curl
        source: |
          curl -H 'x-api-key: b865a2555-ab43-4297-a894-a9b5bffb6395' \
          -H 'Content-Type: application/json' \
          -X POST \
          --data '{"saved_query":{"name":"Large Values Yesterday","leql":{"statement":"where(931dde6c60>=800)","during":{"time_range":"yesterday"}},"logs":["565c1b7b-c08b-4c87-a42a-ab08bad56071","c78579a8-8b20-4e6a-d4c0-5287198a263b"]}}' \
          https://us.rest.logs.insight.rapid7.com/query/saved_queries
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          SAVED_QUERY = {
              'saved_query': {
                  'name': 'saved query example - no logs',
                  "leql": {
                      'statement': 'where("") calculate(count)'
                  }
              }
          }


          def create_saved_query(s: Session) -> None:
              response = s.post(f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/query/saved_queries',
                                headers={'x-api-key': API_KEY},
                                json=SAVED_QUERY)
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              create_saved_query(session)
  /query/saved_queries/{saved_query_id}:
    delete:
      description: |
        For more context on saved queries, as well as instructions on handling rate limits consult [this section's introduction](#tag/Saved-Queries).
      operationId: deleteSavedQueryId
      parameters:
      - description: |
          \
          The id of the saved query.
        example: 00000000-0000-00cf-0000-000000000000
        in: path
        name: saved_query_id
        required: true
        schema:
          type: string
      responses:
        "204":
          description: Resource Deleted Successfully.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1saved_queries~1{saved_query_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1saved_queries~1{saved_query_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1saved_queries~1{saved_query_id}"
        "401":
          description: Unauthorized.
        "404":
          description: Saved Query Not Found.
        "415":
          description: Non-JSON request body was given (Note that the endpoint does
            not take a request body).
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1saved_queries~1{saved_query_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1saved_queries~1{saved_query_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1saved_queries~1{saved_query_id}"
            Retry-After:
              $ref: "#/components/headers/~1query~1saved_queries~1{saved_query_id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Delete A Saved Query
      tags:
      - Saved Queries
      x-code-samples:
      - lang: Shell
        label: curl
        source: |
          curl -H 'x-api-key: b865a2555-ab43-4297-a894-a9b5bffb6395' \
          -X DELETE \
          https://us.rest.logs.insight.rapid7.com/query/saved_queries/00000000-0000-10d0-0000-000000000000
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          SAVED_QUERY_ID = 'YOUR SAVED QUERY ID GOES HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region


          def delete_saved_query(s: Session) -> None:
              response = s.delete(f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/query/'
                                  f'saved_queries/{SAVED_QUERY_ID}',
                                  headers={'x-api-key': API_KEY})
              if response.status_code == 204:
                  print(f'Deleted {SAVED_QUERY_ID}')
              else:
                  print(f'Failed to delete saved query. status_code={response.status_code}')
                  print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              delete_saved_query(session)
    get:
      description: |
        For more context on saved queries, as well as instructions on handling rate limits consult [this section's introduction](#tag/Saved-Queries).
      operationId: getSavedQueryId
      parameters:
      - description: |
          \
          The id of the saved query.
        example: 00000000-0000-00cf-0000-000000000000
        in: path
        name: saved_query_id
        required: true
        schema:
          type: string
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/SavedQuery/value
              schema:
                $ref: '#/components/schemas/saved_query'
          description: Saved Query in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1saved_queries~1{saved_query_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1saved_queries~1{saved_query_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1saved_queries~1{saved_query_id}"
        "401":
          description: Unauthorized.
        "404":
          description: Saved Query Not Found.
        "415":
          description: Non-JSON request body was given (Note that the endpoint does
            not take a request body).
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1saved_queries~1{saved_query_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1saved_queries~1{saved_query_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1saved_queries~1{saved_query_id}"
            Retry-After:
              $ref: "#/components/headers/~1query~1saved_queries~1{saved_query_id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Retrieve A Saved Query
      tags:
      - Saved Queries
      x-code-samples:
      - lang: Shell
        label: curl
        source: |
          curl -H 'x-api-key: b865a2555-ab43-4297-a894-a9b5bffb6395' \
          https://ap.rest.logs.insight.rapid7.com/query/saved_queries/00000000-0000-10d0-0000-000000000000
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          SAVED_QUERY_ID = 'YOUR SAVED QUERY ID GOES HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region


          def get_saved_query(s: Session) -> None:
              response = s.get(f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/query/saved_queries/{SAVED_QUERY_ID}',
                               headers={'x-api-key': API_KEY})
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              get_saved_query(session)
    patch:
      description: |
        Replace one or more individual details of a saved query with the details specified in the JSON request body.
        Cannot be used to remove the time range for a saved query (by replacing the time range with null value).

        For more context on saved queries, as well as instructions on handling rate limits consult [this section's introduction](#tag/Saved-Queries).
      operationId: patchSavedQueryId
      parameters:
      - description: |
          \
          The id of the saved query.
        example: 00000000-0000-00cf-0000-000000000000
        in: path
        name: saved_query_id
        required: true
        schema:
          type: string
      requestBody:
        content:
          application/json:
            example:
              saved_query:
                leql:
                  statement: "where(key1 <= 2 AND key2 > 8) groupby(key1, key2) timeslice(5)"
            schema:
              $ref: '#/components/schemas/patch_saved_query'
        required: true
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/SavedQuery/value
              schema:
                $ref: '#/components/schemas/saved_query'
          description: Success. Modified Saved Query in Response Body
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1saved_queries~1{saved_query_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1saved_queries~1{saved_query_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1saved_queries~1{saved_query_id}"
        "400":
          description: Query Parameter Value(s) Specified in Payload Invalid.
        "401":
          description: Unauthorized.
        "404":
          description: Saved Query Not Found.
        "415":
          description: Non-JSON request body was given (Note that the endpoint does
            not take a request body).
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1saved_queries~1{saved_query_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1saved_queries~1{saved_query_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1saved_queries~1{saved_query_id}"
            Retry-After:
              $ref: "#/components/headers/~1query~1saved_queries~1{saved_query_id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Modify A Saved Query
      tags:
      - Saved Queries
      x-code-samples:
      - lang: Shell
        label: curl
        source: |
          curl -H 'x-api-key: b865a2555-ab43-4297-a894-a9b5bffb6395' \
          -H 'Content-Type: application/json' \
          -X PATCH \
          --data '{"saved_query":{"leql":{"statement":"where(931dde6c60>=800)"}}}' \
          https://ap.rest.logs.insight.rapid7.com/query/saved_queries/00000000-0000-10d0-0000-000000000000
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          SAVED_QUERY_ID = 'YOUR SAVED QUERY ID GOES HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          SAVED_QUERY = {
              'saved_query': {
                  "leql": {
                      'statement': 'where("")'
                  }
              }
          }


          def modify_saved_query(s: Session) -> None:
              response = s.patch(f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/query/'
                                 f'saved_queries/{SAVED_QUERY_ID}',
                                 headers={'x-api-key': API_KEY},
                                 json=SAVED_QUERY)
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              modify_saved_query(session)
    put:
      description: |
        Replace a saved query with the details specified in the JSON request body. If the saved query you are replacing
        contains a time range and the request body does not contain a time range, then the existing time range is retained.

        For more context on saved queries, as well as instructions on handling rate limits consult [this section's introduction](#tag/Saved-Queries).
      operationId: putSavedQueryId
      parameters:
      - description: |
          \
          The id of the saved query.
        example: 00000000-0000-00cf-0000-000000000000
        in: path
        name: saved_query_id
        required: true
        schema:
          type: string
      requestBody:
        content:
          application/json:
            example:
              $ref: ../../insightops-examples.yml#/components/examples/SavedQueryNoID/value
            schema:
              $ref: '#/components/schemas/create_saved_query'
        required: true
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/SavedQuery/value
              schema:
                $ref: '#/components/schemas/saved_query'
          description: Success. New Saved Query in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1saved_queries~1{saved_query_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1saved_queries~1{saved_query_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1saved_queries~1{saved_query_id}"
        "400":
          description: Saved Query Specified in Payload Invalid.
        "401":
          description: Unauthorized.
        "404":
          description: Saved Query Not Found.
        "415":
          description: Non-JSON request body was given (Note that the endpoint does
            not take a request body).
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1saved_queries~1{saved_query_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1saved_queries~1{saved_query_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1saved_queries~1{saved_query_id}"
            Retry-After:
              $ref: "#/components/headers/~1query~1saved_queries~1{saved_query_id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Replace A Saved Query
      tags:
      - Saved Queries
      x-code-samples:
      - lang: Shell
        label: curl
        source: |
          curl -H 'x-api-key:  b865a2555-ab43-4297-a894-a9b5bffb6395' \
          -H 'Content-Type: application/json' \
          -X PUT \
          --data '{"saved_query":{"name":"Large Values Yesterday","leql":{"statement":"where(931dde6c60>=800)","during":{"time_range":"yesterday"}},"logs":["565c1b7b-c08b-4c87-a42a-ab08bad56071","c78579a8-8b20-4e6a-d4c0-5287198a263b"]}}' \
          https://us.rest.logs.insight.rapid7.com/query/saved_queries/00000000-0000-10d0-0000-000000000000
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          SAVED_QUERY_ID = 'YOUR SAVED QUERY ID GOES HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          SAVED_QUERY = {
              'saved_query': {
                  'name': 'replaced saved query example',
                  "leql": {
                      'statement': 'where("") calculate(count)'
                  }
              }
          }


          def replace_saved_query(s: Session) -> None:
              response = s.put(f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/query/saved_queries/{SAVED_QUERY_ID}',
                               headers={'x-api-key': API_KEY},
                               json=SAVED_QUERY)
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              replace_saved_query(session)
  /query/variables:
    get:
      description: |
        For more context on LEQL variables, as well as instructions on handling rate limits consult [this section's introduction](#tag/Leql-Variables).
      operationId: listVariables
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/listVariables_200_response'
          description: List of Variables in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
        "401":
          description: Unauthorized.
        "403":
          description: Forbidden.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: List all LEQL variables
      tags:
      - LEQL Variables
    post:
      description: |
        For more context on LEQL variables, as well as instructions on handling rate limits consult [this section's introduction](#tag/Leql-Variables).
      operationId: createVariable
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/createVariable_request'
      responses:
        "201":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/createVariable_201_response'
          description: Created Variable in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
        "400":
          description: Invalid Request.
        "401":
          description: Unauthorized.
        "403":
          description: Forbidden.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Create a LEQL variable
      tags:
      - LEQL Variables
  /query/variables/{id}:
    delete:
      description: |
        For more context on LEQL variables, as well as instructions on handling rate limits consult [this section's introduction](#tag/Leql-Variables).
      operationId: deleteVariable
      responses:
        "204":
          description: Variable Deleted.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1variables~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1variables~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1variables~1{id}"
        "401":
          description: Unauthorized.
        "403":
          description: Forbidden.
        "404":
          description: Not Found.
        "409":
          description: Variable Cannot Be Deleted As It Is In Use.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1variables~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1variables~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1variables~1{id}"
            Retry-After:
              $ref: "#/components/headers/~1query~1variables~1{id}"
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Delete a LEQL variable
      tags:
      - LEQL Variables
    get:
      description: |
        For more context on LEQL variables, as well as instructions on handling rate limits consult [this section's introduction](#tag/Leql-Variables).
      operationId: retrieveVariable
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/createVariable_201_response'
          description: LEQL Variable in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1variables~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1variables~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1variables~1{id}"
        "401":
          description: Unauthorized.
        "403":
          description: Forbidden.
        "404":
          description: Not Found.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1variables~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1variables~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1variables~1{id}"
            Retry-After:
              $ref: "#/components/headers/~1query~1variables~1{id}"
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Retrieve a LEQL variable
      tags:
      - LEQL Variables
    put:
      description: "Updates a variable that belongs to the authenticated account.\
        \ Only the value of the variable can be updated. \nThe variable name cannot\
        \ be updated.\n\nFor more context on LEQL variables, as well as instructions\
        \ on handling rate limits consult [this section's introduction](#tag/Leql-Variables).\n"
      operationId: updateVariable
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/createVariable_request'
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/createVariable_201_response'
          description: Updated Variable in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1variables~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1variables~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1variables~1{id}"
        "400":
          description: Invalid Request
        "401":
          description: Unauthorized.
        "403":
          description: Forbidden.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1variables~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1variables~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1variables~1{id}"
            Retry-After:
              $ref: "#/components/headers/~1query~1variables~1{id}"
        "409":
          description: Variable Cannot Be Updated As It Will Break A Detection Rule
            Or Pre-Computed Query.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Update a LEQL variable
      tags:
      - LEQL Variables
  /query/live/logs/{log_keys}:
    get:
      description: |
        Starts a Live Tail feed on the logs with those **{log_keys}**, for the Query specified in the URL parameters.
      operationId: getLiveLogs
      parameters:
      - description: |
          \
          The keys of the logs for the Live Tail Feed.

          Supplying multiple ':' separated log keys is deprecated;
          users should instead 'POST' the query as a JSON payload to [/query/live/logs](#operation/postLiveLogs).
        example: /query/live/logs/565c1b7b-c08b-4c87-a42a-ab08bad56071
        in: path
        name: log_keys
        required: true
        schema:
          type: string
      - description: |
          \
          A valid LEQL query for the Live Tail feed.
          If omitted, the query matches all log entries.

          *Live Tail does not support 'calculate' or 'groupby' queries.*
        example: where(foo=bar)
        in: query
        name: query
        required: false
        schema:
          type: string
      - description: |
          \
          The order the log entries are returned in. Possible values:
          * `tail` (which returns entries in the order: newest to oldest.)
          * `head` (which returns entries in the order: oldest to newest.)
        example: head
        in: query
        name: mode
        required: false
        schema:
          default: tail
          type: string
      - description: |
          \
          Only entries which have a label with this UUID will be returned.
          This only works with non-statistical queries (i.e. no 'groupby' or 'calculate' clauses).
        example: 00000000-0000-0000-0000-000000000001
        in: query
        name: label
        required: false
        schema:
          type: string
      - description: |
          \
          A set of ':' separated label UUIDs. Only entries which have a label matching one of these UUIDs will be returned.
          This only works with non-statistical queries (i.e. no 'groupby' or 'calculate' clauses).
          Takes precedence over the 'label' parameter.
        example: 00000000-0000-0000-0000-000000000001:21b21bb8-8869-4e2c-98df-684892e4e112
        in: query
        name: labels
        required: false
        schema:
          type: string
      - description: |
          \
          The maximum number of log entries to return at a time, up to 500(the maximum allowed).
          If the number of results exceed this value, the next "page" of results is returned the next time
          that the Live Tail feed is polled.
        example: 100
        in: query
        name: per_page
        required: false
        schema:
          default: 50
          type: integer
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/LiveTailResponse/value
              schema:
                $ref: '#/components/schemas/LiveTailResponse'
          description: Live Tail feed started. Response body contains link to poll
            the feed.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1live~1logs~1{log_keys}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1live~1logs~1{log_keys}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1live~1logs~1{log_keys}"
        "400":
          description: Invalid URL Query Parameters.
        "401":
          description: Unauthorized
        "404":
          description: Log Not Found.
        "415":
          description: Non-JSON request body was given (Note that the endpoint does
            not take a request body).
        "429":
          description: Rate Limited.
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Start A Live Tail Feed (Individual Logs)
      tags:
      - Watch Incoming Log Data In Realtime
      x-code-samples:
      - lang: Shell
        label: curl
        source: |
          curl -H 'x-api-key: b865a2555-ab43-4297-a894-a9b5bffb6395' \
          -G \
          --data-urlencode query="where(/f9697e0/)" \
          --data mode="head" \
          --data label="00000000-0000-0000-0000-000000000001" \
          https://ap.rest.logs.insight.rapid7.com/query/live/logs/f558ea24-c213-8b99-9a33-8a498121677a
      - lang: Python
        label: Python3
        source: |
          import requests
          import json

          API_KEY = 'YOUR API KEY GOES HERE'
          LOG_KEY = 'YOUR LOG KEY GOES HERE'

          def continue_request(req):
              if 'links' in req.json():
                  continue_url = req.json()['links'][0]['href']
                  new_response = make_request(continue_url)
                  handle_response(new_response)


          def handle_response(resp):
              response = resp

              if response.status_code == 200:
                  print(json.dumps(resp.json(), indent=4))
                  continue_request(resp)
                  return

              if response.status_code > 202:
                  print('Error status code ' + str(response.status_code))
                  return


          def make_request(provided_url=None):
              headers = {'x-api-key': API_KEY}

              url = f"https://us.rest.logs.insight.rapid7.com/query/live/logs/{LOG_KEY}?query=where(foobar)"
              if provided_url:
                  url = provided_url
              req = requests.get(url, headers=headers)
              return req


          def print_query():
              req = make_request()
              handle_response(req)

          def start():
              print_query()


          if __name__ == '__main__':
              start()
  /query/live/logs:
    post:
      description: |
        Starts a Live Tail feed, where the logs and the query for the feed are specified in the (JSON) request body.

        An arbitrary collection of logs can be specified in the request body.
      operationId: postLiveLogs
      parameters:
      - description: |
          \
          A set of ':' separated label UUIDs. Only entries which have a label matching one of these UUIDs will be returned.
          This only works with non-statistical queries (i.e. no 'groupby' or 'calculate' clauses).
          Takes precedence over the 'label' parameter.
        example: 00000000-0000-0000-0000-000000000001:21b21bb8-8869-4e2c-98df-684892e4e112
        in: query
        name: labels
        required: false
        schema:
          type: string
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/postLiveLogs_request'
        required: true
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/LiveTailResponse/value
              schema:
                $ref: '#/components/schemas/LiveTailResponse'
          description: Live Tail feed started. Response body contains link to poll
            the feed.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
        "400":
          description: Malformed JSON Request Body.
        "401":
          description: Unauthorized.
        "404":
          description: Log(s) Not Found.
        "415":
          description: Data not specified as JSON.
        "429":
          description: Rate Limited.
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Start A Live Tail Feed (Multiple Logs)
      tags:
      - Watch Incoming Log Data In Realtime
      x-code-samples:
      - lang: Shell
        label: curl
        source: |
          curl -H 'x-api-key: b865a2555-ab43-4297-a894-a9b5bffb6395' \
          -H 'Content-Type: application/json' \
          -X POST \
          --data '{"logs": ["565c1b7b-c08b-4c87-a42a-ab08bad56071","c78579a8-8b20-4e6a-d4c0-5287198a263b"],"leql":{"statement":"where(/f9697e0/)"}}' \
          https://ap.rest.logs.insight.rapid7.com/query/live/logs
  /query/live/saved_query/{saved_query_id}:
    get:
      description: |
        Starts a Live Tail Feed using the saved query which has id **{saved_query_id}**.

        This endpoint can only be used for saved queries which *have* the logs for the live tail feed already specified.
        For saved queries which *don't have* the logs already specified, use the
        [/query/live/logs/{log_keys}/{saved_query_id}](#operation/liveSavedQueryNoLogs) endpoint.

        Saved queries which have a *time range* already specified can still be used (the time range is ignored).
      operationId: liveSavedQuery
      parameters:
      - description: |
          \
          The id of the saved query.
        example: 00000000-0000-00cf-0000-000000000000
        in: path
        name: saved_query_id
        required: true
        schema:
          type: string
      - description: |
          \
          The maximum number of log entries to return at a time, up to 500(the maximum allowed).
          If the number of results exceed this value, the next "page" of results is returned the next time
          that the Live Tail feed is polled.
        example: 100
        in: query
        name: per_page
        required: false
        schema:
          default: 50
          type: integer
      - description: |
          \
          The order the log entries are returned in. Possible values:
          * `tail` (which returns entries in the order: newest to oldest.)
          * `head` (which returns entries in the order: oldest to newest.)
        example: head
        in: query
        name: mode
        required: false
        schema:
          default: tail
          type: string
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/LiveTailResponse/value
              schema:
                $ref: '#/components/schemas/LiveTailResponse'
          description: Live Tail feed started. Response body contains link to poll
            the feed.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1live~1saved_query~1{saved_query_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1live~1saved_query~1{saved_query_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1live~1saved_query~1{saved_query_id}"
        "400":
          description: URL Query Parameters Invalid.
        "401":
          description: Unauthorized.
        "404":
          description: Saved Query Not Found.
        "415":
          description: Non-JSON request body was given (Note that the endpoint does
            not take a request body).
        "429":
          description: Rate Limited.
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Start a Live Tail Feed (Saved Query - with logs)
      tags:
      - Watch Incoming Log Data In Realtime
    x-code-samples:
    - lang: Shell
      label: curl
      source: |
        curl -H 'x-api-key: b865a2555-ab43-4297-a894-a9b5bffb6395' \
        -G \
        --data per_page=100 \
        --data mode=head \
        https://us.rest.logs.insight.rapid7.com/query/live/saved_query/00000000-0000-01cf-0000-000000000000
  /query/live/logs/{log_keys}/{saved_query_id}:
    get:
      description: |
        Starts a Live Tail Feed using the saved query which has the id **{saved_query_id}**
        on the logs matching the **{log_keys}**.

        This endpoint can only be used for saved queries which *don't have* the logs for the query already specified.
        For saved queries which *have* the logs already specified, use the
        [/query/live/saved_query/{saved_query_id}](#operation/liveSavedQuery) endpoint.

        Saved queries which have a *time range* already specified can still be used (the time range is ignored).
      operationId: liveSavedQueryNoLogs
      parameters:
      - description: |
          \
          The keys of the logs for the Live Tail Feed, separated by the ':' character.
        example: /query/live/logs/565c1b7b-c08b-4c87-a42a-ab08bad56071
        in: path
        name: log_keys
        required: true
        schema:
          type: string
      - description: |
          \
          The id of the saved query.
        example: 00000000-0000-00cf-0000-000000000000
        in: path
        name: saved_query_id
        required: true
        schema:
          type: string
      - description: |
          \
          The maximum number of log entries to return at a time, up to 500(the maximum allowed).
          If the number of results exceed this value, the next "page" of results is returned the next time
          that the Live Tail feed is polled.
        example: 100
        in: query
        name: per_page
        required: false
        schema:
          default: 50
          type: integer
      - description: |
          \
          The order the log entries are returned in. Possible values:
          * `tail` (which returns entries in the order: newest to oldest.)
          * `head` (which returns entries in the order: oldest to newest.)
        example: head
        in: query
        name: mode
        required: false
        schema:
          default: tail
          type: string
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/LiveTailResponse/value
              schema:
                $ref: '#/components/schemas/LiveTailResponse'
          description: Live Tail feed started. Response body contains link to poll
            the feed.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1live~1logs~1{log_keys}~1{saved_query_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1live~1logs~1{log_keys}~1{saved_query_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1live~1logs~1{log_keys}~1{saved_query_id}"
        "400":
          description: URL Query Parameters Invalid.
        "401":
          description: Unauthorized.
        "404":
          description: Log(s) or Saved Query Not Found.
        "415":
          description: Non-JSON request body was given (Note that the endpoint does
            not take a request body).
        "429":
          description: Rate Limited.
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Start a Live Tail Feed (Saved Query - without logs)
      tags:
      - Watch Incoming Log Data In Realtime
      x-code-samples:
      - lang: Shell
        label: curl
        source: |
          curl -H 'x-api-key: b865a2555-ab43-4297-a894-a9b5bffb6395' \
          -G \
          --data per_page=100 \
          --data mode=head \
          https://eu.rest.logs.insight.rapid7.com/query/live/logs/626c8841-feb2-4a45-32a8-5224e4cc6ecf:f558ea24-c213-8b99-9a33-8a498121677a/00000000-0000-01cf-0000-000000000000
  /query/live/{id}:
    get:
      description: |
        Polls the Live Tail Feed with the corresponding **{id}**, returning all the log entries for the Feed since the
        since last time the Feed was polled. If the number of log entries exceeds 50 (by default),
        only 50 log entries will be returned, and the next "page" is returned on the next poll.

        The `log_keys` and `query` metadata information for the Live Tail Feed can only be tracked by the client,
        by providing it as a query parameter with every polling request, which will be returned as given in the response
        (does not affect the query execution - only metadata information).
      operationId: pollLiveTail
      parameters:
      - description: |
          \
          The polling id generated when the Live Tail Feed started.
        example: 'c9d059da-7b1b-48a9-aaeb-edf2aa3e3fd9:2:::0447214e1b4e5b2041bf62bd7421cb9b7069065f:'
        in: path
        name: id
        required: true
        schema:
          type: string
      - description: |
          \
          A valid LEQL query for the Live Tail feed.
          If omitted, the query matches all log entries.

          *Live Tail does not support 'calculate' or 'groupby' queries.*
        example: where(foo=bar)
        in: query
        name: query
        required: false
        schema:
          type: string
      - description: |
          \
          The keys of the logs for the Live Tail Feed, separated by the ':' character.
        example: 565c1b7b-c08b-4c87-a42a-ab08bad56071
        in: query
        name: log_keys
        required: false
        schema:
          type: string
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/LiveTailPollId/value
              schema:
                $ref: '#/components/schemas/LiveTailPollResponse'
          description: Feed Polled Succesfully. Response body contains results.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1live~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1live~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1live~1{id}"
        "400":
          description: Invalid Polling Id.
        "401":
          description: Unauthorized.
        "404":
          description: Feed Not Found (Polling id may have expired).
        "415":
          description: Non-JSON request body was given (Note that the endpoint does
            not take a request body).
        "429":
          description: Rate Limited.
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Poll a Live Tail Feed
      tags:
      - Watch Incoming Log Data In Realtime
      x-code-samples:
      - lang: Shell
        label: curl
        source: |-
          curl -H 'x-api-key: b865a2555-ab43-4297-a894-a9b5bffb6395' \
          "https://ca.rest.logs.insight.rapid7.com/query/live/f8550e83-83f2-4345-8f0e-cb10bc2bf023:2:::e5af7af8b2266b984e382305672331297b8a13c7:\
          ?log_keys=565c1b7b-c08b-4c87-a42a-ab08bad56071%3Ac78579a8-8b20-4e6a-d4c0-5287198a263b\
          &query=where%28%2F.%2A%2F%29"
  /query/context/{id}:
    get:
      description: "Submit a query to retrieve the log entries immediately before,\
        \ after, or both, a specific \nlog entry, which is identified by the log key,\
        \ the timestamp of the log entry, and its sequence number \n(a number used\
        \ to distinguish between log entries received within the same millisecond).\n\
        \nThe log entries included in the query result are those before, after, or\
        \ both, the specified the log entry, \nuntil there is a gap of 60 seconds\
        \ between log entries. For example:\n1. an entry \"entry1\" is ingested,\n\
        2. 61 seconds later, entries \"entry2\", \"entry3\", and \"entry4\" are ingested,\n\
        3. 61 seconds later, an entry \"entry5\" is ingested,\n\nthen the events that\
        \ are \"immediately before or after\" (or both) \"entry3\" will consist of\
        \ {\"entry2\", \"entry3\", \"entry4\"}.\n\nFor instructions on polling a query\
        \ until it is completed, handling pagination, and handling rate limits, consult\n\
        [this section's introduction](#tag/Query-Log-Data). However, note that this\
        \ endpoint is unique in that it also supports\n backwards pagination through\
        \ the **Prev** link in the `links` array of the response, which behaves in\
        \ the same way\n as regular pagination which uses the **Next** link.\n"
      operationId: getContextEvents
      parameters:
      - description: |
          \
          The sequence number of the log entry to fetch contextual log entries for
          (a unique identifier used to distinguish between log entries received in the same millisecond).

          The sequence number can be found next to the log entry in the response body for an Event Search query. For
          more context on creating an Event Search query [view the introduction to this section](#tag/Query-Log-Data).
        example: 2134329353399137024
        in: path
        name: id (sequence number)
        required: true
        schema:
          type: integer
      - description: |
          \
          The timestamp of the log entry to fetch contextual events for.
        example: 1609607464185
        in: query
        name: timestamp
        required: true
        schema:
          type: string
      - description: |
          \
          The key of the log containing the log entry to fetch the contextual events for.
        example: 565c1b7b-c08b-4c87-a42a-ab08bad56071
        in: query
        name: log_keys
        required: true
        schema:
          type: string
      - description: |
          Possible values:
          * `AFTER`  -  returns the log entries immediately *after* the given log entry (doesn't include the given log entry).
          * `BEFORE` -  returns the log entries immediately *before* the given log entry (doesn't include the given log entry).
          * `SURROUND` -  returns the log entries immediately *before and after* the given log entry(*does* include the given log entry).
        example: SURROUND
        in: query
        name: context_type
        required: true
        schema:
          type: string
      - description: |
          \
          Number of log entries to return per page, up to 500(the maximum allowed).
        example: 100
        in: query
        name: per_page
        required: false
        schema:
          default: 50
          type: integer
      - description: |
          \
          When set to true, the `events` object that is returned will additionally contain information about
          all the key-value pairs in each returned log entry.
        example: true
        in: query
        name: kvp_info
        required: false
        schema:
          type: boolean
      - description: |
          \
          When set to `true`, the query returns the most recent events first. When set to `false`, it returns the oldest events first.
        example: true
        in: query
        name: most_recent_first
        required: false
        schema:
          default: false
          type: boolean
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/ContextAPIResult/value
              schema:
                $ref: '#/components/schemas/ContextResponse'
          description: Results in Response Body.
          headers:
            x-beyond-retention:
              $ref: "#/components/headers/~1query~1context~1{id}"
            x-beyond-retention-message:
              $ref: "#/components/headers/~1query~1context~1{id}"
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1context~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1context~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1context~1{id}"
        "202":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/ContextContinue/value
              schema:
                $ref: '#/components/schemas/ContextContinueResponse'
          description: Query in progress. Link to poll the query in response body.
          headers:
            x-beyond-retention:
              $ref: "#/components/headers/~1query~1context~1{id}"
            x-beyond-retention-message:
              $ref: "#/components/headers/~1query~1context~1{id}"
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1context~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1context~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1context~1{id}"
        "400":
          description: Invalid Context Request.
        "401":
          description: Unauthorized.
        "404":
          description: "Log not found, or invalid sequence number."
        "415":
          description: Non-JSON request body was given (Note that the endpoint does
            not take a request body).
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1context~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1context~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1context~1{id}"
            Retry-After:
              $ref: "#/components/headers/~1query~1context~1{id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Retrieve The Log Data Immediately Before And After A Specific Log Line
      tags:
      - Query Log Data
      x-code-samples:
      - lang: Shell
        label: curl
        source: |
          curl -H 'x-api-key: b865a2555-ab43-4297-a894-a9b5bffb6395' \
          -G \
          --data context_type="SURROUND" \
          --data timestamp=1609607464185 \
          --data log_keys=f558ea24-c213-8b99-9a33-8a498121677a \
          https://us.rest.logs.insight.rapid7.com/query/context/3234729357719937024
      - lang: Python
        label: Python3.10
        source: |
          import json
          import time
          from requests import Response, Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          LOG_KEY = 'YOUR LOG KEY HERE'
          LOG_LINE_TIMESTAMP_MS = 1684763050964
          LOG_LINE_SEQUENCE_NUMBER = 3237124846739517440
          DATA_STORAGE_REGION = 'eu'  # Swap for your region


          class RateLimitedException(Exception):
              def __init__(self, message: str, secs_until_reset: int):
                  super().__init__(message)
                  self.secs_until_reset = secs_until_reset


          def is_query_in_progress(query_response: Response) -> bool:
              if 'links' not in query_response.json():
                  return False
              elif 'Next' in [link['rel'] for link in query_response.json()['links']]:
                  return False
              elif 'Self' in [link['rel'] for link in query_response.json()['links']]:
                  return True
              raise Exception('LogSearch query returned an invalid response body according to their spec '
                              '- contains a "links" object, which does not contain a link with either '
                              '"rel" equal to "Next" or "Self"')


          def poll_request_to_completion(logsearch_session: Session,
                                         query_in_progress_response: Response) -> Response:
              """
              "continuation" polls expire after 10 seconds, so we must not wait too long between
              requests. However we must not poll too frequently for long-running queries or we
              risk being rate limited.
              """
              if query_in_progress_response.status_code == 429:
                  secs_until_reset = query_in_progress_response.headers.get('X-RateLimit-Reset')
                  raise RateLimitedException(
                      f'Log Search API Key was rate limited. Seconds until rate limit reset: {secs_until_reset}',
                      int(secs_until_reset)
                  )

              if not is_query_in_progress(query_in_progress_response):
                  return query_in_progress_response

              poll_delay_secs = 0.5
              max_poll_delay_secs = 6
              links = {link['rel']: link['href'] for link in query_in_progress_response.json()['links']}
              while 'Self' in links:
                  time.sleep(poll_delay_secs)

                  resp = logsearch_session.get(links['Self'], headers={'x-api-key': API_KEY})

                  if resp.status_code == 429:
                      secs_until_reset = resp.headers.get('X-RateLimit-Reset')
                      raise RateLimitedException(
                       f'Log Search API Key was rate limited. Seconds until rate limit reset: {secs_until_reset}',
                       int(secs_until_reset)
                      )

                  if not is_query_in_progress(resp):
                      return resp

                  poll_delay_secs = min(poll_delay_secs * 2, max_poll_delay_secs)
                  links = {link['rel']: link['href'] for link in resp.json()['links']}


          def perform_query(logsearch_session: Session) -> Response:
              try:
                  resp = poll_request_to_completion(
                      logsearch_session,
                      logsearch_session.get(f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com'
                                            f'/query/context/{LOG_LINE_SEQUENCE_NUMBER}',
                                            headers={'x-api-key': API_KEY},
                                            params={'timestamp': LOG_LINE_TIMESTAMP_MS,
                                                    'log_keys': LOG_KEY,
                                                    'context_type': 'SURROUND'})
                  )
                  print(json.dumps(resp.json(), indent=4))
                  return resp
              except RateLimitedException as e:
                  print(f'Log Search API Key was rate limited. Sleeping for {e.secs_until_reset} seconds')
                  time.sleep(e.secs_until_reset)
                  return perform_query(logsearch_session)


          session = Session()
          session.mount(
              f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
              HTTPAdapter(max_retries=(
                  Retry(total=3,
                        backoff_factor=1,
                        status_forcelist=[500, 502, 503, 504],
                        respect_retry_after_header=False)  # Rate limiting must be handled explicitly
              ))
          )

          query_results_page = perform_query(session)
          print(json.dumps(query_results_page.json(), indent=4))

          # Note that this script does not handle any additional backwards/forwards pagination, to
          # fetch additional contextual log lines.
  /query/metrics/{id}:
    get:
      description: |
        For more context on pre-computed queries, as well as instructions on handling rate limits consult [this section's introduction](#tag/Pre-Computed-Queries).
      operationId: queryMetrics
      parameters:
      - description: |
          \
          The UUID of the pre-computed query.
        example: 9aff96bd-ef12-4887-93b5-00931se12f1a
        in: path
        name: metric_id
        required: true
        schema:
          type: string
      - description: |
          \
          An alternative to the `from` and `to` query parameters. Supported values:
          * `yesterday`
          * `today`
          * `last x timeunits` where x is the number of time unit back from the current server time. Supported time units (case insensitive):
              - min(s) or minute(s)
              - hr(s) or hour(s)
              - day(s)
              - week(s)
              - month(s)
              - year(s)

          If `time_range` is used, then the `from` and `to` query parameters must not be used.
        example: last 5 minutes
        in: query
        name: time_range
        required: false
        schema:
          type: string
      - description: |
          \
          The start of the time range for the query, as a UNIX timestamp in milliseconds.
        example: 1450557004000
        in: query
        name: from
        required: true
        schema:
          type: integer
      - description: |
          \
          The end of the time range for the query, as a UNIX timestamp in milliseconds.
        example: 1460557604000
        in: query
        name: to
        required: true
        schema:
          type: integer
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/MetricsResponse/value
              schema:
                $ref: '#/components/schemas/MetricsResponse'
          description: Query Results in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1metrics~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1metrics~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1metrics~1{id}"
        "400":
          description: Invalid Query Request.
        "401":
          description: Unauthorized.
        "404":
          description: Metric Not Found.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1query~1metrics~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1query~1metrics~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1query~1metrics~1{id}"
            Retry-After:
              $ref: "#/components/headers/~1query~1metrics~1{id}"
        "500":
          description: Internal Server Error.
        "503":
          description: Service Unavailable.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Fetch Query Results
      tags:
      - Pre-Computed Queries
      x-code-samples:
      - lang: Shell
        label: curl
        source: |
          curl -H 'x-api-key: b865a2555-ab43-4297-a894-a9b5bffb6395' \
          -G \
          --data from=1609502658000 \
          --data to=1610539458000 \
          https://us.rest.logs.insight.rapid7.com/query/metrics/23cf23a8-9b9b-4b6e-b45f-5cbd19544f28
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          PCQ_ID = "YOUR PRE-COMPUTED QUERY ID"
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          TIME_RANGE = "last 1 week"


          def fetch_pcq_results(s: Session) -> None:
              response = s.get(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/"
                               f"query/metrics/{PCQ_ID}",
                               headers={'x-api-key': API_KEY},
                               params={"time_range": TIME_RANGE})
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              fetch_pcq_results(session)
  /management/tags:
    get:
      description: "For more context on basic detection rules, notification, notification\
        \ targets, and labels, \nas well as instructions on handling rate limits,\
        \ consult [this section's introduction](#tag/Basic-Detection-Rules).\n"
      operationId: getManagementTags
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/ListTags/value
              schema:
                $ref: '#/components/schemas/getManagementTags_200_response'
          description: Basic Detection Rules in Response Body
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "401":
          description: Unauthorized.
        "415":
          description: Non-JSON request body was given (Note that the endpoint does
            not take a request body).
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: List All Tags
      tags:
      - Basic Detection Rules
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region


          def list_all_basic_detection_rules(s: Session) -> None:
              response = s.get(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/management/tags",
                               headers={'x-api-key': API_KEY})
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              list_all_basic_detection_rules(session)
    post:
      description: "For more context on basic detection rules, notification, notification\
        \ targets, and labels, \nas well as instructions on handling rate limits,\
        \ consult [this section's introduction](#tag/Basic-Detection-Rules).\n"
      operationId: postManagementTags
      requestBody:
        content:
          application/json:
            example:
              $ref: ../../insightops-examples.yml#/components/examples/CreateOrPutTag/value
            schema:
              $ref: '#/components/schemas/postManagementTags_request'
        required: true
      responses:
        "201":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/TagById/value
              schema:
                $ref: '#/components/schemas/postManagementTags_201_response'
          description: Basic Detection Rule Created. ID in Response
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "400":
          description: Basic Detection Rule Specified In Request Body Invalid.
        "401":
          description: Unauthorized.
        "415":
          description: Non-JSON request body was given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Create A Basic Detection Rule
      tags:
      - Basic Detection Rules
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          LOG_ID = 'YOUR LOG ID HERE'

          BASIC_DETECTION_RULE = {
              "tag": {
                  "actions": [
                      {
                          "enabled": True,
                          "min_matches_count": 0,
                          "min_matches_period": "Hour",
                          "min_report_count": 1,
                          "min_report_period": "Hour",
                          "targets": [
                              {
                                  "alert_content_set":
                                  {
                                      "le_context": "true"
                                  },
                                  "params_set": {
                                      "direct": "test@test.com",
                                  },
                                  "type": "mailto"
                              }
                          ],
                          "type": "Alert"
                      }
                  ],
                  "labels": [],
                  "name": "Foo Bar Tag",
                  "leql": {
                      "statement": "where(/Foo Bar/)"
                  },
                  "sources": [
                      {
                          "id": LOG_ID
                      }
                  ],
                  "type": "Alert"
              }
          }


          def create_basic_detection_rule(s: Session) -> None:
              response = s.post(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/management/tags",
                                headers={'x-api-key': API_KEY},
                                json=BASIC_DETECTION_RULE)
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              create_basic_detection_rule(session)
  /management/tags/{rule_id}:
    delete:
      description: "For more context on basic detection rules, notification, notification\
        \ targets, and labels, \nas well as instructions on handling rate limits,\
        \ consult [this section's introduction](#tag/Basic-Detection-Rules).\n"
      operationId: deleteManagementTagById
      parameters:
      - description: |
          \
          The id of the change detection rule.
        example: 00000000-0000-00cf-0000-000000000000
        in: path
        name: tag_id
        required: true
        schema:
          type: string
      responses:
        "204":
          description: Basic Detection Rule Deleted Successfully.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
        "401":
          description: Unauthorized.
        "404":
          description: Basic Detection Rule Not Found.
        "415":
          description: Non-JSON request body was given (Note that the endpoint does
            not take a request body).
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
        "500":
          description: Internal Server Error
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Delete a Basic Detection Rule
      tags:
      - Basic Detection Rules
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          BASIC_DETECTION_RULE_ID = 'YOUR DETECTION RULE ID HERE'


          def delete_basic_detection_rule(s: Session) -> None:
              response = s.delete(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com"
                                  f"/management/tags/{BASIC_DETECTION_RULE_ID}",
                                  headers={'x-api-key': API_KEY})
              if response.status_code == 204:
                  print(f'Deleted {BASIC_DETECTION_RULE_ID}')
              else:
                  print(f'Failed to delete {BASIC_DETECTION_RULE_ID}. status_code={response.status_code}')
                  print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              delete_basic_detection_rule(session)
    get:
      description: "For more context on basic detection rules, notification, notification\
        \ targets, and labels, \nas well as instructions on handling rate limits,\
        \ consult [this section's introduction](#tag/Basic-Detection-Rules).\n"
      operationId: getManagementTagById
      parameters:
      - description: |
          \
          The id of the change detection rule.
        example: 00000000-0000-00cf-0000-000000000000
        in: path
        name: tag_id
        required: true
        schema:
          type: string
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/TagById/value
              schema:
                $ref: '#/components/schemas/postManagementTags_201_response'
          description: Basic Detection Rule in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
        "401":
          description: Unauthorized.
        "404":
          description: Basic Detection Rule Not Found.
        "415":
          description: Non-JSON request body was given (Note that the endpoint does
            not take a request body).
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Retrieve a Basic Detection Rule
      tags:
      - Basic Detection Rules
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = "acd86e59-10bd-4fc0-b9ed-9ae91fe76de8"
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          BASIC_DETECTION_RULE_ID = '17791813-6c46-4f45-9130-d5f7bdb13813'


          def get_basic_detection_rule(s: Session) -> None:
              response = s.get(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com"
                               f"/management/tags/{BASIC_DETECTION_RULE_ID}",
                               headers={'x-api-key': API_KEY})
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              get_basic_detection_rule(session)
    patch:
      description: "For more context on basic detection rules, notification, notification\
        \ targets, and labels, \nas well as instructions on handling rate limits,\
        \ consult [this section's introduction](#tag/Basic-Detection-Rules).\n"
      operationId: patchManagementTagById
      parameters:
      - description: |
          \
          The id of the change detection rule.
        example: 00000000-0000-00cf-0000-000000000000
        in: path
        name: tag_id
        required: true
        schema:
          type: string
      requestBody:
        content:
          application/json:
            example:
              tag:
                sources:
                - id: 565c1b7b-c08b-4c87-a42a-ab08bad56071
            schema:
              $ref: '#/components/schemas/patchManagementTagById_request'
        required: true
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/TagById/value
              schema:
                $ref: '#/components/schemas/postManagementTags_201_response'
          description: Success. Modified Basic Detection Rule in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
        "400":
          description: Basic Detection Rule Parameter Value(s) Specified In Request
            Body Invalid.
        "401":
          description: Unauthorized.
        "404":
          description: Tag Not Found.
        "415":
          description: Non-JSON request body was given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Modify a Basic Detection Rule
      tags:
      - Basic Detection Rules
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          LOG_ID = 'YOUR LOG ID HERE'
          BASIC_DETECTION_RULE_ID = 'YOUR DETECTION RULE ID HERE'

          BASIC_DETECTION_RULE = {
              "tag": {
                  "name": "Updated Tag Name",
              }
          }


          def update_basic_detection_rule(s: Session) -> None:
              response = s.patch(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com"
                                 f"/management/tags/{BASIC_DETECTION_RULE_ID}",
                                 headers={'x-api-key': API_KEY},
                                 json=BASIC_DETECTION_RULE)
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              update_basic_detection_rule(session)
    put:
      description: "For more context on basic detection rules, notification, notification\
        \ targets, and labels, \nas well as instructions on handling rate limits,\
        \ consult [this section's introduction](#tag/Basic-Detection-Rules).\n"
      operationId: putManagementTagById
      parameters:
      - description: |
          \
          The id of the change detection rule.
        example: 00000000-0000-00cf-0000-000000000000
        in: path
        name: tag_id
        required: true
        schema:
          type: string
      requestBody:
        content:
          application/json:
            example:
              $ref: ../../insightops-examples.yml#/components/examples/CreateOrPutTag/value
            schema:
              $ref: '#/components/schemas/putManagementTagById_request'
        required: true
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/TagById/value
              schema:
                $ref: '#/components/schemas/postManagementTags_201_response'
          description: Success. New Basic Detection Rule in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
        "400":
          description: Basic Detection Rule Specified in Request Body Invalid.
        "401":
          description: Unauthorized.
        "404":
          description: Basic Detection Rule Not Found.
        "415":
          description: Non-JSON request body was given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1tags~1{rule_id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Replace a Basic Detection Rule
      tags:
      - Basic Detection Rules
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          LOG_ID = 'YOUR LOG ID HERE'
          BASIC_DETECTION_RULE_ID = 'YOUR DETECTION RULE ID HERE'

          BASIC_DETECTION_RULE = {
              "tag": {
                  "actions": [
                      {
                          "enabled": True,
                          "min_matches_count": 0,
                          "min_matches_period": "Hour",
                          "min_report_count": 1,
                          "min_report_period": "Hour",
                          "targets": [
                              {
                                  "alert_content_set":
                                  {
                                      "le_context": "true"
                                  },
                                  "params_set": {
                                      "direct": "test@test.com",
                                  },
                                  "type": "mailto"
                              }
                          ],
                          "type": "Alert"
                      }
                  ],
                  "labels": [],
                  "name": "REPLACED Tag",
                  "leql": {
                      "statement": "where(/Replaced/)"
                  },
                  "sources": [
                      {
                          "id": LOG_ID
                      }
                  ],
                  "type": "Alert"
              }
          }


          def replace_basic_detection_rule(s: Session) -> None:
              response = s.put(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com"
                                f"/management/tags/{BASIC_DETECTION_RULE_ID}",
                                headers={'x-api-key': API_KEY},
                                json=BASIC_DETECTION_RULE)
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              replace_basic_detection_rule(session)
  /management/actions:
    get:
      description: "For more context on basic detection rules, notification, notification\
        \ targets, and labels, \nas well as instructions on handling rate limits,\
        \ consult [this section's introduction](#tag/Basic-Detection-Rules).\n"
      operationId: getManagementAlertNotificationSettings
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/ListTagActions/value
              schema:
                $ref: '#/components/schemas/getManagementAlertNotificationSettings_200_response'
          description: Notifications in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "401":
          description: Unauthorized.
        "415":
          description: Non-JSON request body was given (Note that the endpoint does
            not take a request body).
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: List All Notifications
      tags:
      - Basic Detection Rules
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region


          def list_basic_detection_rule_notifications(s: Session) -> None:
              response = s.get(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/management/actions",
                               headers={'x-api-key': API_KEY})
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              list_basic_detection_rule_notifications(session)
    post:
      description: "For more context on basic detection rules, notification, notification\
        \ targets, and labels, \nas well as instructions on handling rate limits,\
        \ consult [this section's introduction](#tag/Basic-Detection-Rules).\n"
      operationId: postManagementTagActions
      requestBody:
        content:
          application/json:
            example:
              $ref: ../../insightops-examples.yml#/components/examples/CreateOrPutTagAction/value
            schema:
              $ref: '#/components/schemas/postManagementTagActions_request'
        required: true
      responses:
        "201":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/TagActionById/value
              schema:
                $ref: '#/components/schemas/postManagementTagActions_201_response'
          description: Notification Created. ID in Response
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "400":
          description: Notification Specified In Request Body Invalid.
        "401":
          description: Unauthorized.
        "415":
          description: Non-JSON request body was given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Create a Notification
      tags:
      - Basic Detection Rules
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          NOTIFICATION_TARGET_ID = 'YOUR NOTIFICATION TARGET ID HERE'

          BASIC_DETECTION_RULE_NOTIFICATION = {
              "action": {
                  "min_matches_count": 0,
                  "min_report_count": 1,
                  "min_matches_period": "Hour",
                  "min_report_period": "Hour",
                  "targets": [
                      {"id": NOTIFICATION_TARGET_ID}
                  ]
              }
          }


          def create_basic_detection_rule_notification(s: Session) -> None:
              response = s.post(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/management/actions",
                                headers={'x-api-key': API_KEY},
                                json=BASIC_DETECTION_RULE_NOTIFICATION)
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              create_basic_detection_rule_notification(session)
  /management/actions/{action_id}:
    delete:
      description: "For more context on basic detection rules, notification, notification\
        \ targets, and labels, \nas well as instructions on handling rate limits,\
        \ consult [this section's introduction](#tag/Basic-Detection-Rules).\n"
      operationId: deleteManagementTagActionById
      parameters:
      - description: |
          \
          The id of the notification.
        example: 00000000-0000-00cf-0000-000000000000
        in: path
        name: action_id
        required: true
        schema:
          type: string
      responses:
        "204":
          description: Alert Notification Settings Deleted Successfully.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
        "401":
          description: Unauthorized.
        "404":
          description: Notification Not Found.
        "415":
          description: Non-JSON request body was given (Note that the endpoint does
            not take a request body).
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
        "500":
          description: Internal Server Error
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Delete a Notification
      tags:
      - Basic Detection Rules
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: "import json\nfrom requests import Session\nfrom requests.adapters\
          \ import HTTPAdapter\nfrom urllib3.util.retry import Retry\n\nAPI_KEY =\
          \ 'YOUR API KEY HERE'\nDATA_STORAGE_REGION = 'eu'  # Swap for your region\n\
          NOTIFICATION_ID = 'YOUR NOTIFICATION ID HERE'\n\n\ndef delete_basic_detection_rule_notification(s:\
          \ Session) -> None:\n    response = s.delete(f\"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com\"\
          \n                        f\"/management/actions/{NOTIFICATION_ID}\",\n\
          \                        headers={'x-api-key': API_KEY})\n    if response.status_code\
          \ == 200:\n        print(f'Deleted {NOTIFICATION_ID}')\n    else:\n    \
          \    print(f'Failed to delete {NOTIFICATION_ID}. status_code={response.status_code}')\n\
          \        print(json.dumps(response.json(), indent=4))\n\n\nif __name__ ==\
          \ '__main__':\n    session = Session()\n    session.mount(\n        f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',\n\
          \        HTTPAdapter(max_retries=(\n            # Handles rate limiting\
          \ by default, by sleeping until the limit has reset before retrying.\n \
          \           Retry(total=3,\n                  backoff_factor=1,\n      \
          \            status_forcelist=[500, 502, 503, 504])\n        ))\n    )\n\
          \    delete_basic_detection_rule_notification(session)            \n"
    get:
      description: "For more context on basic detection rules, notification, notification\
        \ targets, and labels, \nas well as instructions on handling rate limits,\
        \ consult [this section's introduction](#tag/Basic-Detection-Rules).\n"
      operationId: getManagementTagActionById
      parameters:
      - description: |
          \
          The id of the notification.
        example: 00000000-0000-00cf-0000-000000000000
        in: path
        name: action_id
        required: true
        schema:
          type: string
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/AlertNotificationSettingById/value
              schema:
                $ref: '#/components/schemas/postManagementTagActions_201_response'
          description: Notification in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
        "401":
          description: Unauthorized.
        "404":
          description: Notification Not Found.
        "415":
          description: Non-JSON request body was given (Note that the endpoint does
            not take a request body).
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Retrieve a Notification
      tags:
      - Basic Detection Rules
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          NOTIFICATION_ID = 'YOUR NOTIFICATION ID HERE'


          def get_basic_detection_rule_notification(s: Session) -> None:
              response = s.get(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com"
                               f"/management/actions/{NOTIFICATION_ID}",
                               headers={'x-api-key': API_KEY}, )
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              get_basic_detection_rule_notification(session)
    patch:
      description: "For more context on basic detection rules, notification, notification\
        \ targets, and labels, \nas well as instructions on handling rate limits,\
        \ consult [this section's introduction](#tag/Basic-Detection-Rules).\n"
      operationId: patchManagementTagActionById
      parameters:
      - description: |
          \
          The id of the notification.
        example: 00000000-0000-00cf-0000-000000000000
        in: path
        name: action_id
        required: true
        schema:
          type: string
      requestBody:
        content:
          application/json:
            example:
              $ref: ../../insightops-examples.yml#/components/examples/CreateOrPutTagAction/value
            schema:
              $ref: '#/components/schemas/postManagementTagActions_request'
        required: true
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/TagActionById/value
              schema:
                $ref: '#/components/schemas/postManagementTagActions_201_response'
          description: Success. Modified Notification in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
        "400":
          description: Notification Parameter Value(s) Specified In Request Body Invalid.
        "401":
          description: Unauthorized.
        "404":
          description: Notification Not Found.
        "415":
          description: Non-JSON request body was given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Modify a Notification
      tags:
      - Basic Detection Rules
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          NOTIFICATION_ID = 'YOUR NOTIFICATION ID HERE'
          NOTIFICATION_TARGET_ID = 'YOUR NOTIFICATION TARGET ID HERE'

          BASIC_DETECTION_RULE_NOTIFICATION = {
              "action": {
                  "min_matches_count": 5,
                  "min_matches_period": "Hour",
              }
          }


          def update_basic_detection_rule_notification(s: Session) -> None:
              response = s.patch(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com"
                                 f"/management/actions/{NOTIFICATION_ID}",
                                 headers={'x-api-key': API_KEY},
                                 json=BASIC_DETECTION_RULE_NOTIFICATION)
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              update_basic_detection_rule_notification(session)
    put:
      description: "For more context on basic detection rules, notification, notification\
        \ targets, and labels, \nas well as instructions on handling rate limits,\
        \ consult [this section's introduction](#tag/Basic-Detection-Rules).\n"
      operationId: putManagementTagActionById
      parameters:
      - description: |
          \
          The id of the notification.
        example: 00000000-0000-00cf-0000-000000000000
        in: path
        name: action_id
        required: true
        schema:
          type: string
      requestBody:
        content:
          application/json:
            example:
              $ref: ../../insightops-examples.yml#/components/examples/CreateOrPutTagAction/value
            schema:
              $ref: '#/components/schemas/postManagementTagActions_request'
        required: true
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/TagActionById/value
              schema:
                $ref: '#/components/schemas/postManagementTagActions_201_response'
          description: Success. New Notifications in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
        "400":
          description: Notification Specified in Request Body Invalid.
        "401":
          description: Unauthorized.
        "404":
          description: Notification Not Found.
        "415":
          description: Non-JSON request body was given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1actions~1{action_id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Replace a Notification
      tags:
      - Basic Detection Rules
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          NOTIFICATION_ID = 'YOUR NOTIFICATION ID HERE'
          NOTIFICATION_TARGET_ID = 'YOUR NOTIFICATION TARGET ID HERE'

          BASIC_DETECTION_RULE_NOTIFICATION = {
              "action": {
                  "min_matches_count": 0,
                  "min_report_count": 1,
                  "min_matches_period": "Day",
                  "min_report_period": "Day",
                  "targets": [
                      {"id": NOTIFICATION_TARGET_ID}
                  ]
              }
          }


          def replace_basic_detection_rule_notification(s: Session) -> None:
              response = s.put(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com"
                               f"/management/actions/{NOTIFICATION_ID}",
                               headers={'x-api-key': API_KEY},
                               json=BASIC_DETECTION_RULE_NOTIFICATION)
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              replace_basic_detection_rule_notification(session)
  /management/actions/{action_id}/targets:
    get:
      description: "Given the ID of a notification, returns all notification targets\
        \ currently attached to that notification.\nFor more context on basic detection\
        \ rules, notification, notification targets, and labels, \nas well as instructions\
        \ on handling rate limits, consult [this section's introduction](#tag/Basic-Detection-Rules).\n"
      operationId: getManagementTagActionTargets
      parameters:
      - description: |
          \
          The id of the notification.
        example: 00000000-0000-00cf-0000-000000000000
        in: path
        name: action_id
        required: true
        schema:
          type: string
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/AlertNotificationTarget/value
              schema:
                $ref: '#/components/schemas/getManagementTagActionTargets_200_response'
          description: Notification Targets in Response Body
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1actions~1{action_id}~1targets"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1actions~1{action_id}~1targets"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1actions~1{action_id}~1targets"
            Retry-After:
              $ref: "#/components/headers/~1management~1actions~1{action_id}~1targets"
        "401":
          description: Unauthorized.
        "415":
          description: Non-JSON request body was given (Note that the endpoint does
            not take a request body).
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1actions~1{action_id}~1targets"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1actions~1{action_id}~1targets"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1actions~1{action_id}~1targets"
            Retry-After:
              $ref: "#/components/headers/~1management~1actions~1{action_id}~1targets"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: List All Targets Attached To A Notification
      tags:
      - Basic Detection Rules
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          NOTIFICATION_ID = 'YOUR NOTIFICATION ID HERE'


          def list_targets_for_notification(s: Session) -> None:
              response = s.get(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com"
                               f"/management/actions/{NOTIFICATION_ID}/targets",
                               headers={'x-api-key': API_KEY})
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              list_targets_for_notification(session)
    patch:
      description: "Using the ID of a notification, modify the notification target\
        \ that is attached to it.\nThis endpoint only allows updating a notification\
        \ to have one notification target attached to it.\nTo attach multiple targets\
        \ to a notification you can use the [\"management/actions\"](#operation/patchManagementTagActionById)\
        \ endpoint.\nFor more context on basic detection rules, notification, notification\
        \ targets, and labels, \nas well as instructions on handling rate limits,\
        \ consult [this section's introduction](#tag/Basic-Detection-Rules).\n"
      operationId: patchManagementTagActionTargetById
      parameters:
      - description: |
          \
          The id of the notification.
        example: 00000000-0000-00cf-0000-000000000000
        in: path
        name: action_id
        required: true
        schema:
          type: string
      requestBody:
        content:
          application/json:
            example:
              $ref: ../../insightops-examples.yml#/components/examples/CreateOrPutTarget/value
            schema:
              $ref: '#/components/schemas/patchManagementTagActionTargetById_request'
        required: true
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/AlertNotificationTarget/value
              schema:
                $ref: '#/components/schemas/patchManagementTagActionTargetById_request'
          description: Success. Modified Notification Targets in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1actions~1{action_id}~1targets"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1actions~1{action_id}~1targets"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1actions~1{action_id}~1targets"
            Retry-After:
              $ref: "#/components/headers/~1management~1actions~1{action_id}~1targets"
        "400":
          description: Notification Targets Parameter Value(s) Specified In Request
            Body Invalid.
        "401":
          description: Unauthorized.
        "404":
          description: Notification Not Found.
        "415":
          description: Non-JSON request body was given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1actions~1{action_id}~1targets"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1actions~1{action_id}~1targets"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1actions~1{action_id}~1targets"
            Retry-After:
              $ref: "#/components/headers/~1management~1actions~1{action_id}~1targets"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Modify the Targets Attached To A Notification
      tags:
      - Basic Detection Rules
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          NOTIFICATION_ID = 'YOUR NOTIFICATION ID HERE'
          UPDATED_NOTIFICATION_TARGET_ID = 'YOUR NOTIFICATION TARGET ID HERE'


          def update_targets_for_notification(s: Session) -> None:
              response = s.patch(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com"
                                 f"/management/actions/{NOTIFICATION_ID}/targets",
                                 headers={'x-api-key': API_KEY},
                                 json={"target": {"id": UPDATED_NOTIFICATION_TARGET_ID}})
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              update_targets_for_notification(session)
  /management/targets:
    get:
      description: "For more context on basic detection rules, notification, notification\
        \ targets, and labels, \nas well as instructions on handling rate limits,\
        \ consult [this section's introduction](#tag/Basic-Detection-Rules).\n"
      operationId: getManagementTargets
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/ListTargets/value
              schema:
                $ref: '#/components/schemas/target_response'
          description: Notification Targets in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "401":
          description: Unauthorized.
        "415":
          description: Non-JSON Request Body Given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: List All Targets
      tags:
      - Basic Detection Rules
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region


          def list_notifications_targets(s: Session) -> None:
              response = s.get(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/management/targets",
                               headers={'x-api-key': API_KEY})
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              list_notifications_targets(session)
    post:
      description: "For more context on basic detection rules, notification, notification\
        \ targets, and labels, \nas well as instructions on handling rate limits,\
        \ consult [this section's introduction](#tag/Basic-Detection-Rules).\n"
      operationId: postManagementTargets
      requestBody:
        content:
          application/json:
            example:
              $ref: ../../insightops-examples.yml#/components/examples/CreateOrPutTarget/value
            schema:
              $ref: '#/components/schemas/create_put_target'
        required: true
      responses:
        "201":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/TargetById/value
              schema:
                $ref: '#/components/schemas/target_response'
          description: Notification Target Created. ID in Response.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "400":
          description: Notification Targets Specified in Request Body Invalid.
        "401":
          description: Unauthorized.
        "403":
          description: Forbidden.
        "415":
          description: Non-JSON Request Body Given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Create a Target
      tags:
      - Basic Detection Rules
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region

          NOTIFICATION_TARGET = {
              "target": {
                      "name": "My Notification Target",
                      "description": "My Clever Description",
                      "type": "Mailto",
                      "params_set": {
                          "direct": "my_name@my_organisation.com"
                      },
                      "user_data": {},
                      "alert_content_set": {
                          "le_trigger_event": "true",
                          "le_context": "true"
                      }
                  }
          }


          def create_notification_target(s: Session) -> None:
              response = s.post(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/management/targets",
                                headers={'x-api-key': API_KEY},
                                json=NOTIFICATION_TARGET)
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              create_notification_target(session)
  /management/targets/{target_id}:
    delete:
      description: "For more context on basic detection rules, notification, notification\
        \ targets, and labels, \nas well as instructions on handling rate limits,\
        \ consult [this section's introduction](#tag/Basic-Detection-Rules).\n"
      operationId: deleteManagementTargetById
      parameters:
      - description: |
          \
          The id of the notification target.
        example: 4a8869fa-0843-4edd-85f5-bf7d6b80d6c5
        in: path
        name: target_id
        required: true
        schema:
          type: string
      responses:
        "204":
          description: Notification Target Deleted Successfully.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1targets~1{target_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1targets~1{target_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1targets~1{target_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1targets~1{target_id}"
        "401":
          description: Unauthorized.
        "404":
          description: Notification Target Not Found.
        "415":
          description: Non-JSON Request Body Given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1targets~1{target_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1targets~1{target_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1targets~1{target_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1targets~1{target_id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Delete a Target
      tags:
      - Basic Detection Rules
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          NOTIFICATION_TARGET_ID = 'YOUR NOTIFICATION TARGET ID HERE'


          def delete_notification_target(s: Session) -> None:
              response = s.delete(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com"
                                  f"/management/targets/{NOTIFICATION_TARGET_ID}",
                                  headers={'x-api-key': API_KEY})
              if response.status_code == 204:
                  print(f'Deleted {NOTIFICATION_TARGET_ID}')
              else:
                  print(f'Failed to delete {NOTIFICATION_TARGET_ID}. status_code={response.status_code}')
                  print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              delete_notification_target(session)
    get:
      description: "For more context on basic detection rules, notification, notification\
        \ targets, and labels, \nas well as instructions on handling rate limits,\
        \ consult [this section's introduction](#tag/Basic-Detection-Rules).\n"
      operationId: getManagementTargetById
      parameters:
      - description: |
          \
          The id of the notification target.
        example: 4a8869fa-0843-4edd-85f5-bf7d6b80d6c5
        in: path
        name: target_id
        required: true
        schema:
          type: string
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/TargetById/value
              schema:
                $ref: '#/components/schemas/target_response'
          description: Notification Target in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1targets~1{target_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1targets~1{target_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1targets~1{target_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1targets~1{target_id}"
        "401":
          description: Unauthorized.
        "404":
          description: Notification Target Not Found.
        "415":
          description: Non-JSON Request Body Given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1targets~1{target_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1targets~1{target_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1targets~1{target_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1targets~1{target_id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Retrieve a Target
      tags:
      - Basic Detection Rules
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          NOTIFICATION_TARGET_ID = 'YOUR NOTIFICATION TARGET ID HERE'


          def create_notification_target(s: Session) -> None:
              response = s.get(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com"
                               f"/management/targets/{NOTIFICATION_TARGET_ID}",
                               headers={'x-api-key': API_KEY})
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              create_notification_target(session)
    put:
      description: "For more context on basic detection rules, notification, notification\
        \ targets, and labels, \nas well as instructions on handling rate limits,\
        \ consult [this section's introduction](#tag/Basic-Detection-Rules).\n"
      operationId: putManagementTargetById
      parameters:
      - description: |
          \
          The id of the notification target.
        example: 4a8869fa-0843-4edd-85f5-bf7d6b80d6c5
        in: path
        name: target_id
        required: true
        schema:
          type: string
      requestBody:
        content:
          application/json:
            example:
              $ref: ../../insightops-examples.yml#/components/examples/CreateOrPutTarget/value
            schema:
              $ref: '#/components/schemas/create_put_target'
        required: true
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/TargetById/value
              schema:
                $ref: '#/components/schemas/target_response'
          description: Success. Modified Notification Target in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1targets~1{target_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1targets~1{target_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1targets~1{target_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1targets~1{target_id}"
        "400":
          description: Notification Target Specified in Request Body Invalid.
        "401":
          description: Unauthorized.
        "403":
          description: Forbidden.
        "404":
          description: Target Not Found.
        "415":
          description: Non-JSON Request Body Given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1targets~1{target_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1targets~1{target_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1targets~1{target_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1targets~1{target_id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Replace a Target
      tags:
      - Basic Detection Rules
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          NOTIFICATION_TARGET_ID = 'YOUR NOTIFICATION TARGET ID HERE'

          NOTIFICATION_TARGET = {
              "target": {
                  "name": "My Replace Notification Target",
                  "description": "My Replaced Description",
                  "type": "Mailto",
                  "params_set": {
                      "direct": "replaced@my_organisation.com"
                  },
                  "user_data": {},
                  "alert_content_set": {
                      "le_trigger_event": "true",
                      "le_context": "true"
                  }
              }
          }


          def replace_notification_target(s: Session) -> None:
              response = s.put(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com"
                               f"/management/targets/{NOTIFICATION_TARGET_ID}",
                               headers={'x-api-key': API_KEY},
                               json=NOTIFICATION_TARGET)
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              replace_notification_target(session)
  /management/logs:
    get:
      description: |
        For more context on logs and log sets, as well as instructions on handling rate limits consult [this section's introduction](#tag/Logs-and-Log-Sets).
      operationId: getLogs
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/LogsResponse/value
              schema:
                $ref: '#/components/schemas/logs_response'
          description: Logs in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
        "400":
          description: Invalid Request.
        "401":
          description: Unauthorized.
        "415":
          description: Unsupported Media Type.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
        "503":
          description: Service Unavailable.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Retrieve All Logs
      tags:
      - Logs & Log Sets
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region


          def list_all_logs(s: Session) -> None:
              response = s.get(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/management/logs",
                               headers={'x-api-key': API_KEY})
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              list_all_logs(session)
    post:
      description: |
        For more context on logs and log sets, as well as instructions on handling rate limits consult [this section's introduction](#tag/Logs-and-Log-Sets).
      operationId: postLog
      requestBody:
        content:
          application/json:
            example:
              $ref: ../../insightops-examples.yml#/components/examples/CreateOrPutLog/value
            schema:
              $ref: '#/components/schemas/create_or_put_log'
        required: true
      responses:
        "201":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/LogResponse/value
              schema:
                $ref: '#/components/schemas/log_response'
          description: New Log Returned.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
        "400":
          description: Invalid Request.
        "401":
          description: Unauthorized.
        "405":
          description: Method Not Allowed.
        "415":
          description: Unsupported Media Type. Non-JSON Request Body Given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
        "503":
          description: Service Unavailable.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Create a Log
      tags:
      - Logs & Log Sets
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          LOGSET_ID = 'YOUR LOGSET ID HERE'
          LOG = {
              'log': {
                  'name': 'my log',
                  'structures': [],
                  'source_type': 'token',
                  'token_seed': None,
                  'user_data': {
                      'foo': 'bar'
                  },
                  'logsets_info': [
                      {
                          'id': LOGSET_ID
                      }
                  ]
              }
          }


          def create_log(s: Session) -> None:
              response = s.post(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/management/logs",
                                headers={'x-api-key': API_KEY},
                                json=LOG)
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              create_log(session)
  /management/logs/{id}:
    delete:
      description: |
        For more context on logs and log sets, as well as instructions on handling rate limits consult [this section's introduction](#tag/Logs-and-Log-Sets).
      operationId: deleteLog
      parameters:
      - description: |
          \
          The id of the log to be queried.
        example: a53578a2-e667-423b-9694-3e989c388186
        in: path
        name: id
        required: true
        schema:
          type: string
      responses:
        "204":
          description: Log Deleted.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1logs~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1logs~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1logs~1{id}"
        "400":
          description: Invalid Request.
        "401":
          description: Unauthorized.
        "404":
          description: Log Not Found.
        "405":
          description: Method Not Allowed.
        "415":
          description: Unsupported Media Type.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1logs~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1logs~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1logs~1{id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1logs~1{id}"
        "500":
          description: Internal Server Error.
        "503":
          description: Service Unavailable.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Delete a Log
      tags:
      - Logs & Log Sets
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          LOG_ID = 'YOUR LOG ID HERE'


          def delete_log(s: Session) -> None:
              response = s.delete(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/management/logs/{LOG_ID}",
                                  headers={'x-api-key': API_KEY})
              if response.status_code == 204:
                  print(f'Deleted {LOG_ID}')
              else:
                  print(f'Failed to delete {LOG_ID}. status_code={response.status_code}')
                  print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              delete_log(session)
    get:
      description: |
        For more context on logs and log sets, as well as instructions on handling rate limits consult [this section's introduction](#tag/Logs-and-Log-Sets).
      operationId: getLog
      parameters:
      - description: |
          \
          The id of the log to be queried.
        example: a53578a2-e667-423b-9694-3e989c388186
        in: path
        name: id
        required: true
        schema:
          type: string
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/LogResponse/value
              schema:
                $ref: '#/components/schemas/log_response'
          description: Log Successfully Returned.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1logs~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1logs~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1logs~1{id}"
        "400":
          description: Invalid Request.
        "401":
          description: Unauthorized.
        "404":
          description: Log Not Found.
        "415":
          description: Unsupported Media Type.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1logs~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1logs~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1logs~1{id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1logs~1{id}"
        "500":
          description: Internal Server Error.
        "503":
          description: Service Unavailable.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Retrieve a Log
      tags:
      - Logs & Log Sets
      x-code-samples:
      - lang: Shell
        label: curl
        source: |
          curl -H 'x-api-key: 00000000-0000-0000-0000-000000000000' \
          -G \
          https://us.rest.logs.insight.rapid7.com/management/logs/00000000-0000-0000-0000-000000000000
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          LOG_ID = 'YOUR LOG ID HERE'


          def get_log(s: Session) -> None:
              response = s.get(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/management/logs/{LOG_ID}",
                               headers={'x-api-key': API_KEY})
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              get_log(session)
    put:
      description: |
        For more context on logs and log sets, as well as instructions on handling rate limits consult [this section's introduction](#tag/Logs-and-Log-Sets).
      operationId: putLog
      parameters:
      - description: |
          \
          The id of the log to be queried.
        example: a53578a2-e667-423b-9694-3e989c388186
        in: path
        name: id
        required: true
        schema:
          type: string
      requestBody:
        content:
          application/json:
            example:
              $ref: ../../insightops-examples.yml#/components/examples/CreateOrPutLog/value
            schema:
              $ref: '#/components/schemas/create_or_put_log'
        required: true
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/LogResponse/value
              schema:
                $ref: '#/components/schemas/log_response'
          description: New Log Returned.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1logs~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1logs~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1logs~1{id}"
        "400":
          description: Invalid Request.
        "401":
          description: Unauthorized.
        "404":
          description: Log Not Found.
        "405":
          description: Method Not Allowed.
        "415":
          description: Unsupported Media Type. Non-JSON Request Body Given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1logs~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1logs~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1logs~1{id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1logs~1{id}"
        "500":
          description: Internal Server Error.
        "503":
          description: Service Unavailable.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Replace a Log
      tags:
      - Logs & Log Sets
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          LOG_ID = 'YOUR LOG ID HERE'
          LOGSET_ID = 'YOUR LOGSET ID HERE'
          LOG = {
              'log': {
                  'name': 'my replaced log',
                  'structures': [],
                  'source_type': 'token',
                  'token_seed': None,
                  'user_data': {
                      'foo': 'baz'
                  },
                  'logsets_info': [
                      {
                          'id': LOGSET_ID
                      }
                  ]
              }
          }


          def replace_log(s: Session) -> None:
              response = s.put(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/management/logs/{LOG_ID}",
                               headers={'x-api-key': API_KEY},
                               json=LOG)
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              replace_log(session)
  /management/logs/{id}/topkeys:
    get:
      description: "For more context on keys and commonly occurring keys, \nas well\
        \ as instructions on handling rate limits consult [this section's introduction](#tag/Retrieve-The-Most-Common-Keys-Within-Your-Log-Data).\n"
      operationId: getLogTopkeys
      parameters:
      - description: |
          \
          The id of the log to be queried.
        example: a53578a2-e667-423b-9694-3e989c388186
        in: path
        name: id
        required: true
        schema:
          type: string
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/LogTopkeysResponse/value
              schema:
                $ref: '#/components/schemas/log_topkeys_response'
          description: Most Common Keys in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1logs~1{id}~1topkeys"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1logs~1{id}~1topkeys"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1logs~1{id}~1topkeys"
        "400":
          description: Invalid Request.
        "401":
          description: Unauthorized.
        "404":
          description: Log Not Found.
        "415":
          description: Unsupported Media Type.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1logs~1{id}~1topkeys"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1logs~1{id}~1topkeys"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1logs~1{id}~1topkeys"
            Retry-After:
              $ref: "#/components/headers/~1management~1logs~1{id}~1topkeys"
        "500":
          description: Internal Server Error.
        "503":
          description: Service Unavailable.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Retrieve Most Common Keys For A Log
      tags:
      - Retrieve The Most Common Keys Within Your Log Data
      x-code-samples:
      - lang: Shell
        label: curl
        source: |
          curl -H 'x-api-key: 00000000-0000-0000-0000-000000000000' \
          -G \
          https://us.rest.logs.insight.rapid7.com/management/logs/00000000-0000-0000-0000-000000000000/topkeys
  /management/logsets:
    get:
      description: |
        For more context on logs and log sets, as well as instructions on handling rate limits consult [this section's introduction](#tag/Logs-and-Log-Sets).
      operationId: getManagementLogsets
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/ListLogsets/value
              schema:
                $ref: '#/components/schemas/logset_response'
          description: Log Sets in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
        "401":
          description: Unauthorized.
        "415":
          description: Non-JSON Request Body Given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: List All Log Sets
      tags:
      - Logs & Log Sets
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region


          def list_all_logsets(s: Session) -> None:
              response = s.get(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/management/logsets",
                               headers={'x-api-key': API_KEY})
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              list_all_logsets(session)
    post:
      description: |
        For more context on logs and log sets, as well as instructions on handling rate limits consult [this section's introduction](#tag/Logs-and-Log-Sets).
      operationId: postManagementLogsets
      requestBody:
        content:
          application/json:
            example:
              $ref: ../../insightops-examples.yml#/components/examples/CreateOrPutLogset/value
            schema:
              $ref: '#/components/schemas/create_logset'
        required: true
      responses:
        "201":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/LogsetById/value
              schema:
                $ref: '#/components/schemas/logset_response'
          description: Log Set Created. ID in Response.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
        "400":
          description: Log Set Specified in Request Body Invalid.
        "401":
          description: Unauthorized.
        "403":
          description: Forbidden.
        "415":
          description: Non-JSON Request Body Given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Create a Log Set
      tags:
      - Logs & Log Sets
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          LOGSET = {
              "logset": {
                  "name": "My New LogSet"
              }
          }


          def create_logset(s: Session) -> None:
              response = s.post(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/management/logsets",
                                headers={'x-api-key': API_KEY},
                                json=LOGSET)
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              create_logset(session)
  /management/logsets/{logset_id}:
    delete:
      description: |
        For more context on logs and log sets, as well as instructions on handling rate limits consult [this section's introduction](#tag/Logs-and-Log-Sets).
      operationId: deleteManagementLogsetById
      parameters:
      - description: |
          \
          The id of the log set to be queried.
        example: 4a8869fa-0843-4edd-85f5-bf7d6b80d6c5
        in: path
        name: logset_id
        required: true
        schema:
          type: string
      responses:
        "204":
          description: Log Set Deleted Successfully.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1logsets~1{logset_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1logsets~1{logset_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1logsets~1{logset_id}"
        "401":
          description: Unauthorized.
        "404":
          description: Log Set Not Found.
        "415":
          description: Non-JSON Request Body Given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1logsets~1{logset_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1logsets~1{logset_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1logsets~1{logset_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1logsets~1{logset_id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Delete a Log Set
      tags:
      - Logs & Log Sets
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          LOGSET_ID = 'YOUR LOGSET ID HERE'


          def delete_logset(s: Session) -> None:
              response = s.delete(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/management/logsets/{LOGSET_ID}",
                                  headers={'x-api-key': API_KEY})
              if response.status_code == 204:
                  print(f'Deleted {LOGSET_ID}')
              else:
                  print(f'Failed to delete {LOGSET_ID}. status_code={response.status_code}')
                  print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              delete_logset(session)
    get:
      description: |
        For more context on logs and log sets, as well as instructions on handling rate limits consult [this section's introduction](#tag/Logs-and-Log-Sets).
      operationId: getManagementLogsetById
      parameters:
      - description: |
          \
          The id of the log set to be queried.
        example: 4a8869fa-0843-4edd-85f5-bf7d6b80d6c5
        in: path
        name: logset_id
        required: true
        schema:
          type: string
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/LogsetById/value
              schema:
                $ref: '#/components/schemas/logset_response'
          description: Log Set in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1logsets~1{logset_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1logsets~1{logset_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1logsets~1{logset_id}"
        "401":
          description: Unauthorized.
        "404":
          description: Log Set Not Found.
        "415":
          description: Non-JSON Request Body Given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1logsets~1{logset_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1logsets~1{logset_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1logsets~1{logset_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1logsets~1{logset_id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Retrieve a Log Set
      tags:
      - Logs & Log Sets
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          LOGSET_ID = 'YOUR LOGSET ID HERE'


          def get_logset(s: Session) -> None:
              response = s.get(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/management/logsets/{LOGSET_ID}",
                                headers={'x-api-key': API_KEY})
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              get_logset(session)
    put:
      description: |
        For more context on logs and log sets, as well as instructions on handling rate limits consult [this section's introduction](#tag/Logs-and-Log-Sets).
      operationId: putManagementLogsetById
      parameters:
      - description: |
          \
          The id of the log set to be queried.
        example: 4a8869fa-0843-4edd-85f5-bf7d6b80d6c5
        in: path
        name: logset_id
        required: true
        schema:
          type: string
      requestBody:
        content:
          application/json:
            example:
              $ref: ../../insightops-examples.yml#/components/examples/CreateOrPutLogset/value
            schema:
              $ref: '#/components/schemas/logset_response'
        required: true
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/LogsetById/value
              schema:
                $ref: '#/components/schemas/logset_response'
          description: Success. Modified Log Set in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1logsets~1{logset_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1logsets~1{logset_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1logsets~1{logset_id}"
        "400":
          description: Log Set Specified in Request Body Invalid.
        "401":
          description: Unauthorized.
        "403":
          description: Forbidden.
        "404":
          description: Log Set Not Found.
        "415":
          description: Non-JSON Request Body Given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1logsets~1{logset_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1logsets~1{logset_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1logsets~1{logset_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1logsets~1{logset_id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Replace a Log Set
      tags:
      - Logs & Log Sets
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          LOGSET_ID = 'YOUR LOGSET ID HERE'

          LOGSET = {
              "logset": {
                  "name": "My Replaced Logset"
              }
          }


          def replace_logset(s: Session) -> None:
              response = s.put(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/management/logsets/{LOGSET_ID}",
                               headers={'x-api-key': API_KEY},
                               json=LOGSET)
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              replace_logset(session)
  /management/metrics:
    get:
      description: |
        For more context on pre-computed queries, as well as instructions on handling rate limits consult [this section's introduction](#tag/Pre-Computed-Queries).
      operationId: metrics-retrieve_all
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/MetricsResponseList
              schema:
                $ref: '#/components/schemas/MetricsResponseList'
          description: Pre-Computed Queries in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
        "401":
          description: Unauthorized.
        "415":
          description: Incorrect Request Body Format.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: List All Pre-Computed Queries
      tags:
      - Pre-Computed Queries
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region


          def list_precomputed_queries(s: Session) -> None:
              response = s.get(f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/management/metrics',
                               headers={'x-api-key': API_KEY})
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              list_precomputed_queries(session)
    post:
      description: |
        For more context on pre-computed queries, as well as instructions on handling rate limits consult [this section's introduction](#tag/Pre-Computed-Queries).
      operationId: metrics-create
      requestBody:
        content:
          application/json:
            example:
              $ref: ../../insightops-examples.yml#/components/examples/MetricsInput
            schema:
              $ref: '#/components/schemas/metrics_create_request'
        required: true
      responses:
        "201":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/MetricsResponseSingle
              schema:
                $ref: '#/components/schemas/MetricsResponseSingle'
          description: Pre-Computed Query Created.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
        "400":
          description: Invalid Request.
        "401":
          description: Unauthorized.
        "415":
          description: Incorrect Request Body Format.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Create A Pre-Computed Query
      tags:
      - Pre-Computed Queries
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'ap'  # Swap for your region
          LOG_ID = 'YOUR LOG ID HERE'
          NEW_METRIC = {
              "metric": {
                  "name": "test",
                  "description": "test",
                  "enabled": True,
                  "logs": [{"id": LOG_ID}],
                  "leql": {"statement": "where(json.key > 500)", "function": "calculate(count)"},
                  "retention": 600,
                  "resolution": 60
              }
          }


          def create_pre_computed_query(s: Session) -> None:
              response = s.post(f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/management/metrics',
                                headers={'x-api-key': API_KEY},
                                json=NEW_METRIC)
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              create_pre_computed_query(session)
  /management/metrics/{metric_id}:
    delete:
      description: |
        For more context on pre-computed queries, as well as instructions on handling rate limits consult [this section's introduction](#tag/Pre-Computed-Queries).
      operationId: metrics-delete
      parameters:
      - description: |
          \
          The UUID of the pre-computed query.
        example: 9aff96bd-ef12-4887-93b5-00931se12f1a
        in: path
        name: metric_id
        required: true
        schema:
          type: string
      responses:
        "204":
          description: Pre-Computed Query Deleted.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1metrics~1{metric_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1metrics~1{metric_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1metrics~1{metric_id}"
        "401":
          description: Unauthorized.
        "404":
          description: Pre-Computed Query Not Found.
        "415":
          description: Incorrect Request Body Format.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1metrics~1{metric_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1metrics~1{metric_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1metrics~1{metric_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1metrics~1{metric_id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Delete A Pre-Computed Query
      tags:
      - Pre-Computed Queries
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          PCQ_ID = "YOUR PRE-COMPUTED QUERY ID"
          DATA_STORAGE_REGION = 'ap'  # Swap for your region


          def delete_pcq_by_id(s: Session) -> None:
              response = s.delete(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/"
                                  f"management/metrics/{PCQ_ID}",
                                  headers={'x-api-key': API_KEY})
              if response.status_code == 204:
                  print(f"Deleted {PCQ_ID}")
              else:
                  print(f"Failed to delete {PCQ_ID}. status_code={response.status_code}")


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              delete_pcq_by_id(session)
    get:
      description: |
        For more context on pre-computed queries, as well as instructions on handling rate limits consult [this section's introduction](#tag/Pre-Computed-Queries).
      operationId: metrics-retrieve
      parameters:
      - description: |
          \
          The UUID of the pre-computed query.
        example: 9aff96bd-ef12-4887-93b5-00931se12f1a
        in: path
        name: metric_id
        required: true
        schema:
          type: string
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/MetricsResponseSingle
              schema:
                $ref: '#/components/schemas/MetricsResponseSingle'
          description: Pre-Computed Query in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1metrics~1{metric_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1metrics~1{metric_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1metrics~1{metric_id}"
        "401":
          description: Unauthorized.
        "404":
          description: Pre-Computed Query Not Found.
        "415":
          description: Incorrect Request Body Format.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1metrics~1{metric_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1metrics~1{metric_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1metrics~1{metric_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1metrics~1{metric_id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only and Above
      summary: Retrieve A Pre-Computed Query
      tags:
      - Pre-Computed Queries
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          PCQ_ID = "YOUR PRE-COMPUTED QUERY ID"
          DATA_STORAGE_REGION = 'ap'  # Swap for your region


          def get_pcq_by_id(s: Session) -> None:
              response = s.get(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/"
                               f"management/metrics/{PCQ_ID}",
                               headers={'x-api-key': API_KEY})
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              get_pcq_by_id(session)
    put:
      description: |
        For more context on pre-computed queries, as well as instructions on handling rate limits consult [this section's introduction](#tag/Pre-Computed-Queries).
      operationId: metrics-put
      parameters:
      - description: |
          \
          The UUID of the pre-computed query.
        example: 9aff96bd-ef12-4887-93b5-00931se12f1a
        in: path
        name: metric_id
        required: true
        schema:
          type: string
      requestBody:
        content:
          application/json:
            example:
              $ref: ../../insightops-examples.yml#/components/examples/MetricsInput
            schema:
              $ref: '#/components/schemas/metrics_create_request'
        required: true
      responses:
        "201":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/MetricsResponseSingle
              schema:
                $ref: '#/components/schemas/MetricsResponseSingle'
          description: Pre-Computed Query Replaced.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1metrics~1{metric_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1metrics~1{metric_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1metrics~1{metric_id}"
        "400":
          description: Invalid Request.
        "401":
          description: Unauthorized.
        "415":
          description: Incorrect Request Body Format.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1metrics~1{metric_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1metrics~1{metric_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1metrics~1{metric_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1metrics~1{metric_id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Replace a Pre-Computed Query
      tags:
      - Pre-Computed Queries
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'ap'  # Swap for your region
          PCQ_ID = "YOUR PRE-COMPUTED QUERY ID"
          LOG_ID = 'YOUR LOG ID HERE'
          NEW_METRIC = {
              "metric": {
                  "name": "test",
                  "description": "test",
                  "enabled": True,
                  "logs": [{"id": LOG_ID}],
                  "leql": {"statement": "where(json.key > 500)", "function": "calculate(count)"},
                  "retention": 600,
                  "resolution": 60
              }
          }


          def replace_pre_computed_query(s: Session) -> None:
              response = s.put(f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/management/metrics/{PCQ_ID}',
                                headers={'x-api-key': API_KEY},
                                json=NEW_METRIC)
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              replace_pre_computed_query(session)
  /management/archiving/s3setup:
    delete:
      description: "For more context on daily archiving, the configurations your S3\
        \ bucket must have, \nand handling rate limits consult [this section's introduction](#tag/Backup-Your-Log-Data-To-S3).\n"
      operationId: deleteArchivingS3Setup
      responses:
        "204":
          description: Daily Archiving Disabled.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
        "401":
          description: Unauthorized.
        "404":
          description: Daily Archiving is Not Enabled.
        "415":
          description: Unsupported Media Type.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Disable Daily Archiving
      tags:
      - Backup Your Log Data To S3
      x-code-samples:
      - lang: Python
        label: Python3
        source: |
          import json
          import requests

          API_KEY = 'YOUR API KEY GOES HERE'
          REQUEST_URL = 'https://us.rest.logs.insight.rapid7.com/management/archiving/s3setup'

          data = {'s3setup':{'bucket_name':'my-bucket','enabled':False,'compression':'GZIP'}}

          def handle_response(response):
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))

          def make_request():
              headers = {'Content-type': 'application/json', 'x-api-key': API_KEY}
              body = json.dumps(data, separators=(',', ':'))
              response = requests.delete(REQUEST_URL, data=body, headers=headers)
              return response

          def start():
              response = make_request()
              handle_response(response)

          if __name__ == '__main__':
              start()
    get:
      description: "For more context on daily archiving, the configurations your S3\
        \ bucket must have, \nand handling rate limits consult [this section's introduction](#tag/Backup-Your-Log-Data-To-S3).\n"
      operationId: getArchivingS3Setup
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/S3ArchivingSetup/value
              schema:
                $ref: '#/components/schemas/s3_archiving_setup'
          description: Daily Archiving Settings in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
        "401":
          description: Unauthorized.
        "404":
          description: Daily Archiving is Not Enabled.
        "415":
          description: Unsupported Media Type.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: View Daily Archiving Settings
      tags:
      - Backup Your Log Data To S3
      x-code-samples:
      - lang: Python
        label: Python3
        source: |
          import json
          import requests

          API_KEY = 'YOUR API KEY GOES HERE'
          REQUEST_URL = 'https://us.rest.logs.insight.rapid7.com/management/archiving/s3setup'

          def handle_response(response):
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))

          def make_request():
              headers = {'x-api-key': API_KEY}
              response = requests.get(REQUEST_URL, headers=headers)
              return response

          def start():
              response = make_request()
              handle_response(response)

          if __name__ == '__main__':
              start()
    patch:
      description: "For more context on daily archiving, the configurations your S3\
        \ bucket must have, \nand handling rate limits consult [this section's introduction](#tag/Backup-Your-Log-Data-To-S3).\n"
      operationId: patchArchivingS3Setup
      requestBody:
        content:
          application/json:
            example:
              $ref: ../../insightops-examples.yml#/components/examples/CreateS3ArchivingSetup/value
            schema:
              $ref: '#/components/schemas/patch_s3_archiving_setup'
        required: true
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/S3ArchivingSetup/value
              schema:
                $ref: '#/components/schemas/s3_archiving_setup'
          description: Modified Daily Archiving Settings in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
        "400":
          description: Daily Archiving Settings are Invalid.
        "401":
          description: Unauthorized.
        "403":
          description: The S3 Bucket Failed Validation.
        "404":
          description: Daily Archiving is Not Enabled.
        "415":
          description: Unsupported Media Type. Non-JSON Request Body Given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Modify Daily Archiving Settings
      tags:
      - Backup Your Log Data To S3
      x-code-samples:
      - lang: Python
        label: Python3
        source: |
          import json
          import requests

          API_KEY = 'YOUR API KEY GOES HERE'
          REQUEST_URL = 'https://us.rest.logs.insight.rapid7.com/management/archiving/s3setup'

          data = {'s3setup':{'bucket_name':'my-bucket','enabled':False,'compression':'GZIP'}}

          def handle_response(response):
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))

          def make_request():
              headers = {'Content-type': 'application/json', 'x-api-key': API_KEY}
              body = json.dumps(data, separators=(',', ':'))
              response = requests.patch(REQUEST_URL, data=body, headers=headers)
              return response

          def start():
              response = make_request()
              handle_response(response)

          if __name__ == '__main__':
              start()
    post:
      description: "For more context on daily archiving, the configurations your S3\
        \ bucket must have, \nand handling rate limits consult [this section's introduction](#tag/Backup-Your-Log-Data-To-S3).\n"
      operationId: postArchivingS3Setup
      requestBody:
        content:
          application/json:
            example:
              $ref: ../../insightops-examples.yml#/components/examples/CreateS3ArchivingSetup/value
            schema:
              $ref: '#/components/schemas/create_s3_archiving_setup'
        required: true
      responses:
        "201":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/S3ArchivingSetup/value
              schema:
                $ref: '#/components/schemas/s3_archiving_setup'
          description: Daily Archiving Enabled.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
        "400":
          description: Daily Archiving Settings Invalid.
        "401":
          description: Unauthorized.
        "403":
          description: The S3 Bucket Failed Validation.
        "415":
          description: Unsupported Media Type. Non-JSON Request Body Given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Enable Daily Archiving
      tags:
      - Backup Your Log Data To S3
      x-code-samples:
      - lang: Python
        label: Python3
        source: |
          import json
          import requests

          API_KEY = 'YOUR API KEY GOES HERE'
          REQUEST_URL = 'https://us.rest.logs.insight.rapid7.com/management/archiving/s3setup'

          data = {'s3setup':{'bucket_name':'my-bucket','enabled':False,'compression':'GZIP'}}

          def handle_response(response):
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))

          def make_request():
              headers = {'Content-type': 'application/json', 'x-api-key': API_KEY}
              body = json.dumps(data, separators=(',', ':'))
              response = requests.post(REQUEST_URL, data=body, headers=headers)
              return response

          def start():
              response = make_request()
              handle_response(response)

          if __name__ == '__main__':
              start()
    put:
      description: "For more context on daily archiving, the configurations your S3\
        \ bucket must have, \nand handling rate limits consult [this section's introduction](#tag/Backup-Your-Log-Data-To-S3).\n"
      operationId: putArchivingS3Setup
      requestBody:
        content:
          application/json:
            example:
              $ref: ../../insightops-examples.yml#/components/examples/CreateS3ArchivingSetup/value
            schema:
              $ref: '#/components/schemas/create_s3_archiving_setup'
        required: true
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/S3ArchivingSetup/value
              schema:
                $ref: '#/components/schemas/s3_archiving_setup'
          description: New Daily Archiving Settings in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
        "400":
          description: Daily Archiving Settings are Invalid.
        "401":
          description: Unauthorized.
        "403":
          description: The S3 Bucket Failed Validation.
        "404":
          description: Daily Archiving is Not Enabled
        "415":
          description: Unsupported Media Type. Non-JSON Request Body Given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Replace Daily Archiving Settings
      tags:
      - Backup Your Log Data To S3
      x-code-samples:
      - lang: Python
        label: Python3
        source: |
          import json
          import requests

          API_KEY = 'YOUR API KEY GOES HERE'
          REQUEST_URL = 'https://us.rest.logs.insight.rapid7.com/management/archiving/s3setup'

          data = {'s3setup':{'bucket_name':'my-bucket','enabled':False,'compression':'GZIP'}}

          def handle_response(response):
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))

          def make_request():
              headers = {'Content-type': 'application/json', 'x-api-key': API_KEY}
              body = json.dumps(data, separators=(',', ':'))
              response = requests.put(REQUEST_URL, data=body, headers=headers)
              return response

          def start():
              response = make_request()
              handle_response(response)

          if __name__ == '__main__':
              start()
  /usage/organizations:
    get:
      description: Returns the total number bytes written to every log in your account
        for the specified time range (including logs that may have been deleted since
        that time). There is no restriction on the timerange.
      operationId: getOrganizationsUsage
      parameters:
      - description: |
          \
          The start of the time range as a string in the format "YYYY-MM-DD".
        example: 2023-09-14
        in: query
        name: from
        required: true
        schema:
          type: string
      - description: |
          \
          The end of the time range as a string in the format "YYYY-MM-DD".
        example: 2023-09-20
        in: query
        name: to
        required: true
        schema:
          type: string
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/accounts_usage/value
              schema:
                $ref: '#/components/schemas/accounts_usage_response'
          description: Data Size in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit-Usage-API'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
        "401":
          description: Unauthorized.
        "404":
          description: Data Not Found.
        "415":
          description: Unsupported Media Type.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit-Usage-API'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Total Data Size Across All Logs
      tags:
      - Explore The Size of Your Log Data
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          FROM_DATE = '2023-06-19'
          TO_DATE = '2023-06-26'


          def retrieve_total_data_size(s: Session) -> None:
              response = s.get(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com"
                               f"/usage/organizations",
                               headers={'x-api-key': API_KEY},
                               params={'from': FROM_DATE, 'to': TO_DATE})
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              retrieve_total_data_size(session)
  /usage/organizations/logs:
    get:
      description: Returns the total number bytes written to each log in your account
        for each day in the specified time range. The timerange must be within the
        last 30 days.
      operationId: getOrganizationsLogsUsage
      parameters:
      - description: |
          \
          The start of the time range as a string in the format "YYYY-MM-DD".
        example: 2023-09-14
        in: query
        name: from
        required: true
        schema:
          type: string
      - description: |
          \
          The end of the time range as a string in the format "YYYY-MM-DD".
        example: 2023-09-20
        in: query
        name: to
        required: true
        schema:
          type: string
      - description: |
          \
          An alternative to the `from` and `to` query parameters. Supported values:
          * `yesterday`
          * `today`
          * `last x timeunits` where x is the number of time unit back from the current server time. Supported time units (case insensitive):
              - min(s) or minute(s)
              - hr(s) or hour(s)
              - day(s)
              - week(s)
              - month(s)
              - year(s)

          If `time_range` is used, then the `from` and `to` query parameters must not be used.
        example: last 5 minutes
        in: query
        name: time_range
        required: false
        schema:
          type: string
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/logs_usage/value
              schema:
                $ref: '#/components/schemas/logs_usage_response'
          description: Data Size in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit-Usage-API'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
        "401":
          description: Unauthorized.
        "404":
          description: Data Not Found.
        "415":
          description: Unsupported Media Type.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit-Usage-API'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Data Size Broken Down By Log
      tags:
      - Explore The Size of Your Log Data
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          FROM_DATE = '2023-06-19'
          TO_DATE = '2023-06-26'


          def retrieve_total_data_size(s: Session) -> None:
              response = s.get(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com"
                               f"/usage/organizations/logs",
                               headers={'x-api-key': API_KEY},
                               params={'from': FROM_DATE, 'to': TO_DATE})
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              retrieve_total_data_size(session)
  /usage/organizations/logs/{log_key}:
    get:
      description: Returns the total number bytes written to the specified log for
        each day in the specified time range. The timerange must be within the last
        30 days.
      operationId: getOrganizationsLogUsage
      parameters:
      - description: |
          \
          The key of the log to be queried.
        example: 565c1b7b-c08b-4c87-a42a-ab08bad56071
        in: path
        name: log key
        required: true
        schema:
          type: string
      - description: |
          \
          The start of the time range as a string in the format "YYYY-MM-DD".
        example: 2023-09-14
        in: query
        name: from
        required: true
        schema:
          type: string
      - description: |
          \
          The end of the time range as a string in the format "YYYY-MM-DD".
        example: 2023-09-20
        in: query
        name: to
        required: true
        schema:
          type: string
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/log_usage/value
              schema:
                $ref: '#/components/schemas/log_usage_response'
          description: Data Size in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1usage~1organizations~1logs~1{log_key}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1usage~1organizations~1logs~1{log_key}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1usage~1organizations~1logs~1{log_key}"
        "401":
          description: Unauthorized.
        "404":
          description: Data Not Found.
        "415":
          description: Unsupported Media Type.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1usage~1organizations~1logs~1{log_key}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1usage~1organizations~1logs~1{log_key}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1usage~1organizations~1logs~1{log_key}"
            Retry-After:
              $ref: "#/components/headers/~1usage~1organizations~1logs~1{log_key}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Data Size For a Specific Log
      tags:
      - Explore The Size of Your Log Data
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          FROM_DATE = '2023-06-19'
          TO_DATE = '2023-06-26'
          LOG_ID = 'YOUR LOG ID HERE'


          def retrieve_total_data_size(s: Session) -> None:
              response = s.get(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com"
                               f"/usage/organizations/logs/{LOG_ID}",
                               headers={'x-api-key': API_KEY},
                               params={'from': FROM_DATE, 'to': TO_DATE})
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              retrieve_total_data_size(session)
  /download/logs:
    get:
      description: |
        Returns the raw log entries in the response body. Each log entry is on a new line.
        Data can be downloaded from a maximum of 10 Logs per download request.
      operationId: getDownloadLogs
      parameters:
      - description: |
          \
          The UUIDs of the logs separated by colons ":" or semicolons ";". For example "UUID1:UUID2:UUID3" or "UUID1;UUID2;UUID3".
        example: aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb:cccccccc-cccc-cccc-cccc-cccccccccccc
        in: path
        name: ids
        required: true
        schema:
          type: string
      - description: |
          \
          The start of the time range for the query, as a UNIX timestamp in milliseconds.
        example: 1450557004000
        in: query
        name: from
        required: true
        schema:
          type: integer
      - description: |
          \
          The end of the time range for the query, as a UNIX timestamp in milliseconds.
        example: 1460557604000
        in: query
        name: to
        required: true
        schema:
          type: integer
      - description: |
          \
          An alternative to the `from` and `to` query parameters. Supported values:
          * `yesterday`
          * `today`
          * `last x timeunits` where x is the number of time unit back from the current server time. Supported time units (case insensitive):
              - min(s) or minute(s)
              - hr(s) or hour(s)
              - day(s)
              - week(s)
              - month(s)
              - year(s)

          If `time_range` is used, then the `from` and `to` query parameters must not be used.
        example: last 5 minutes
        in: query
        name: time_range
        required: false
        schema:
          type: string
      - description: |
          \
          A valid LEQL query to run against the log.
          If omitted, the query retrieves all log entries in the specified time range.
        example: where(foo=bar)
        in: query
        name: query
        required: false
        schema:
          type: string
      - description: |
          \
          The maximum, and default, number of log entries to download is 500,000,000 log entries.
          You can specify this parameter to limit the number of log entries in the download.
        example: 10
        in: query
        name: limit
        required: false
        schema:
          type: integer
      responses:
        "200":
          content:
            text/plain:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/DownloadLogsResponse/value
          description: Log Entries are Returned.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1download~1logs~1{ids}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1download~1logs~1{ids}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1download~1logs~1{ids}"
        "400":
          description: Invalid Request.
        "401":
          description: Unauthorized.
        "404":
          description: Log Not Found.
        "415":
          description: Unsupported Media Type.
        "429":
          content:
            text/plain:
              example: API rate limit exceeded
              schema:
                type: string
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1download~1logs~1{ids}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1download~1logs~1{ids}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1download~1logs~1{ids}"
            Retry-After:
              $ref: "#/components/headers/~1download~1logs~1{ids}"
        "500":
          description: Internal Server Error.
        "503":
          description: Service Unavailable.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Download Log Data
      tags:
      - Download Log Data
      x-code-samples:
      - lang: Shell
        label: curl
        source: |
          curl -H 'x-api-key: 00000000-0000-0000-0000-000000000000' \
          -G \
          https://us.rest.logs.insight.rapid7.com/download/logs/aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb:cccccccc-cccc-cccc-cccc-cccccccccccc?time_range=last 1 hour
  /exports:
    get:
      description: |
        For more context on export jobs, as well as instructions on handling rate limits consult [this section's introduction](#tag/Export-Log-Data-To-CSV).
      operationId: getExportJobs
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/ExportJobsResponse/value
              schema:
                $ref: '#/components/schemas/export_jobs_response'
          description: Export Jobs are Returned.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit-Export-To-CSV'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
        "400":
          description: Invalid Request.
        "401":
          description: Unauthorized.
        "415":
          description: Unsupported Media Type.
        "429":
          content:
            text/plain:
              example: API rate limit exceeded
              schema:
                type: string
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit-Export-To-CSV'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
        "503":
          description: Service Unavailable.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Retrieve All Export Jobs
      tags:
      - Export Log Data To CSV
      x-code-samples:
      - lang: Shell
        label: curl
        source: |
          curl -H 'x-api-key: 00000000-0000-0000-0000-000000000000' \
          -G \
          https://us.rest.logs.insight.rapid7.com/exports
  /exports/{id}:
    delete:
      description: |
        Removes the export job with the specified ID. Only export jobs which have failed or completed can be removed.

        For more context on export jobs, as well as instructions on handling rate limits consult [this section's introduction](#tag/Export-Log-Data-To-CSV).
      operationId: deleteExportJob
      parameters:
      - description: |
          \
          The UUID of the export job.
        example: 00000000-0000-0000-0000-000000000000
        in: query
        name: id
        required: true
        schema:
          type: string
      responses:
        "204":
          description: Export Job Deleted Successfully.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1exports~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1exports~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1exports~1{id}"
        "400":
          description: Invalid Request.
        "401":
          description: Unauthorized.
        "404":
          description: Export Job Not Found.
        "415":
          description: Unsupported Media Type.
        "429":
          content:
            text/plain:
              example: API rate limit exceeded
              schema:
                type: string
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1exports~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1exports~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1exports~1{id}"
            Retry-After:
              $ref: "#/components/headers/~1exports~1{id}"
        "500":
          description: Internal Server Error.
        "503":
          description: Service Unavailable.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Delete An Export Job By Id
      tags:
      - Export Log Data To CSV
      x-code-samples:
      - lang: Shell
        label: curl
        source: |
          curl -X DELETE \
          -H 'x-api-key: 00000000-0000-0000-0000-000000000000' \
          https://us.rest.logs.insight.rapid7.com/exports/aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa
    get:
      description: |
        For more context on export jobs, as well as instructions on handling rate limits consult [this section's introduction](#tag/Export-Log-Data-To-CSV).
      operationId: getExportJob
      parameters:
      - description: |
          \
          The UUID of the export job.
        example: 00000000-0000-0000-0000-000000000000
        in: query
        name: id
        required: true
        schema:
          type: string
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/ExportJobResponse/value
              schema:
                $ref: '#/components/schemas/export_job_response'
          description: Export Job is Returned.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1exports~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1exports~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1exports~1{id}"
        "400":
          description: Invalid Request.
        "401":
          description: Unauthorized.
        "404":
          description: Export Job Not Found.
        "415":
          description: Unsupported Media Type.
        "429":
          content:
            text/plain:
              example: API rate limit exceeded
              schema:
                type: string
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1exports~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1exports~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1exports~1{id}"
            Retry-After:
              $ref: "#/components/headers/~1exports~1{id}"
        "500":
          description: Internal Server Error.
        "503":
          description: Service Unavailable.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Retrieve An Export Job By Id
      tags:
      - Export Log Data To CSV
      x-code-samples:
      - lang: Shell
        label: curl
        source: |
          curl -H 'x-api-key: 00000000-0000-0000-0000-000000000000' \
          -G \
          https://us.rest.logs.insight.rapid7.com/exports/aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa
  /management/labels:
    get:
      description: "For more context on basic detection rules, notification, notification\
        \ targets, and labels, \nas well as instructions on handling rate limits,\
        \ consult [this section's introduction](#tag/Basic-Detection-Rules).\n"
      operationId: getLabels
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/LabelResponse/value
              schema:
                $ref: '#/components/schemas/labels_response'
          description: Labels in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "400":
          description: Invalid Request.
        "401":
          description: Unauthorized.
        "415":
          description: Unsupported Media Type.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
        "503":
          description: Service Unavailable.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: List all Labels
      tags:
      - Basic Detection Rules
      x-code-samples:
      - lang: Shell
        label: curl
        source: |
          curl -H 'x-api-key: 00000000-0000-0000-0000-000000000000' \
          -G \
          https://us.rest.logs.insight.rapid7.com/management/labels/00000000-0000-0000-0000-000000000000
      - lang: Python3
        label: Python3.6+
        source: |
          import requests

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region


          def handle_response(response):
            print(response.json())
            print(response.status_code)


          def make_request():
            headers = {'x-api-key': API_KEY}
            url = f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/management/labels'
            request = requests.get(url, headers=headers)
            return request


          def start():
            request = make_request()
            handle_response(request)


          if __name__ == '__main__':
            start()
    post:
      description: "For more context on basic detection rules, notification, notification\
        \ targets, and labels, \nas well as instructions on handling rate limits,\
        \ consult [this section's introduction](#tag/Basic-Detection-Rules).\n"
      operationId: postLabels
      requestBody:
        content:
          application/json:
            example:
              $ref: ../../insightops-examples.yml#/components/examples/CreateOrPostLabel/value
            schema:
              $ref: '#/components/schemas/create_label'
        required: true
      responses:
        "201":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/LabelResponse/value
              schema:
                $ref: '#/components/schemas/label_response'
          description: Label Created. ID in Response.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "400":
          description: Invalid Label Specified in the Request Body.
        "401":
          description: Unauthorized.
        "403":
          description: Forbidden.
        "415":
          description: Non-JSON request body was given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Create a Label
      tags:
      - Basic Detection Rules
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          import requests

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          BODY = {
          "label":
            {"sn": 12345,
             "name": "My Label",
             "color": "ff0000",
            }
          }


          def create_label():
            url = f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/management/labels'
            headers = {
              'x-api-key': API_KEY,
              "Content-Type": "application/json"
            }
            r = requests.post(url, data=json.dumps(BODY), headers=headers)
            print(r.status_code, r.content)


          def start():
            create_label()


          if __name__ == '__main__':
            start()
  /management/labels/{label_id}:
    delete:
      description: "For more context on basic detection rules, notification, notification\
        \ targets, and labels, \nas well as instructions on handling rate limits,\
        \ consult [this section's introduction](#tag/Basic-Detection-Rules).\n"
      operationId: deleteLabelById
      parameters:
      - description: |
          \
          The ID of the label to be queried.
        example: 4a8869fa-0843-4edd-85f5-bf7d6b80d6c5
        in: path
        name: label_id
        required: true
        schema:
          type: string
      responses:
        "200":
          description: Label Successfully Deleted.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
        "401":
          description: Unauthorized.
        "404":
          description: Label Not Found.
        "415":
          description: Non-JSON request body was given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Delete a Label
      tags:
      - Basic Detection Rules
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import requests

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          LABEL_ID = '7882d150-4027-4914-8d4e-744c82fbda38'


          def handle_response(response):
            if response.status_code == 200:
              print("Label successfully deleted")
            else:
              print(response.status_code)


          def make_request():
            headers = {'x-api-key': API_KEY}
            url = f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/management/labels/{LABEL_ID}'
            return requests.delete(url, headers=headers)


          def delete_label():
            response = make_request()
            handle_response(response)


          if __name__ == '__main__':
            delete_label()
    get:
      description: "For more context on basic detection rules, notification, notification\
        \ targets, and labels, \nas well as instructions on handling rate limits,\
        \ consult [this section's introduction](#tag/Basic-Detection-Rules).\n"
      operationId: getLabelById
      parameters:
      - description: |
          \
          The ID of the label to be queried.
        example: 4a8869fa-0843-4edd-85f5-bf7d6b80d6c5
        in: path
        name: label_id
        required: true
        schema:
          type: string
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/LabelById/value
              schema:
                $ref: '#/components/schemas/label_response'
          description: Label in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
        "401":
          description: Unauthorized.
        "404":
          description: Label Not Found.
        "415":
          description: Request body is not in JSON format.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Retrieve a Label
      tags:
      - Basic Detection Rules
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: "import requests\nimport json\n  \nAPI_KEY = 'YOUR API KEY'\nDATA_STORAGE_REGION\
          \ = 'eu'  # Swap for your region\nLABEL_ID = '00000000-0000-0000-0000-000000000004'\n\
          \n\ndef handle_response(response):\n  if response.status_code == 200:\n\
          \    print(json.dumps(response.json(), indent=4))\n  else:\n    print(response.status_code)\n\
          \n\ndef make_request():\n  url = f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/management/labels/{LABEL_ID}'\n\
          \  return requests.get(url, headers={'x-api-key': API_KEY})\n\n\ndef get_label():\n\
          \  req = make_request()\n  handle_response(req)\n\n\nif __name__ == '__main__':\n\
          \  get_label()\n"
    patch:
      description: "For more context on basic detection rules, notification, notification\
        \ targets, and labels, \nas well as instructions on handling rate limits,\
        \ consult [this section's introduction](#tag/Basic-Detection-Rules).\n"
      operationId: patchLabelById
      parameters:
      - description: |
          \
          The ID of the label to be queried.
        example: 4a8869fa-0843-4edd-85f5-bf7d6b80d6c5
        in: path
        name: label_id
        required: true
        schema:
          type: string
      requestBody:
        content:
          application/json:
            example:
              $ref: ../../insightops-examples.yml#/components/examples/CreateOrPostLabel/value
            schema:
              $ref: '#/components/schemas/patch_label'
        required: true
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/LabelById/value
              schema:
                $ref: '#/components/schemas/label_response'
          description: Success. Updated Label in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
        "400":
          description: Invalid Label Specified in Request Body.
        "401":
          description: Unauthorized.
        "403":
          description: Forbidden.
        "404":
          description: Label Not Found.
        "415":
          description: Non-JSON request body was given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Update a Label
      tags:
      - Basic Detection Rules
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          import requests

          API_KEY = 'YOUR API KEY'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          LABEL_ID = '8c67f5a3-bae5-4a25-953c-8edb0bce4c9c'
          BODY = {
          "label": {
            "name": "My Partially Updated Label"
              }
            }


          def patch_label():
            url = f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/management/labels/{LABEL_ID}'
            headers = {
            'x-api-key': API_KEY,
            "Content-Type": "application/json"
              }
            r = requests.patch(url, data=json.dumps(BODY), headers=headers)
            print(r.status_code, r.content)


          if __name__ == '__main__':
            patch_label()
    put:
      description: "For more context on basic detection rules, notification, notification\
        \ targets, and labels, \nas well as instructions on handling rate limits,\
        \ consult [this section's introduction](#tag/Basic-Detection-Rules).\n"
      operationId: putLabelById
      parameters:
      - description: |
          \
          The ID of the label to be queried.
        example: 4a8869fa-0843-4edd-85f5-bf7d6b80d6c5
        in: path
        name: label_id
        required: true
        schema:
          type: string
      requestBody:
        content:
          application/json:
            example:
              $ref: ../../insightops-examples.yml#/components/examples/CreateOrPostLabel/value
            schema:
              $ref: '#/components/schemas/put_label'
        required: true
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/LabelById/value
              schema:
                $ref: '#/components/schemas/label_response'
          description: Success. Modified Label in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
        "400":
          description: Invalid Label Specified in Request Body.
        "401":
          description: Unauthorized.
        "403":
          description: Forbidden.
        "404":
          description: Label Not Found.
        "415":
          description: Non-JSON request body was given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
            Retry-After:
              $ref: "#/components/headers/~1management~1labels~1{label_id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Write or Above
      summary: Replace a Label
      tags:
      - Basic Detection Rules
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          import requests

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region
          LABEL_ID = 'YOUR LABEL ID HERE'
          BODY = {
          "label": {
            "name": "My Replaced Label",
            "color": "ff0000"
              }
            }


          def put_label():
            url = f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/management/labels/{LABEL_ID}'
            headers = {
            'x-api-key': API_KEY,
            "Content-Type": "application/json"
             }
            r = requests.put(url, data=json.dumps(BODY), headers=headers)
            print(r.status_code, r.content)


          if __name__ == '__main__':
            put_label()
  /search-stats:
    get:
      description: "Retrieve information about your queries such as: \n* Time taken\
        \ to complete the query.\n* Amount of data searched.\n* Number of log lines\
        \ in your data which matched the query.\n* LEQL statement used for the query.\n\
        \nFor context and information about Log Search queries, consult this [this\
        \ section's introduction](#tag/Query-Log-Data).\n"
      operationId: getSearchStats
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/search-stats/value
              schema:
                $ref: '#/components/schemas/search-stats'
          description: Statistics in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit-Search-Stats'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
        "400":
          description: Invalid Request.
        "401":
          description: Unauthorized.
        "415":
          description: Non-JSON Request Body Given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit-Search-Stats'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: View Statistics On Past Queries
      tags:
      - Query Log Data
      x-code-samples:
      - lang: Python
        label: Python3.10
        source: |
          import requests
          import json

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region

          def handle_response(response):
            if response.status_code == 200:
              print(json.dumps(response.json(), indent=4))
            else:
              print(response.status_code)

          def make_request():
            headers = {'x-api-key': API_KEY}
            url = f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/search-stats'
            return requests.get(url, headers=headers)

          def get_search_stats():
            response = make_request()
            handle_response(response

          if __name__ == '__main__':
            get_search_stats()
  /audit/query:
    get:
      description: |
        This endpoint is available as a convenient way to search for audit logs. It operates the same way as the [/query](#operation/getQueryEndpoints) endpoints, which can be used to search for both audit logs and regular logs.
      operationId: auditGetQueryEndpoints
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/ListAuditEndpoints/value
              schema:
                $ref: '#/components/schemas/ListEndpointsResponse'
          description: Endpoints in Response Body.
      summary: List All Endpoints
      tags:
      - Audit API
  /audit/query/{id}:
    get:
      description: "This endpoint is available as a convenient way to search for audit\
        \ logs. It operates the same way as the [/query/{id}](#operation/pollQuery)\
        \ endpoints, which can be used to search for both audit logs and regular logs.\
        \ \n\nLinks must be polled at least once **every 20 seconds** to avoid expiration.\
        \ Be cautious of polling too frequently as that can lead to rate limiting.\n"
      operationId: auditPollQuery
      parameters:
      - description: |
          \
          The continuation id generated when the query started.
        example: '0bnc17f4-bbbe-46b1-a843-163c074bd1ad:0:c5be1c97f925ff772263661182974903b83ef305:50:f89f7d5cbeb270abeb18b1c28262cee66047d21d:'
        in: path
        name: id
        required: true
        schema:
          type: string
      - description: |
          \
          An alternative to the `from` and `to` query parameters. Supported values:
          * `yesterday`
          * `today`
          * `last x timeunits` where x is the number of time unit back from the current server time. Supported time units (case insensitive):
              - min(s) or minute(s)
              - hr(s) or hour(s)
              - day(s)
              - week(s)
              - month(s)
              - year(s)

          If `time_range` is used, then the `from` and `to` query parameters must not be used.
        example: last 5 minutes
        in: query
        name: time_range
        required: false
        schema:
          type: string
      responses:
        "200":
          content:
            application/json:
              examples:
                EventsContinue:
                  $ref: "#/components/examples/~1audit~1query~1{id}"
                EventsResponseSimple:
                  $ref: "#/components/examples/~1audit~1query~1{id}"
                EventsResponsePagination:
                  $ref: "#/components/examples/~1audit~1query~1{id}"
                StatsContinueInitial:
                  $ref: "#/components/examples/~1audit~1query~1{id}"
                StatisticalResponseSimple:
                  $ref: "#/components/examples/~1audit~1query~1{id}"
                StatisticalResponseTimeSeriesMultiGroupBy:
                  $ref: "#/components/examples/~1audit~1query~1{id}"
              schema:
                $ref: '#/components/schemas/pollQuery_200_response'
          description: Successful poll. Query is either done or on-going and response
            body may contain partial or full query results.
          headers:
            x-beyond-retention:
              $ref: "#/components/headers/~1audit~1query~1{id}"
            x-beyond-retention-message:
              $ref: "#/components/headers/~1audit~1query~1{id}"
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1audit~1query~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1audit~1query~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1audit~1query~1{id}"
        "400":
          description: Invalid Continuation ID.
        "401":
          description: Unauthorized.
        "404":
          description: Query Not Found (Continuation ID may have expired).
        "415":
          description: "Non-JSON request body was given (Note, the endpoint does not\
            \ take a request body)."
        "429":
          content:
            text/plain:
              example: API rate limit exceeded
              schema:
                type: string
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1audit~1query~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1audit~1query~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1audit~1query~1{id}"
            Retry-After:
              $ref: "#/components/headers/~1audit~1query~1{id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Poll a Query In Progress
      tags:
      - Audit API
  /audit/logs/{log_keys}:
    get:
      description: |
        This endpoint is available as a convenient way to search for audit logs. It operates the same way as the [/query/logs/{log_keys}](#operation/getQueryLogs) endpoints, which can be used to search for both audit logs and regular logs.
      operationId: auditGetQueryLogs
      parameters:
      - description: |
          \
          The key of the log to be queried.

          Supplying multiple ':' separated log keys is deprecated;
          users should instead 'POST' the query as a JSON payload to [/query/logs](#operation/postQueryLogs).
        example: /query/logs/565c1b7b-c08b-4c87-a42a-ab08bad56071
        in: path
        name: log_keys
        required: true
        schema:
          type: string
      - description: |
          \
          A valid LEQL query to run against the log.
          If omitted, the query retrieves all log entries in the specified time range.
        example: where(foo=bar)
        in: query
        name: query
        required: false
        schema:
          type: string
      - description: |
          \
          The start of the time range for the query, as a UNIX timestamp in milliseconds.
        example: 1450557004000
        in: query
        name: from
        required: true
        schema:
          type: integer
      - description: |
          \
          The end of the time range for the query, as a UNIX timestamp in milliseconds.
        example: 1460557604000
        in: query
        name: to
        required: true
        schema:
          type: integer
      - description: |
          \
          An alternative to the `from` and `to` query parameters. Supported values:
          * `yesterday`
          * `today`
          * `last x timeunits` where x is the number of time unit back from the current server time. Supported time units (case insensitive):
              - min(s) or minute(s)
              - hr(s) or hour(s)
              - day(s)
              - week(s)
              - month(s)
              - year(s)

          If `time_range` is used, then the `from` and `to` query parameters must not be used.
        example: last 5 minutes
        in: query
        name: time_range
        required: false
        schema:
          type: string
      - description: |
          \
          Only entries which have a label with this UUID will be returned.
          This only works with non-statistical queries (i.e. no 'groupby' or 'calculate' clauses).
        example: 00000000-0000-0000-0000-000000000001
        in: query
        name: label
        required: false
        schema:
          type: string
      - description: |
          \
          A set of ':' separated label UUIDs. Only entries which have a label matching one of these UUIDs will be returned.
          This only works with non-statistical queries (i.e. no 'groupby' or 'calculate' clauses).
          Takes precedence over the 'label' parameter.
        example: 00000000-0000-0000-0000-000000000001:21b21bb8-8869-4e2c-98df-684892e4e112
        in: query
        name: labels
        required: false
        schema:
          type: string
      - description: |
          \
          Number of log entries to return per page, up to 500(the maximum allowed).
        example: 100
        in: query
        name: per_page
        required: false
        schema:
          default: 50
          type: integer
      - description: |
          \
          If included, the query results will be exported to the given format.

          * Currently only `csv` is supported.
          * This parameter is only for non-statistical search queries (i.e. no 'calculate' and/or 'groupby' clauses).
          * Results are limited to the first 1 million log entries, and only one export job may run per account at a time.

          The response will be a 202, and the response body will contain a link for polling the export job (on the **/exports/{id}** endpoint).
        example: csv
        in: query
        name: export_format
        required: false
        schema:
          type: string
      - description: |
          \
          When set to true, the `events` object that is returned will additionally contain information about
          all the key-value pairs in each returned log entry.
        example: true
        in: query
        name: kvp_info
        required: false
        schema:
          type: boolean
      - description: |
          \
          When set to `true`, the query returns the most recent events first. When set to `false`, it returns the oldest events first.
        example: true
        in: query
        name: most_recent_first
        required: false
        schema:
          default: false
          type: boolean
      - description: |
          \
          If this query parameter is included, the query results will additionally include all log entries received in the
          `from` millisecond which have sequence numbers larger than the one specified.

          Sequence numbers are identifiers used to distinguish between log entries received in the same millisecond.
          If a log entry was split up into several log entries during ingestion, then those chunks are ordered by sequence number.
        in: query
        name: sequence_number
        required: false
        schema:
          type: integer
      responses:
        "200":
          content:
            application/json:
              examples:
                EventsResponseSimple:
                  $ref: "#/components/examples/~1audit~1query~1logs~1{log_keys}"
                EventsResponsePagination:
                  $ref: "#/components/examples/~1audit~1query~1logs~1{log_keys}"
                StatisticalResponseSimple:
                  $ref: "#/components/examples/~1audit~1query~1logs~1{log_keys}"
                StatisticalResponseTimeSeriesMultiGroupBy:
                  $ref: "#/components/examples/~1audit~1query~1logs~1{log_keys}"
              schema:
                $ref: '#/components/schemas/getQueryLogs_200_response'
          description: Results in Response Body.
          headers:
            x-beyond-retention:
              $ref: "#/components/headers/~1audit~1query~1logs~1{log_keys}"
            x-beyond-retention-message:
              $ref: "#/components/headers/~1audit~1query~1logs~1{log_keys}"
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1audit~1query~1logs~1{log_keys}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1audit~1query~1logs~1{log_keys}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1audit~1query~1logs~1{log_keys}"
        "202":
          content:
            application/json:
              examples:
                EventsContinue:
                  $ref: "#/components/examples/~1audit~1query~1logs~1{log_keys}"
                EventsContinueExportCSV:
                  $ref: "#/components/examples/~1audit~1query~1logs~1{log_keys}"
                StatsContinueInitial:
                  $ref: "#/components/examples/~1audit~1query~1logs~1{log_keys}"
              schema:
                $ref: '#/components/schemas/getQueryLogs_202_response'
          description: Query in Progress. Links in Response Body.
          headers:
            x-beyond-retention:
              $ref: "#/components/headers/~1audit~1query~1logs~1{log_keys}"
            x-beyond-retention-message:
              $ref: "#/components/headers/~1audit~1query~1logs~1{log_keys}"
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1audit~1query~1logs~1{log_keys}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1audit~1query~1logs~1{log_keys}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1audit~1query~1logs~1{log_keys}"
        "400":
          description: Invalid Query Request.
        "401":
          description: Unauthorized.
        "404":
          description: Log Not Found.
        "415":
          description: "Non-JSON request body was given (Note, the endpoint takes\
            \ a request body)."
        "429":
          content:
            text/plain:
              example: API rate limit exceeded
              schema:
                type: string
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1audit~1query~1logs~1{log_keys}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1audit~1query~1logs~1{log_keys}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1audit~1query~1logs~1{log_keys}"
            Retry-After:
              $ref: "#/components/headers/~1audit~1query~1logs~1{log_keys}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Query Individual Logs Using LEQL
      tags:
      - Audit API
  /audit/exports:
    get:
      description: |
        This endpoint is available as a convenient way to search for audit logs. It operates the same way as the [/exports](#operation/getExportJobs) endpoints, which can be used to search for both audit logs and regular logs.
      operationId: auditGetExportJobs
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/ExportJobsResponse/value
              schema:
                $ref: '#/components/schemas/export_jobs_response'
          description: Export Jobs are Returned.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit-Export-To-CSV'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
        "400":
          description: Invalid Request.
        "401":
          description: Unauthorized.
        "415":
          description: Unsupported Media Type.
        "429":
          content:
            text/plain:
              example: API rate limit exceeded
              schema:
                type: string
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit-Export-To-CSV'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
        "503":
          description: Service Unavailable.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Retrieve All Export Jobs
      tags:
      - Audit API
  /audit/exports/{id}:
    get:
      description: |
        This endpoint is available as a convenient way to search for audit logs. It operates the same way as the [/exports/{id}](#operation/getExportJob) endpoints, which can be used to search for both audit logs and regular logs.
      operationId: auditGetExportJob
      parameters:
      - description: |
          \
          The UUID of the export job.
        example: 00000000-0000-0000-0000-000000000000
        in: query
        name: id
        required: true
        schema:
          type: string
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/ExportJobResponse/value
              schema:
                $ref: '#/components/schemas/export_job_response'
          description: Export Job is Returned.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1audit~1exports~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1audit~1exports~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1audit~1exports~1{id}"
        "400":
          description: Invalid Request.
        "401":
          description: Unauthorized.
        "404":
          description: Export Job Not Found.
        "415":
          description: Unsupported Media Type.
        "429":
          content:
            text/plain:
              example: API rate limit exceeded
              schema:
                type: string
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1audit~1exports~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1audit~1exports~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1audit~1exports~1{id}"
            Retry-After:
              $ref: "#/components/headers/~1audit~1exports~1{id}"
        "500":
          description: Internal Server Error.
        "503":
          description: Service Unavailable.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Retrieve An Export Job By Id
      tags:
      - Audit API
  /audit/query/logs:
    post:
      description: |
        This endpoint is available as a convenient way to search for audit logs. It operates the same way as the [/query/logs](#operation/postQueryLogs) endpoints, which can be used to search for both audit logs and regular logs.
      operationId: auditPostQueryLogs
      parameters:
      - description: |
          \
          Number of log entries to return per page, up to 500(the maximum allowed).
        example: 100
        in: query
        name: per_page
        required: false
        schema:
          default: 50
          type: integer
      - description: |
          \
          If included, the query results will be exported to the given format.

          * Currently only `csv` is supported.
          * This parameter is only for non-statistical search queries (i.e. no 'calculate' and/or 'groupby' clauses).
          * Results are limited to the first 1 million log entries, and only one export job may run per account at a time.

          The response will be a 202, and the response body will contain a link for polling the export job (on the **/exports/{id}** endpoint).
        example: csv
        in: query
        name: export_format
        required: false
        schema:
          type: string
      - description: |
          \
          When set to true, the `events` object that is returned will additionally contain information about
          all the key-value pairs in each returned log entry.
        example: true
        in: query
        name: kvp_info
        required: false
        schema:
          type: boolean
      - description: |
          \
          When set to `true`, the query returns the most recent events first. When set to `false`, it returns the oldest events first.
        example: true
        in: query
        name: most_recent_first
        required: false
        schema:
          default: false
          type: boolean
      - description: |
          \
          A set of ':' separated label UUIDs. Only entries which have a label matching one of these UUIDs will be returned.
          This only works with non-statistical queries (i.e. no 'groupby' or 'calculate' clauses).
          Takes precedence over the 'label' parameter.
        example: 00000000-0000-0000-0000-000000000001:21b21bb8-8869-4e2c-98df-684892e4e112
        in: query
        name: labels
        required: false
        schema:
          type: string
      - description: |
          \
          If this query parameter is included, the query results will additionally include all log entries received in the
          `from` millisecond which have sequence numbers larger than the one specified.

          Sequence numbers are identifiers used to distinguish between log entries received in the same millisecond.
          If a log entry was split up into several log entries during ingestion, then those chunks are ordered by sequence number.
        in: query
        name: sequence_number
        required: false
        schema:
          type: integer
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/postQueryLogs_request'
        description: |
          The JSON payload must contain:
          * a non-empty array of the log keys for the logs that will be queried
          * a `leql` object, containing a value for either of the following (but **not** for both):
            - `leql.during.time_range`
            - `leql.during.from` and `leql.during.to`

          The `leql.statement` can be empty or omitted.
        required: true
      responses:
        "200":
          content:
            application/json:
              examples:
                EventsResponseSimple:
                  $ref: '#/components/examples/EventsResponseSimple'
                EventsResponsePagination:
                  $ref: '#/components/examples/EventsResponsePagination'
                StatisticalResponseSimple:
                  $ref: '#/components/examples/StatisticalResponseSimple'
                StatisticalResponseTimeSeriesMultiGroupBy:
                  $ref: '#/components/examples/StatisticalResponseTimeSeriesMultiGroupBy'
              schema:
                $ref: '#/components/schemas/getQueryLogs_200_response'
          description: Results in Response Body.
          headers:
            x-beyond-retention:
              $ref: '#/components/headers/x-beyond-retention'
            x-beyond-retention-message:
              $ref: '#/components/headers/x-beyond-retention-message'
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
        "202":
          content:
            application/json:
              examples:
                EventsContinue:
                  $ref: '#/components/examples/EventsContinue'
                EventsContinueExportCSV:
                  $ref: '#/components/examples/EventsContinueExportCSV'
                StatsContinueInitial:
                  $ref: '#/components/examples/StatsContinueInitial'
              schema:
                $ref: '#/components/schemas/getQueryLogs_202_response'
          description: Query in Progress. Links in Response Body.
          headers:
            x-beyond-retention:
              $ref: '#/components/headers/x-beyond-retention'
            x-beyond-retention-message:
              $ref: '#/components/headers/x-beyond-retention-message'
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
        "400":
          description: Malformed JSON Request Body.
        "401":
          description: Unauthorized.
        "404":
          description: Log Not Found.
        "415":
          description: Data not specified as JSON.
        "429":
          content:
            text/plain:
              example: API rate limit exceeded
              schema:
                type: string
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Query Multiple Logs Using LEQL
      tags:
      - Audit API
  /audit/management/logs:
    get:
      description: "Returns all \"audit\" logs for this account. The \"audit\" logs\
        \ are a subset of all the logs, and include the logs \ninside the \"Internal\
        \ Logs\" logset, e.g., \"Web Access Log\", which report on activity within\
        \ Log Search itself.\n"
      operationId: getAllAuditLogs
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/audit_logs_response/value
              schema:
                $ref: '#/components/schemas/audit_log_list'
          description: Logs in Response Body.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
        "400":
          description: Invalid Request.
        "401":
          description: Unauthorized.
        "415":
          description: Non-JSON Request Body Given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: '#/components/headers/X-RateLimit-Limit'
            X-RateLimit-Remaining:
              $ref: '#/components/headers/X-RateLimit-Remaining'
            X-RateLimit-Reset:
              $ref: '#/components/headers/X-RateLimit-Reset'
            Retry-After:
              $ref: '#/components/headers/Retry-After'
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Retrieve All Audit Logs
      tags:
      - Audit API
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region


          def get_audit_logs(s: Session) -> None:
              response = s.get(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/audit/management/logs",
                               headers={'x-api-key': API_KEY})
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              get_audit_logs(session)
  /audit/management/logs/{id}:
    get:
      description: "Returns the \"audit\" log with that **{id}**. The \"audit\" logs\
        \ are a subset of all the logs, and include the logs \ninside the \"Internal\
        \ Logs\" logset, e.g., \"Web Access Log\", which report on activity within\
        \ Log Search itself.\n"
      operationId: getAuditLog
      parameters:
      - description: |
          \
          The id of the log to be queried.
        example: a53578a2-e667-423b-9694-3e989c388186
        in: path
        name: id
        required: true
        schema:
          type: string
      responses:
        "200":
          content:
            application/json:
              example:
                $ref: ../../insightops-examples.yml#/components/examples/audit_log_response/value
              schema:
                $ref: '#/components/schemas/audit_log_single'
          description: Log is Returned.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1audit~1management~1logs~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1audit~1management~1logs~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1audit~1management~1logs~1{id}"
        "400":
          description: Invalid Request.
        "401":
          description: Unauthorized.
        "415":
          description: Non-JSON Request Body Given.
        "429":
          description: Rate Limited.
          headers:
            X-RateLimit-Limit:
              $ref: "#/components/headers/~1audit~1management~1logs~1{id}"
            X-RateLimit-Remaining:
              $ref: "#/components/headers/~1audit~1management~1logs~1{id}"
            X-RateLimit-Reset:
              $ref: "#/components/headers/~1audit~1management~1logs~1{id}"
            Retry-After:
              $ref: "#/components/headers/~1audit~1management~1logs~1{id}"
        "500":
          description: Internal Server Error.
      security:
      - Api Key Authentication:
        - Read Only or Above
      summary: Retrieve An Audit Log
      tags:
      - Audit API
      x-code-samples:
      - lang: Python
        label: Python3.6+
        source: |
          import json
          from requests import Session
          from requests.adapters import HTTPAdapter
          from urllib3.util.retry import Retry

          API_KEY = 'YOUR API KEY HERE'
          AUDIT_LOG_ID = 'YOUR AUDIT LOG ID HERE'
          DATA_STORAGE_REGION = 'eu'  # Swap for your region


          def get_audit_log(s: Session) -> None:
              response = s.get(f"https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com/audit/management/logs/{AUDIT_LOG_ID}",
                               headers={'x-api-key': API_KEY})
              print(response.status_code)
              print(json.dumps(response.json(), indent=4))


          if __name__ == '__main__':
              session = Session()
              session.mount(
                  f'https://{DATA_STORAGE_REGION}.rest.logs.insight.rapid7.com',
                  HTTPAdapter(max_retries=(
                      # Handles rate limiting by default, by sleeping until the limit has reset before retrying.
                      Retry(total=3,
                            backoff_factor=1,
                            status_forcelist=[500, 502, 503, 504])
                  ))
              )
              get_audit_log(session)
components:
  examples:
    EventsResponseSimple:
      summary: query=where(931dde6c60>=800)
      value:
        logs:
        - 565c1b7b-c08b-4c87-a42a-ab08bad56071
        leql:
          statement: where(931dde6c60>=800)
          during:
            from: 1609629856000
            to: 1609629992000
        events:
        - labels:
          - links:
            - rel: Self
              href: https://ap.rest.logs.insight.rapid7.com/management/labels/00000000-0000-0000-0000-000000000001
            id: 00000000-0000-0000-0000-000000000001
          timestamp: 1609629969390
          sequence_number: 2234733321019952220
          log_id: 565c1b7b-c08b-4c87-a42a-ab08bad56071
          message: "{\"931dde6c60\":899}"
          links:
          - rel: Context
            href: https://ap.rest.logs.insight.rapid7.com/query/context/2234733321019952220?per_page=50&timestamp=1609629969390&log_keys=565c1b7b-c08b-4c87-a42a-ab08bad56071&context_type=SURROUND&kvp_info=true
          sequence_number_str: 2234733321019952220
          kvp_info:
          - key:
              text: json.931dde6c60
              start: 2
              end: 12
            value:
              text: 899
              start: 14
              end: 17
        - labels:
          - links:
            - rel: Self
              href: https://ap.rest.logs.insight.rapid7.com/management/labels/00000000-0000-0000-0000-000000000001
            id: 00000000-0000-0000-0000-000000000001
          timestamp: 1609629978988
          sequence_number: 2234733321345612345
          log_id: 565c1b7b-c08b-4c87-a42a-ab08bad56071
          message: "{\"931dde6c60\":931}"
          links:
          - rel: Context
            href: https://ap.rest.logs.insight.rapid7.com/query/context/2234733321345612345?per_page=1&timestamp=1609629978988&log_keys=565c1b7b-c08b-4c87-a42a-ab08bad56071&context_type=SURROUND&kvp_info=true
          sequence_number_str: 2234733321345612345
          kvp_info:
          - key:
              text: json.931dde6c60
              start: 2
              end: 12
              value:
                text: 931
                start: 14
                end: 17
    EventsResponsePagination:
      summary: "query=where(931dde6c60>=800), per_page=1"
      value:
        logs:
        - 565c1b7b-c08b-4c87-a42a-ab08bad56071
        leql:
          statement: where(931dde6c60>=800)
          during:
            from: 1609629856000
            to: 1609629992000
        events:
        - labels:
          - links:
            - rel: Self
              href: https://ap.rest.logs.insight.rapid7.com/management/labels/00000000-0000-0000-0000-000000000001
            id: 00000000-0000-0000-0000-000000000001
          timestamp: 1609629969390
          sequence_number: 2234733321019952220
          log_id: 565c1b7b-c08b-4c87-a42a-ab08bad56071
          message: "{\"931dde6c60\":899}"
          links:
          - rel: Context
            href: https://ap.rest.logs.insight.rapid7.com/query/context/2234733321019952220?per_page=50&timestamp=1609629969390&log_keys=565c1b7b-c08b-4c87-a42a-ab08bad56071&context_type=SURROUND&kvp_info=true
          sequence_number_str: 2234733321019952220
          kvp_info:
          - key:
              text: json.931dde6c60
              start: 2
              end: 12
            value:
              text: 899
              start: 14
              end: 17
        links:
        - rel: Next
          href: https://ap.rest.logs.insight.rapid7.com/query/logs/565c1b7b-c08b-4c87-a42a-ab08bad56071?from=1609629969390&to=1609629992000&per_page=1&sequence_number=2234733321019952220&next_page=true&query=where%28931dde6c60%3E%3D800%29
    StatisticalResponseSimple:
      summary: query=calculate(sd:3ad3319a46)
      value:
        logs:
        - 565c1b7b-c08b-4c87-a42a-ab08bad56071
        - c78579a8-8b20-4e6a-d4c0-5287198a263b
        leql:
          statement: calculate(sd:3ad3319a46)
          during:
            from: 1609679106682
            to: 1609679706682
        statistics:
          cardinality: 0
          granularity: 60000
          from: 1609679106682
          to: 1609679706682
          type: standarddeviation
          stats:
            "3ad3319a46":
              standarddeviation: 287.01781617806677
          groups: []
          others: {}
          status: 200
          timeseries:
            "3ad3319a46":
            - standarddeviation: 264.67908507948334
            - standarddeviation: 318.8861682764081
            - standarddeviation: 288.0976375868536
            - standarddeviation: 298.30015234396
            - standarddeviation: 271.8874158563202
            - standarddeviation: 241.83893687729548
            - standarddeviation: 245.0096430890253
            - standarddeviation: 294.34210035083316
            - standarddeviation: 301.9467447555437
            - standarddeviation: 291.7268742522665
          groups_timeseries: []
          all_exact_results: null
          standarddeviation: 0
          key: 3ad3319a46
        search_stats:
          duration_ms: 93
          bytes_all: 5607226
          bytes_checked: 5607226
          events_all: 20000
          events_checked: 20000
          events_matched: 4310
          index_factor: 0
    StatisticalResponseTimeSeriesMultiGroupBy:
      summary: "query=where(key1 <= 2 AND key2 > 8) groupby(key1, key2) timeslice(5)"
      value:
        logs:
        - c78579a8-8b20-4e6a-d4c0-5287198a263b
        leql:
          statement: "where(key1 <= 2 AND key2 > 8) groupby(key1, key2) timeslice(5)"
          during:
            from: 1609696665614
            to: 1609697265614
        statistics:
          cardinality: 0
          granularity: 0
          from: 1609696665614
          to: 1609697265614
          type: count
          stats: {}
          groups:
          - '[1,9]':
              count: 6.0
          - '[2,10]':
              count: 4.0
          - '[1,10]':
              count: 3.0
          - '[0,9]':
              count: 2.0
          - '[0,10]':
              count: 2.0
          - '[2,9]':
              count: 1.0
          others:
            series: []
          status: 200
          timeseries: {}
          groups_timeseries:
          - "1":
              groups_timeseries:
              - "9":
                  groups_timeseries: []
                  series:
                  - count: 1.0
                  - count: 1.0
                  - count: 2.0
                  - count: 2.0
                  - count: 0.0
                  totals:
                    count: 6.0
              - "10":
                  groups_timeseries: []
                  series:
                  - count: 2.0
                  - count: 0.0
                  - count: 0.0
                  - count: 1.0
                  - count: 0.0
                  total: 3.0
              series:
              - count: 3.0
              - count: 1.0
              - count: 2.0
              - count: 3.0
              - count: 0.0
              totals:
                count: 9.0
          - "2":
              groups_timeseries:
              - "10":
                  groups_timeseries: []
                  series:
                  - count: 1.0
                  - count: 0.0
                  - count: 0.0
                  - count: 2.0
                  - count: 1.0
                  totals:
                    count: 4.0
              - "9":
                  groups_timeseries: []
                  series:
                  - count: 0.0
                  - count: 1.0
                  - count: 0.0
                  - count: 0.0
                  - count: 0.0
                  total:
                    count: 1.0
              series:
              - count: 1.0
              - count: 1.0
              - count: 0.0
              - count: 2.0
              - count: 1.0
              totals:
                count: 5.0
          - "0":
              groups_timeseries:
              - "10":
                  groups_timeseries: []
                  series:
                  - count: 0.0
                  - count: 0.0
                  - count: 1.0
                  - count: 1.0
                  - count: 0.0
                  totals:
                  - count: 2.0
              - "9":
                  groups-timeseries: []
                  series:
                  - count: 0.0
                  - count: 1.0
                  - count: 0.0
                  - count: 1.0
                  - count: 0.0
                  totals:
                  - counts: 2.0
              series:
              - count: 0.0
              - count: 1.0
              - count: 1.0
              - count: 2.0
              - count: 0.0
              totals:
                count: 4.0
          all_exact_result: true
        search_stats:
          duration_ms: 3
          bytes_all: 5607226
          bytes_checked: 2102444
          events_all: 20000
          events_checked: 7490
          events_matched: 18
          index_factor: 0.63
    EventsContinue:
      summary: query=where(931dde6c60>=800)
      value:
        logs:
        - 565c1b7b-c08b-4c87-a42a-ab08bad56071
        leql:
          statement: where(931dde6c60>=800)
          during:
            from: 1609629856000
            to: 1609629992000
        progress: 0
        id: '369640e6-5f93-468d-a6db-d378c7c37756:0:9a3ec09650da40feb64849c5e7bd56379ec9eca9:1:bc5b04ad709824b098f977e04ce729b42835b985:'
        events: []
        links:
        - rel: Self
          href: 'https://ap.rest.logs.insight.rapid7.com/query/369640e6-5f93-468d-a6db-d378c7c37756:0:9a3ec09650da40feb64849c5e7bd56379ec9eca9:1:bc5b04ad709824b098f977e04ce729b42835b985:'
    EventsContinueExportCSV:
      summary: "query=where(931dde6c60>=800), export_format=csv"
      value:
        logs:
        - 565c1b7b-c08b-4c87-a42a-ab08bad56071
        leql:
          statement: where(931dde6c60>=800)
          during:
            from: 1609629856000
            to: 1609629992000
        progress: 0
        id: a782e81a-1414-47c4-a8c6-8dfb16ebfc17
        events: []
        links:
        - rel: Self
          href: https://ap.rest.logs.insight.rapid7.com/exports/a782e81a-1414-47c4-a8c6-8dfb16ebfc17
    StatsContinueInitial:
      summary: query=where(level!=INFO AND /EOFException/) calculate(count) timeslice(2)
      value:
        logs:
        - 626c8841-feb2-4a45-32a8-5224e4cc6ecf
        leql:
          statement: where(level!=INFO AND /EOFException/) calculate(count) timeslice(2)
          during:
            from: 1601812494482
            to: 1609761294482
            time_range: last 3 months
        progress: 0
        id: '18e408bb-b1dd-4000-b64d-3b9d6edde452:1:c682284c6b4439b0ee207d9c6b77e7b26eaac471::6fb96975a9b1307a417bd64af3cca05ef56fa13b:'
        events: []
        partial:
          cardinality: 0
          granularity: 3974400000
          from: 1601812494482
          to: 1609761294482
          type: count
          stats:
            global_timeseries:
              count: 0.0
          groups: []
          others: {}
          status: 200
          timeseries:
            global_timeseries:
            - count 0.0
            - count 0.0
          groups_timeseries: []
          all_exact_result: null
          count: 0
        links:
        - rel: Self
          href: https://eu.rest.logs.insight.rapid7.com/query/18e408bb-b1dd-4000-b64d-3b9d6edde452:1:c682284c6b4439b0ee207d9c6b77e7b26eaac471::6fb96975a9b1307a417bd64af3cca05ef56fa13b:?time_range=last+3+months
  headers:
    x-beyond-retention:
      description: "When present, indicates that the data queried is beyond the retention\
        \ period."
      schema:
        type: boolean
    x-beyond-retention-message:
      description: Standard error message returned if the executed query is beyond
        retention period.
      schema:
        type: string
    X-RateLimit-Limit:
      description: "The total number of requests allowed in the current rate limit\
        \ window. \nBy default, you can make 1,500 requests in a 15-minute time window.\n\
        The `X-RateLimit-Reset` response header tells you how many seconds you must\
        \ wait until the limit is reset.\n"
      required: true
      schema:
        type: integer
    X-RateLimit-Remaining:
      description: The number of requests remaining for the current window.
      required: true
      schema:
        type: integer
    X-RateLimit-Reset:
      description: The number of seconds until the current rate limit window resets.
      required: true
      schema:
        type: integer
    Retry-After:
      description: |
        The number of seconds until the current rate limit window resets.
        Automatically handled by some programming libraries for making HTTP requests.
      required: true
      schema:
        type: integer
    X-RateLimit-Limit-Usage-API:
      description: "The total number of requests allowed in the current rate limit\
        \ window. \nBy default, you can make 500 requests to the `/usage` namespace\
        \ in a 15-minute time window.\nThe `X-RateLimit-Reset` response header tells\
        \ you how many seconds you must wait until the limit is reset.\n"
      required: true
      schema:
        type: integer
    X-RateLimit-Limit-Export-To-CSV:
      description: "The total number of requests allowed in the current rate limit\
        \ window. \nBy default, you can make 500 requests to the `/exports` namespace\
        \ in a 15-minute time window.\nThe `X-RateLimit-Reset` response header tells\
        \ you how many seconds you must wait until the limit is reset.\n"
      required: true
      schema:
        type: integer
    X-RateLimit-Limit-Search-Stats:
      description: "The total number of requests allowed in the current rate limit\
        \ window. \nBy default, you can make 500 requests to the `/search-stats` namespace\
        \ in a 15-minute time window.\nThe `X-RateLimit-Reset` response header tells\
        \ you how many seconds you must wait until the limit is reset.\n"
      required: true
      schema:
        type: integer
  parameters:
    log_keys_deprecated:
      description: |
        \
        The key of the log to be queried.

        Supplying multiple ':' separated log keys is deprecated;
        users should instead 'POST' the query as a JSON payload to [/query/logs](#operation/postQueryLogs).
      example: /query/logs/565c1b7b-c08b-4c87-a42a-ab08bad56071
      in: path
      name: log_keys
      required: true
      schema:
        type: string
    query:
      description: |
        \
        A valid LEQL query to run against the log.
        If omitted, the query retrieves all log entries in the specified time range.
      example: where(foo=bar)
      in: query
      name: query
      required: false
      schema:
        type: string
    from:
      description: |
        \
        The start of the time range for the query, as a UNIX timestamp in milliseconds.
      example: 1450557004000
      in: query
      name: from
      required: true
      schema:
        type: integer
    to:
      description: |
        \
        The end of the time range for the query, as a UNIX timestamp in milliseconds.
      example: 1460557604000
      in: query
      name: to
      required: true
      schema:
        type: integer
    time_range:
      description: |
        \
        An alternative to the `from` and `to` query parameters. Supported values:
        * `yesterday`
        * `today`
        * `last x timeunits` where x is the number of time unit back from the current server time. Supported time units (case insensitive):
            - min(s) or minute(s)
            - hr(s) or hour(s)
            - day(s)
            - week(s)
            - month(s)
            - year(s)

        If `time_range` is used, then the `from` and `to` query parameters must not be used.
      example: last 5 minutes
      in: query
      name: time_range
      required: false
      schema:
        type: string
    label:
      description: |
        \
        Only entries which have a label with this UUID will be returned.
        This only works with non-statistical queries (i.e. no 'groupby' or 'calculate' clauses).
      example: 00000000-0000-0000-0000-000000000001
      in: query
      name: label
      required: false
      schema:
        type: string
    labels:
      description: |
        \
        A set of ':' separated label UUIDs. Only entries which have a label matching one of these UUIDs will be returned.
        This only works with non-statistical queries (i.e. no 'groupby' or 'calculate' clauses).
        Takes precedence over the 'label' parameter.
      example: 00000000-0000-0000-0000-000000000001:21b21bb8-8869-4e2c-98df-684892e4e112
      in: query
      name: labels
      required: false
      schema:
        type: string
    per_page:
      description: |
        \
        Number of log entries to return per page, up to 500(the maximum allowed).
      example: 100
      in: query
      name: per_page
      required: false
      schema:
        default: 50
        type: integer
    export_format:
      description: |
        \
        If included, the query results will be exported to the given format.

        * Currently only `csv` is supported.
        * This parameter is only for non-statistical search queries (i.e. no 'calculate' and/or 'groupby' clauses).
        * Results are limited to the first 1 million log entries, and only one export job may run per account at a time.

        The response will be a 202, and the response body will contain a link for polling the export job (on the **/exports/{id}** endpoint).
      example: csv
      in: query
      name: export_format
      required: false
      schema:
        type: string
    kvp_info:
      description: |
        \
        When set to true, the `events` object that is returned will additionally contain information about
        all the key-value pairs in each returned log entry.
      example: true
      in: query
      name: kvp_info
      required: false
      schema:
        type: boolean
    most_recent_first:
      description: |
        \
        When set to `true`, the query returns the most recent events first. When set to `false`, it returns the oldest events first.
      example: true
      in: query
      name: most_recent_first
      required: false
      schema:
        default: false
        type: boolean
    sequence_number:
      description: |
        \
        If this query parameter is included, the query results will additionally include all log entries received in the
        `from` millisecond which have sequence numbers larger than the one specified.

        Sequence numbers are identifiers used to distinguish between log entries received in the same millisecond.
        If a log entry was split up into several log entries during ingestion, then those chunks are ordered by sequence number.
      in: query
      name: sequence_number
      required: false
      schema:
        type: integer
    logset_name:
      description: |
        \
        The name of the log set to be queried.
        Multiple log sets can be queried by providing this parameter multiple times,
        which results in the query running on the *union* of all contained logs.
        If any of the provided log set names do not exist, a 404 error response is returned.
      example: Internal Logs
      in: query
      name: logset_name
      required: true
      schema:
        type: string
    logset_id:
      description: |
        \
        The id of the log set to be queried.
      example: 4a8869fa-0843-4edd-85f5-bf7d6b80d6c5
      in: path
      name: logset_id
      required: true
      schema:
        type: string
    saved_query_id:
      description: |
        \
        The id of the saved query.
      example: 00000000-0000-00cf-0000-000000000000
      in: path
      name: saved_query_id
      required: true
      schema:
        type: string
    log_keys:
      description: |
        \
        The keys of the logs to be queried, separated by the ':' character.
      example: /query/logs/565c1b7b-c08b-4c87-a42a-ab08bad56071
      in: path
      name: log_keys
      required: true
      schema:
        type: string
    continuation_id:
      description: |
        \
        The continuation id generated when the query started.
      example: '0bnc17f4-bbbe-46b1-a843-163c074bd1ad:0:c5be1c97f925ff772263661182974903b83ef305:50:f89f7d5cbeb270abeb18b1c28262cee66047d21d:'
      in: path
      name: id
      required: true
      schema:
        type: string
    log_keys_live_tail_deprecated:
      description: |
        \
        The keys of the logs for the Live Tail Feed.

        Supplying multiple ':' separated log keys is deprecated;
        users should instead 'POST' the query as a JSON payload to [/query/live/logs](#operation/postLiveLogs).
      example: /query/live/logs/565c1b7b-c08b-4c87-a42a-ab08bad56071
      in: path
      name: log_keys
      required: true
      schema:
        type: string
    query_live_tail:
      description: |
        \
        A valid LEQL query for the Live Tail feed.
        If omitted, the query matches all log entries.

        *Live Tail does not support 'calculate' or 'groupby' queries.*
      example: where(foo=bar)
      in: query
      name: query
      required: false
      schema:
        type: string
    mode:
      description: |
        \
        The order the log entries are returned in. Possible values:
        * `tail` (which returns entries in the order: newest to oldest.)
        * `head` (which returns entries in the order: oldest to newest.)
      example: head
      in: query
      name: mode
      required: false
      schema:
        default: tail
        type: string
    per_page_live_tail:
      description: |
        \
        The maximum number of log entries to return at a time, up to 500(the maximum allowed).
        If the number of results exceed this value, the next "page" of results is returned the next time
        that the Live Tail feed is polled.
      example: 100
      in: query
      name: per_page
      required: false
      schema:
        default: 50
        type: integer
    log_keys_live_tail:
      description: |
        \
        The keys of the logs for the Live Tail Feed, separated by the ':' character.
      example: /query/live/logs/565c1b7b-c08b-4c87-a42a-ab08bad56071
      in: path
      name: log_keys
      required: true
      schema:
        type: string
    live_tail_poll_id:
      description: |
        \
        The polling id generated when the Live Tail Feed started.
      example: 'c9d059da-7b1b-48a9-aaeb-edf2aa3e3fd9:2:::0447214e1b4e5b2041bf62bd7421cb9b7069065f:'
      in: path
      name: id
      required: true
      schema:
        type: string
    log_keys_live_tail_query_param:
      description: |
        \
        The keys of the logs for the Live Tail Feed, separated by the ':' character.
      example: 565c1b7b-c08b-4c87-a42a-ab08bad56071
      in: query
      name: log_keys
      required: false
      schema:
        type: string
    context_id:
      description: |
        \
        The sequence number of the log entry to fetch contextual log entries for
        (a unique identifier used to distinguish between log entries received in the same millisecond).

        The sequence number can be found next to the log entry in the response body for an Event Search query. For
        more context on creating an Event Search query [view the introduction to this section](#tag/Query-Log-Data).
      example: 2134329353399137024
      in: path
      name: id (sequence number)
      required: true
      schema:
        type: integer
    timestamp_context:
      description: |
        \
        The timestamp of the log entry to fetch contextual events for.
      example: 1609607464185
      in: query
      name: timestamp
      required: true
      schema:
        type: string
    log_keys_context:
      description: |
        \
        The key of the log containing the log entry to fetch the contextual events for.
      example: 565c1b7b-c08b-4c87-a42a-ab08bad56071
      in: query
      name: log_keys
      required: true
      schema:
        type: string
    context_type:
      description: |
        Possible values:
        * `AFTER`  -  returns the log entries immediately *after* the given log entry (doesn't include the given log entry).
        * `BEFORE` -  returns the log entries immediately *before* the given log entry (doesn't include the given log entry).
        * `SURROUND` -  returns the log entries immediately *before and after* the given log entry(*does* include the given log entry).
      example: SURROUND
      in: query
      name: context_type
      required: true
      schema:
        type: string
    metrics_id:
      description: |
        \
        The UUID of the pre-computed query.
      example: 9aff96bd-ef12-4887-93b5-00931se12f1a
      in: path
      name: metric_id
      required: true
      schema:
        type: string
    tag_id:
      description: |
        \
        The id of the change detection rule.
      example: 00000000-0000-00cf-0000-000000000000
      in: path
      name: tag_id
      required: true
      schema:
        type: string
    action_id:
      description: |
        \
        The id of the notification.
      example: 00000000-0000-00cf-0000-000000000000
      in: path
      name: action_id
      required: true
      schema:
        type: string
    target_id:
      description: |
        \
        The id of the notification target.
      example: 4a8869fa-0843-4edd-85f5-bf7d6b80d6c5
      in: path
      name: target_id
      required: true
      schema:
        type: string
    log_id:
      description: |
        \
        The id of the log to be queried.
      example: a53578a2-e667-423b-9694-3e989c388186
      in: path
      name: id
      required: true
      schema:
        type: string
    from_usage:
      description: |
        \
        The start of the time range as a string in the format "YYYY-MM-DD".
      example: 2023-09-14
      in: query
      name: from
      required: true
      schema:
        type: string
    to_usage:
      description: |
        \
        The end of the time range as a string in the format "YYYY-MM-DD".
      example: 2023-09-20
      in: query
      name: to
      required: true
      schema:
        type: string
    log_key:
      description: |
        \
        The key of the log to be queried.
      example: 565c1b7b-c08b-4c87-a42a-ab08bad56071
      in: path
      name: log key
      required: true
      schema:
        type: string
    log_ids:
      description: |
        \
        The UUIDs of the logs separated by colons ":" or semicolons ";". For example "UUID1:UUID2:UUID3" or "UUID1;UUID2;UUID3".
      example: aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa:bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb:cccccccc-cccc-cccc-cccc-cccccccccccc
      in: path
      name: ids
      required: true
      schema:
        type: string
    download_logs_limit:
      description: |
        \
        The maximum, and default, number of log entries to download is 500,000,000 log entries.
        You can specify this parameter to limit the number of log entries in the download.
      example: 10
      in: query
      name: limit
      required: false
      schema:
        type: integer
    export_job_id:
      description: |
        \
        The UUID of the export job.
      example: 00000000-0000-0000-0000-000000000000
      in: query
      name: id
      required: true
      schema:
        type: string
    label_id:
      description: |
        \
        The ID of the label to be queried.
      example: 4a8869fa-0843-4edd-85f5-bf7d6b80d6c5
      in: path
      name: label_id
      required: true
      schema:
        type: string
  schemas:
    ListEndpointsResponse:
      additionalProperties:
        $ref: '#/components/schemas/ListEndpointsResponse_value'
      type: object
    EventsResponse:
      example:
        leql:
          statement: statement
          during:
            time_range: time_range
            from: 0
            to: 6
        links:
        - rel: rel
          href: href
        - rel: rel
          href: href
        logs:
        - 565c1b7b-c08b-4c87-a42a-ab08bad56071
        - c78579a8-8b20-4e6a-d4c0-5287198a263b
        events:
        - sequence_number: 5
          log_id: log_id
          sequence_number_str: sequence_number_str
          links:
          - rel: rel
            href: href
          - rel: rel
            href: href
          message: message
          labels:
          - links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
          - links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
          timestamp: 1
          kvp_info:
          - value:
              start: 7
              end: 9
              text: text
            key:
              start: 5
              end: 2
              text: text
          - value:
              start: 7
              end: 9
              text: text
            key:
              start: 5
              end: 2
              text: text
        - sequence_number: 5
          log_id: log_id
          sequence_number_str: sequence_number_str
          links:
          - rel: rel
            href: href
          - rel: rel
            href: href
          message: message
          labels:
          - links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
          - links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
          timestamp: 1
          kvp_info:
          - value:
              start: 7
              end: 9
              text: text
            key:
              start: 5
              end: 2
              text: text
          - value:
              start: 7
              end: 9
              text: text
            key:
              start: 5
              end: 2
              text: text
      properties:
        logs:
          description: The log keys of the logs which the query is run against.
          example:
          - 565c1b7b-c08b-4c87-a42a-ab08bad56071
          - c78579a8-8b20-4e6a-d4c0-5287198a263b
          items:
            type: string
          type: array
        leql:
          $ref: '#/components/schemas/leql'
        events:
          description: |
            The result of the query - the matching log entries (with metadata).
            It is empty for 202 responses.
          items:
            $ref: '#/components/schemas/event_query'
          type: array
        links:
          items:
            $ref: '#/components/schemas/query_api_links_inner'
          type: array
      required:
      - events
      - leql
      - logs
      title: Event Search Response
      type: object
    logs:
      description: The log keys of the logs which the query is run against.
      example:
      - 565c1b7b-c08b-4c87-a42a-ab08bad56071
      - c78579a8-8b20-4e6a-d4c0-5287198a263b
      items:
        type: string
      type: array
    leql:
      description: "The LEQL statement of the query, along with the time range."
      example:
        statement: statement
        during:
          time_range: time_range
          from: 0
          to: 6
      properties:
        during:
          $ref: '#/components/schemas/leql_during'
        statement:
          description: |
            \
            The LEQL query run against the log(s).
            If empty, the query retrieves all log entries in the specified time range.

            Cannot be empty for saved queries.
          type: string
      required:
      - statement
      type: object
    events_query_response:
      description: |
        The result of the query - the matching log entries (with metadata).
        It is empty for 202 responses.
      items:
        $ref: '#/components/schemas/event_query'
      type: array
    event_query:
      example:
        sequence_number: 5
        log_id: log_id
        sequence_number_str: sequence_number_str
        links:
        - rel: rel
          href: href
        - rel: rel
          href: href
        message: message
        labels:
        - links:
          - rel: rel
            href: href
          - rel: rel
            href: href
          id: id
        - links:
          - rel: rel
            href: href
          - rel: rel
            href: href
          id: id
        timestamp: 1
        kvp_info:
        - value:
            start: 7
            end: 9
            text: text
          key:
            start: 5
            end: 2
            text: text
        - value:
            start: 7
            end: 9
            text: text
          key:
            start: 5
            end: 2
            text: text
      properties:
        labels:
          description: "the UUIDs of all labels of the log entry (and a link to **/management/labels/{label_id}**)."
          items:
            $ref: '#/components/schemas/labels_inner'
          type: array
        timestamp:
          description: "The UNIX timestamp in milliseconds, of when the log entry\
            \ was received."
          type: integer
        sequence_number:
          description: The sequence number of the log entry (a unique identifier used
            to distinguish between log entries received in the same millisecond).
          type: integer
        log_id:
          description: The key of the log that the entry belongs to.
          type: string
        message:
          description: The log entry itself.
          type: string
        links:
          items:
            $ref: '#/components/schemas/links_inner'
          type: array
        sequence_number_str:
          description: "The sequence number as a string, rather than as an integer."
          type: string
        kvp_info:
          description: Information about the KVPs in the log entry that were parsed
            when they were received.
          items:
            $ref: '#/components/schemas/kvp_info_inner'
          type: array
      required:
      - log_id
      - message
      - sequence_number
      - sequence_number_str
      - timestamp
      type: object
    labels:
      description: "the UUIDs of all labels of the log entry (and a link to **/management/labels/{label_id}**)."
      items:
        $ref: '#/components/schemas/labels_inner'
      type: array
    links:
      items:
        $ref: '#/components/schemas/links_inner'
      type: array
    kvp_info:
      description: Information about the KVPs in the log entry that were parsed when
        they were received.
      items:
        $ref: '#/components/schemas/kvp_info_inner'
      type: array
    query_api_links:
      items:
        $ref: '#/components/schemas/query_api_links_inner'
      type: array
    StatisticalResponse:
      properties:
        logs:
          description: The log keys of the logs which the query is run against.
          example:
          - 565c1b7b-c08b-4c87-a42a-ab08bad56071
          - c78579a8-8b20-4e6a-d4c0-5287198a263b
          items:
            type: string
          type: array
        leql:
          $ref: '#/components/schemas/leql'
        statistics:
          $ref: '#/components/schemas/statistics'
        search_stats:
          $ref: '#/components/schemas/search_stats'
      required:
      - leql
      - logs
      - search_stats
      - statistics
      title: Statistical Search Response
      type: object
    statistics:
      additionalProperties:
        description: |
          If the function is "count" result is the count; otherwise returns 0.

          Examples:
          * `"count": 10`
          * `"standarddeviation": 0`
          * `"sum": 0`:
        type: number
        x-additionalPropertiesName: <"calculate" function>
      description: The result of the 'calculate' function and/or any 'groupby' queries.
        202 responses may provide a partial result.
      properties:
        stats:
          additionalProperties:
            $ref: '#/components/schemas/stats'
          description: |
            Holds the overall result when query does not contain a 'groupby' clause.

            Examples:
            * `"stats": {"key1": {"sum": <RESULT>}}` for a 'calculate(SUM:key1)' query

            * `"stats": {"number": {"average": <RESULT>}}` for a 'calculate(AVERAGE:number)' query

            * `"stats": {"global_timeseries": {"count": <RESULT>}}` for a 'count' query
          maxProperties: 1
          minProperties: 0
          type: object
        groups:
          description: Holds the overall result for each group in a 'groupby' query.
          items:
            additionalProperties:
              $ref: '#/components/schemas/stats'
            type: object
          type: array
        granularity:
          description: The time window in milliseconds for each time slice in the
            time series.
          type: integer
        timeseries:
          additionalProperties:
            items:
              $ref: '#/components/schemas/stats'
            type: array
            x-additionalPropertiesName: <the given key|"global_timeseries">
          description: Holds the query results for each timeslice (each partition
            of the time_range) (10 by default). For non-'groupby' queries.
          maxProperties: 1
          minProperties: 0
          type: object
        groups_timeseries:
          description: "For 'groupby' queries, holds the timeseries object for each\
            \ group."
          items:
            additionalProperties:
              $ref: '#/components/schemas/groups_timeseries_inner_value'
            type: object
          type: array
        from:
          description: "The start of the time range for the query, as a UNIX timestamp\
            \ in milliseconds."
          type: integer
        to:
          description: "The end of the time range for the query, as a UNIX timestamp\
            \ in milliseconds."
          type: integer
        type:
          description: "The type of function performed, for example, \"count\", \"\
            max\", \"average\", \"standarddeviation\"."
          type: string
        key:
          description: "The key which the function of the 'calculate' clause is applied\
            \ to (for example, `number` in `calculate(SUM:number)`)."
          type: string
        cardinality:
          description: Always 0. (Not implemented)
          type: integer
        others:
          description: Not yet implemented.
          type: object
        status:
          description: "holds a status code for the query(for example, 200, 202, 204,\
            \ 400), potentially different from the status code of the response."
          type: integer
        all_exact_results:
          description: |
            Boolean indicating whether groups are calculated approximately (approximated if a groupby query involves over 10,000 groups).
            Equal to "null" if query is not a groupby query.
          type: boolean
          x-nullable: true
      required:
      - all_exact_results
      - cardinality
      - from
      - granularity
      - groups
      - groups_timeseries
      - others
      - stats
      - status
      - timeseries
      - to
      - type
      type: object
    stats:
      properties:
        average:
          type: number
        min:
          type: number
        max:
          type: number
        median:
          type: number
        percentile_<1 to 99>*:
          type: number
        count:
          type: number
        sum:
          type: number
        standarddeviation:
          type: number
        unique:
          type: number
        bytes:
          type: number
      type: object
    groups:
      description: Holds the overall result for each group in a 'groupby' query.
      items:
        additionalProperties:
          $ref: '#/components/schemas/stats'
        type: object
      type: array
    timeseries:
      additionalProperties:
        items:
          $ref: '#/components/schemas/stats'
        type: array
        x-additionalPropertiesName: <the given key|"global_timeseries">
      description: Holds the query results for each timeslice (each partition of the
        time_range) (10 by default). For non-'groupby' queries.
      maxProperties: 1
      minProperties: 0
      type: object
    groups_timeseries:
      description: "For 'groupby' queries, holds the timeseries object for each group."
      items:
        additionalProperties:
          $ref: '#/components/schemas/groups_timeseries_inner_value'
        type: object
      type: array
    search_stats:
      description: It includes the metrics of the executed query.
      properties:
        duration_ms:
          description: "The time taken to complete the query, in milliseconds."
          type: integer
        bytes_all:
          description: The total number of bytes.
          type: integer
        bytes_checked:
          description: The number of bytes checked.
          type: integer
        events_all:
          description: The total number of events.
          type: integer
        events_checked:
          description: The number of events checked.
          type: integer
        events_matched:
          description: The number of events matched.
          type: integer
        index_factor:
          description: |
            This shows if the query was able to use our indexing technology to help reduce the query duration.
            * Value of 0: Indexing could not be used.
            * Value of 1: Full indexing was achieved to reduce the query duration.
          type: number
      type: object
    EventsContinuation:
      example:
        leql:
          statement: statement
          during:
            time_range: time_range
            from: 0
            to: 6
        progress: 3
        links:
        - rel: rel
          href: href
        - rel: rel
          href: href
        id: id
        logs:
        - 565c1b7b-c08b-4c87-a42a-ab08bad56071
        - c78579a8-8b20-4e6a-d4c0-5287198a263b
        events:
        - sequence_number: 5
          log_id: log_id
          sequence_number_str: sequence_number_str
          links:
          - rel: rel
            href: href
          - rel: rel
            href: href
          message: message
          labels:
          - links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
          - links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
          timestamp: 1
          kvp_info:
          - value:
              start: 7
              end: 9
              text: text
            key:
              start: 5
              end: 2
              text: text
          - value:
              start: 7
              end: 9
              text: text
            key:
              start: 5
              end: 2
              text: text
        - sequence_number: 5
          log_id: log_id
          sequence_number_str: sequence_number_str
          links:
          - rel: rel
            href: href
          - rel: rel
            href: href
          message: message
          labels:
          - links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
          - links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
          timestamp: 1
          kvp_info:
          - value:
              start: 7
              end: 9
              text: text
            key:
              start: 5
              end: 2
              text: text
          - value:
              start: 7
              end: 9
              text: text
            key:
              start: 5
              end: 2
              text: text
      properties:
        logs:
          description: The log keys of the logs which the query is run against.
          example:
          - 565c1b7b-c08b-4c87-a42a-ab08bad56071
          - c78579a8-8b20-4e6a-d4c0-5287198a263b
          items:
            type: string
          type: array
        leql:
          $ref: '#/components/schemas/leql'
        progress:
          description: The completion of the query in percent (0 to 99).
          type: integer
        id:
          description: "The query ID which can be used to poll the query on the **/query/{id}**\
            \ endpoint."
          type: string
        events:
          description: |
            The result of the query - the matching log entries (with metadata).
            It is empty for 202 responses.
          items:
            $ref: '#/components/schemas/event_query'
          type: array
        links:
          items:
            $ref: '#/components/schemas/query_api_links_inner'
          type: array
      required:
      - events
      - id
      - leql
      - links
      - logs
      - progress
      title: Event Search In Progress
      type: object
    StatisticalContinuation:
      properties:
        logs:
          description: The log keys of the logs which the query is run against.
          example:
          - 565c1b7b-c08b-4c87-a42a-ab08bad56071
          - c78579a8-8b20-4e6a-d4c0-5287198a263b
          items:
            type: string
          type: array
        leql:
          $ref: '#/components/schemas/leql'
        progress:
          description: The completion of the query in percent (0 to 99).
          type: integer
        id:
          description: "The query ID which can be used to poll the query on the **/query/{id}**\
            \ endpoint."
          type: string
        events:
          description: This array is always empty.
          items:
            type: object
          type: array
        partial:
          $ref: '#/components/schemas/statistics'
        links:
          items:
            $ref: '#/components/schemas/query_api_links_inner'
          type: array
      required:
      - events
      - id
      - leql
      - links
      - logs
      - partial
      - progress
      title: Statistical Search In Progress
      type: object
    saved_query:
      example:
        leql:
          statement: statement
          during:
            time_range: time_range
            from: 0
            to: 6
        name: name
        id: id
        logs:
        - 565c1b7b-c08b-4c87-a42a-ab08bad56071
        - c78579a8-8b20-4e6a-d4c0-5287198a263b
      properties:
        id:
          description: The unique id of the saved query.
          type: string
        name:
          description: The name of the saved query.
          type: string
        leql:
          $ref: '#/components/schemas/leql'
        logs:
          description: The log keys of the logs which the query is run against.
          example:
          - 565c1b7b-c08b-4c87-a42a-ab08bad56071
          - c78579a8-8b20-4e6a-d4c0-5287198a263b
          items:
            type: string
          type: array
      required:
      - id
      - name
      type: object
    create_saved_query:
      properties:
        saved_query:
          $ref: '#/components/schemas/create_saved_query_saved_query'
      type: object
    patch_saved_query:
      properties:
        saved_query:
          $ref: '#/components/schemas/patch_saved_query_saved_query'
      type: object
    leql_PATCH:
      description: The LEQL statement of the query and/or the time range.
      properties:
        during:
          $ref: '#/components/schemas/leql_PATCH_during'
        statement:
          description: |
            \
            The LEQL query run against the log(s).
            If empty, the query retrieves all log entries in the specified time range.

            Cannot be empty for saved queries.
          type: string
      type: object
    leql_variable_response:
      example:
        reserved: false
        created: 2022-10-21T11:51:53.971784
        name: BadIPs
        description: List of banned IP addresses
        id: 123e4567-e89b-12d3-a456-426614174000
        value: "IP(10.0.0.0/8), IP(5.0.0.0/8)"
        userId: 00000000-0000-0000-0000-000000000001
        updated: 2022-10-21T11:51:53.971784
      properties:
        id:
          description: Unique variable ID. UUID.
          example: 123e4567-e89b-12d3-a456-426614174000
          type: string
        name:
          description: Variable name.
          example: BadIPs
          pattern: "^[a-zA-Z0-9_]{1,128}$"
          type: string
        description:
          description: Variable description.
          example: List of banned IP addresses
          maxLength: 1024
          minLength: 0
          nullable: true
          type: string
        value:
          description: Variable contents.
          example: "IP(10.0.0.0/8), IP(5.0.0.0/8)"
          maxLength: 1024
          minLength: 1
          type: string
        userId:
          description: The ID of the user that created the variable.
          example: 00000000-0000-0000-0000-000000000001
          type: string
        created:
          description: The date/time when the variable was created.
          example: 2022-10-21T11:51:53.971784
          type: string
        updated:
          description: The date/time when the variable was updated.
          example: 2022-10-21T11:51:53.971784
          type: string
        reserved:
          description: Reserved variables cannot be modified.
          example: false
          type: boolean
      required:
      - id
      - name
      - value
      type: object
    variable_id:
      description: Unique variable ID. UUID.
      example: 123e4567-e89b-12d3-a456-426614174000
      type: string
    variable_name:
      description: Variable name.
      example: BadIPs
      pattern: "^[a-zA-Z0-9_]{1,128}$"
      type: string
    variable_description:
      description: Variable description.
      example: List of banned IP addresses
      maxLength: 1024
      minLength: 0
      nullable: true
      type: string
    variable_value:
      description: Variable contents.
      example: "IP(10.0.0.0/8), IP(5.0.0.0/8)"
      maxLength: 1024
      minLength: 1
      type: string
    variable_user_id:
      description: The ID of the user that created the variable.
      example: 00000000-0000-0000-0000-000000000001
      type: string
    variable_created_timestamp:
      description: The date/time when the variable was created.
      example: 2022-10-21T11:51:53.971784
      type: string
    variable_updated_timestamp:
      description: The date/time when the variable was updated.
      example: 2022-10-21T11:51:53.971784
      type: string
    variable_reserved:
      description: Reserved variables cannot be modified.
      example: false
      type: boolean
    leql_variable_request:
      properties:
        name:
          description: Variable name.
          example: BadIPs
          pattern: "^[a-zA-Z0-9_]{1,128}$"
          type: string
        description:
          description: Variable description.
          example: List of banned IP addresses
          maxLength: 1024
          minLength: 0
          nullable: true
          type: string
        value:
          description: Variable contents.
          example: "IP(10.0.0.0/8), IP(5.0.0.0/8)"
          maxLength: 1024
          minLength: 1
          type: string
      required:
      - name
      - value
      type: object
    LiveTailResponse:
      example:
        leql:
          statement: statement
        links:
        - rel: rel
          href: href
        - rel: rel
          href: href
        logs:
        - 565c1b7b-c08b-4c87-a42a-ab08bad56071
        - c78579a8-8b20-4e6a-d4c0-5287198a263b
        events:
        - sequence_number: 6
          log_id: log_id
          sequence_number_str: sequence_number_str
          message: message
          labels:
          - links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
          - links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
          timestamp: 0
        - sequence_number: 6
          log_id: log_id
          sequence_number_str: sequence_number_str
          message: message
          labels:
          - links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
          - links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
          timestamp: 0
      properties:
        logs:
          description: The log keys of the logs for the live tail feed.
          example:
          - 565c1b7b-c08b-4c87-a42a-ab08bad56071
          - c78579a8-8b20-4e6a-d4c0-5287198a263b
          items:
            type: string
          type: array
        leql:
          $ref: '#/components/schemas/leql_live_tail'
        events:
          description: |
            Always empty.
          items:
            $ref: '#/components/schemas/event_live_tail'
          type: array
        links:
          items:
            $ref: '#/components/schemas/links_inner'
          type: array
      required:
      - events
      - leql
      - links
      - logs
      type: object
    logs_live_tail:
      description: The log keys of the logs for the live tail feed.
      example:
      - 565c1b7b-c08b-4c87-a42a-ab08bad56071
      - c78579a8-8b20-4e6a-d4c0-5287198a263b
      items:
        type: string
      type: array
    leql_live_tail:
      description: The LEQL statement of the query.
      example:
        statement: statement
      properties:
        statement:
          description: |
            \
            The LEQL query that incoming log entries are matched against.
            If empty, the query matches all incoming log entries.

            Cannot be a statistical query ('calculate' or 'groupby' query).
          type: string
      type: object
    events_live_tail_start:
      description: |
        Always empty.
      items:
        $ref: '#/components/schemas/event_live_tail'
      type: array
    event_live_tail:
      example:
        sequence_number: 6
        log_id: log_id
        sequence_number_str: sequence_number_str
        message: message
        labels:
        - links:
          - rel: rel
            href: href
          - rel: rel
            href: href
          id: id
        - links:
          - rel: rel
            href: href
          - rel: rel
            href: href
          id: id
        timestamp: 0
      properties:
        labels:
          description: "the UUIDs of all labels of the log entry (and a link to **/management/labels/{label_id}**)."
          items:
            $ref: '#/components/schemas/labels_inner'
          type: array
        timestamp:
          description: "The UNIX timestamp in milliseconds, of when the log entry\
            \ was received."
          type: integer
        sequence_number:
          description: The sequence number of the log entry (a unique identifier used
            to distinguish between log entries received in the same millisecond).
          type: integer
        log_id:
          description: The key of the log that the entry belongs to.
          type: string
        message:
          description: The log entry itself.
          type: string
        sequence_number_str:
          description: "The sequence number as a string, rather than as an integer."
          type: string
      required:
      - log_id
      - message
      - sequence_number
      - sequence_number_str
      - timestamp
      type: object
    LiveTailPollResponse:
      example:
        leql:
          statement: statement
        links:
        - rel: rel
          href: href
        - rel: rel
          href: href
        logs:
        - 565c1b7b-c08b-4c87-a42a-ab08bad56071
        - c78579a8-8b20-4e6a-d4c0-5287198a263b
        events:
        - sequence_number: 6
          log_id: log_id
          sequence_number_str: sequence_number_str
          message: message
          labels:
          - links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
          - links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
          timestamp: 0
        - sequence_number: 6
          log_id: log_id
          sequence_number_str: sequence_number_str
          message: message
          labels:
          - links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
          - links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
          timestamp: 0
      properties:
        logs:
          description: The log keys of the logs for the live tail feed.
          example:
          - 565c1b7b-c08b-4c87-a42a-ab08bad56071
          - c78579a8-8b20-4e6a-d4c0-5287198a263b
          items:
            type: string
          type: array
        leql:
          $ref: '#/components/schemas/leql_live_tail'
        events:
          description: |
            The log entries (with metadata) ingested which match the query.
          items:
            $ref: '#/components/schemas/event_live_tail'
          type: array
        links:
          items:
            $ref: '#/components/schemas/links_inner'
          type: array
      required:
      - events
      - leql
      - links
      - logs
      type: object
    events_live_tail_poll:
      description: |
        The log entries (with metadata) ingested which match the query.
      items:
        $ref: '#/components/schemas/event_live_tail'
      type: array
    ContextResponse:
      example:
        leql:
          statement: statement
          during:
            from: 0
            to: 6
        links:
        - rel: rel
          href: href
        - rel: rel
          href: href
        logs:
        - 565c1b7b-c08b-4c87-a42a-ab08bad56071
        events:
        - sequence_number: 5
          log_id: log_id
          sequence_number_str: sequence_number_str
          links:
          - rel: rel
            href: href
          - rel: rel
            href: href
          message: message
          labels:
          - links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
          - links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
          timestamp: 1
          kvp_info:
          - value:
              start: 7
              end: 9
              text: text
            key:
              start: 5
              end: 2
              text: text
          - value:
              start: 7
              end: 9
              text: text
            key:
              start: 5
              end: 2
              text: text
        - sequence_number: 5
          log_id: log_id
          sequence_number_str: sequence_number_str
          links:
          - rel: rel
            href: href
          - rel: rel
            href: href
          message: message
          labels:
          - links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
          - links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
          timestamp: 1
          kvp_info:
          - value:
              start: 7
              end: 9
              text: text
            key:
              start: 5
              end: 2
              text: text
          - value:
              start: 7
              end: 9
              text: text
            key:
              start: 5
              end: 2
              text: text
      properties:
        logs:
          description: The log key of the log which contains the contextual log entries.
          example:
          - 565c1b7b-c08b-4c87-a42a-ab08bad56071
          items:
            type: string
          type: array
        leql:
          $ref: '#/components/schemas/leql_context'
        events:
          description: |
            The contextual log entries for the given log entry.
            It is empty for a 202 response.
          items:
            $ref: '#/components/schemas/event_query'
          type: array
        links:
          items:
            $ref: '#/components/schemas/context_api_links_inner'
          type: array
      required:
      - events
      - leql
      - logs
      type: object
    logs_context:
      description: The log key of the log which contains the contextual log entries.
      example:
      - 565c1b7b-c08b-4c87-a42a-ab08bad56071
      items:
        type: string
      type: array
    leql_context:
      description: Contains the timestamps of the first and last log entry on the
        current page of contextual log entries.
      example:
        statement: statement
        during:
          from: 0
          to: 6
      properties:
        during:
          $ref: '#/components/schemas/leql_context_during'
        statement:
          description: Always null.
          type: string
      type: object
    events_context:
      description: |
        The contextual log entries for the given log entry.
        It is empty for a 202 response.
      items:
        $ref: '#/components/schemas/event_query'
      type: array
    context_api_links:
      items:
        $ref: '#/components/schemas/context_api_links_inner'
      type: array
    ContextContinueResponse:
      example:
        leql:
          statement: statement
          during:
            from: 0
            to: 6
        progress: 1
        links:
        - rel: rel
          href: href
        - rel: rel
          href: href
        id: id
        logs:
        - 565c1b7b-c08b-4c87-a42a-ab08bad56071
        events:
        - sequence_number: 5
          log_id: log_id
          sequence_number_str: sequence_number_str
          links:
          - rel: rel
            href: href
          - rel: rel
            href: href
          message: message
          labels:
          - links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
          - links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
          timestamp: 1
          kvp_info:
          - value:
              start: 7
              end: 9
              text: text
            key:
              start: 5
              end: 2
              text: text
          - value:
              start: 7
              end: 9
              text: text
            key:
              start: 5
              end: 2
              text: text
        - sequence_number: 5
          log_id: log_id
          sequence_number_str: sequence_number_str
          links:
          - rel: rel
            href: href
          - rel: rel
            href: href
          message: message
          labels:
          - links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
          - links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
          timestamp: 1
          kvp_info:
          - value:
              start: 7
              end: 9
              text: text
            key:
              start: 5
              end: 2
              text: text
          - value:
              start: 7
              end: 9
              text: text
            key:
              start: 5
              end: 2
              text: text
      properties:
        logs:
          description: The log key of the log which contains the contextual log entries.
          example:
          - 565c1b7b-c08b-4c87-a42a-ab08bad56071
          items:
            type: string
          type: array
        leql:
          $ref: '#/components/schemas/leql_context'
        progress:
          description: The completion of the query in percent (0 to 99).
          type: integer
        id:
          description: "The query ID which can be used to poll the query on the **/query/{id}**\
            \ endpoint."
          type: string
        events:
          description: |
            The contextual log entries for the given log entry.
            It is empty for a 202 response.
          items:
            $ref: '#/components/schemas/event_query'
          type: array
        links:
          items:
            $ref: '#/components/schemas/context_api_links_inner'
          type: array
      required:
      - events
      - id
      - leql
      - logs
      - progress
      type: object
    MetricsResponse:
      example:
        leql:
          function: function
          statement: statement
        logsets:
        - logs_info:
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          name: ""
          description: description
          id: id
          user_data: "{}"
          rrn: ""
        - logs_info:
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          name: ""
          description: description
          id: id
          user_data: "{}"
          rrn: ""
        id: id
        logs:
        - logsets_info:
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          name: ""
          structures:
          - structures
          - structures
          tokens:
          - tokens
          - tokens
          source_type: token
          links:
          - rel: rel
            href: href
          - rel: rel
            href: href
          id: id
          ip_address: ip_address
          user_data:
            key: user_data
          token_seed: ""
          retention_period: retention_period
          rrn: rrn
        - logsets_info:
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          name: ""
          structures:
          - structures
          - structures
          tokens:
          - tokens
          - tokens
          source_type: token
          links:
          - rel: rel
            href: href
          - rel: rel
            href: href
          id: id
          ip_address: ip_address
          user_data:
            key: user_data
          token_seed: ""
          retention_period: retention_period
          rrn: rrn
        statistics:
          result: 5.962133916683182
          timeseries:
          - time: 6
            value: 1.4658129805029452
          - time: 6
            value: 1.4658129805029452
          type: COUNT
          resolution: 0
          key: key
      properties:
        id:
          description: The UUID of the pre-computed query.
          type: string
        logs:
          description: The information of the logs used in the pre-computed query.
          items:
            $ref: '#/components/schemas/log_info_response'
          type: array
        logsets:
          description: The information on the log sets used in the pre-computed query.
          items:
            $ref: '#/components/schemas/logset_info'
          type: array
        leql:
          $ref: '#/components/schemas/leql_metrics'
        statistics:
          $ref: '#/components/schemas/statistics_metrics'
      type: object
    logs_metrics:
      description: The information of the logs used in the pre-computed query.
      items:
        $ref: '#/components/schemas/log_info_response'
      type: array
    log_info_response:
      example:
        logsets_info:
        - name: name
          links:
          - rel: rel
            href: href
          - rel: rel
            href: href
          id: id
          rrn: rrn
        - name: name
          links:
          - rel: rel
            href: href
          - rel: rel
            href: href
          id: id
          rrn: rrn
        name: ""
        structures:
        - structures
        - structures
        tokens:
        - tokens
        - tokens
        source_type: token
        links:
        - rel: rel
          href: href
        - rel: rel
          href: href
        id: id
        ip_address: ip_address
        user_data:
          key: user_data
        token_seed: ""
        retention_period: retention_period
        rrn: rrn
      properties:
        id:
          description: The UUID of the log.
          type: string
        name:
          description: The name of the log.
        tokens:
          description: The log token(s) used for writing to the log. This only applies
            to token type logs (view the `source_type` parameter).
          items:
            type: string
          type: array
        structures:
          description: |
            Structures are internal entities which may apply some additional processing to log entries written to this log.
          items:
            type: string
          type: array
        ip_address:
          description: The IP address that the Log Search system receives log entries
            from. This only applies to syslog type logs (view the `source_type` parameter).
          type: string
        logsets_info:
          description: |
            The information on each log set that this log is part of.
          items:
            $ref: '#/components/schemas/member_info_inner'
          type: array
        user_data:
          additionalProperties:
            type: string
            x-additionalPropertiesName: <key>
          description: A list of key-values pairs that may indicate some auxiliary
            information about the log.
          type: object
        source_type:
          default: token
          description: |
            A categorization of logs which defines how log entries are received by a server.
            * Syslog type logs are associated with an IP address and a port (the values appear in the `user_data` field). Any log entries received by the server on that port and from that IP address will belong to that log.
            * Token type logs are associated with a log token. Any log entries received by the server on one of the [standard ports](https://docs.rapid7.com/insightops/token-tcp) containing that log token will belong to that log (with the log token removed from the log entry).
            * Internal type logs use internal mechanisms to receive log entries, for example any of the logs in the Internal Logs log set.
          enum:
          - syslog
          - token
          - internal
          type: string
        rrn:
          description: The Rapid7 Resource Name (RRN) of the log. The RRN is a unique
            identifier across the Rapid7 Platform.
          type: string
        token_seed:
          description: The seed used to generate the log token (if the log's source
            type is `"token"`).
        retention_period:
          $ref: '#/components/schemas/retention_period_enum'
        links:
          items:
            $ref: '#/components/schemas/links_inner'
          type: array
      required:
      - id
      - links
      - name
      type: object
    member_info:
      description: |
        The information on each log set that this log is part of.
      items:
        $ref: '#/components/schemas/member_info_inner'
      type: array
    retention_period_enum:
      enum:
      - 1w
      - 2w
      - 1m
      - 2m
      - 6m
      - 1y
      - 2y
      - unlimited
      - default
      type: string
    logsets_metrics:
      description: The information on the log sets used in the pre-computed query.
      items:
        $ref: '#/components/schemas/logset_info'
      type: array
    logset_info:
      example:
        logs_info:
        - name: name
          links:
          - rel: rel
            href: href
          - rel: rel
            href: href
          id: id
          rrn: rrn
        - name: name
          links:
          - rel: rel
            href: href
          - rel: rel
            href: href
          id: id
          rrn: rrn
        name: ""
        description: description
        id: id
        user_data: "{}"
        rrn: ""
      properties:
        id:
          description: The UUID of the log set.
          type: string
        name:
          description: The name of the log set.
        description:
          description: The description of the log set.
          type: string
        user_data:
          description: A list of key-value pairs that may indicate some auxiliary
            information about the log set.
          type: object
        logs_info:
          description: |
            Information on each log that this log set contains.
          items:
            $ref: '#/components/schemas/member_info_logset_inner'
          type: array
        rrn:
          description: The Rapid7 Resource Name (RRN) of the log set. The RRN is a
            unique identifier across the Rapid7 Platform.
      required:
      - description
      - id
      - logs_info
      - name
      - rrn
      - user_data
      type: object
    member_info_logset:
      description: |
        Information on each log that this log set contains.
      items:
        $ref: '#/components/schemas/member_info_logset_inner'
      type: array
    leql_metrics:
      description: The LEQL statement of the pre-computed query.
      example:
        function: function
        statement: statement
      properties:
        statement:
          description: "The 'where' statement of the pre-computed query, for example,\
            \ `\"where(foo>10 AND bar!=0 OR /some_reg[ex]*/)\"`."
          type: string
        function:
          description: |
            The 'calculate' statement of the pre-computed query.
            Possible values:
            * `"calculate(count)"`
            * `"calculate(min: <key>)"`
            * `"calculate(max: <key>)"`
            * `"calculate(sum: <key>)"`
            * `"calculate(average: <key>)"`
            * `"calculate(bytes)"`
          type: string
      type: object
    statistics_metrics:
      description: Holds the results of the query.
      example:
        result: 5.962133916683182
        timeseries:
        - time: 6
          value: 1.4658129805029452
        - time: 6
          value: 1.4658129805029452
        type: COUNT
        resolution: 0
        key: key
      properties:
        type:
          description: |
            The type of calculation performed.
          enum:
          - COUNT
          - MIN
          - MAX
          - SUM
          - AVERAGE
          - BYTES
          type: string
        key:
          description: The key that the calculation was performed on.
          type: string
        resolution:
          description: "The length of each element of the time series, in seconds."
          type: integer
        timeseries:
          items:
            $ref: '#/components/schemas/statistics_metrics_timeseries_inner'
          type: array
        result:
          description: The total of all the values in the timeseries.
          type: number
      type: object
    statistics_metrics_resolution:
      description: "The length of each element of the time series, in seconds."
      type: integer
    statistics_metrics_timeseries:
      items:
        $ref: '#/components/schemas/statistics_metrics_timeseries_inner'
      type: array
    statistics_metrics_result:
      description: The total of all the values in the timeseries.
      type: number
    basic_tag_response:
      example:
        sources:
        - name: name
          stored_days: ""
          id: id
          retention_period: retention_period
          token: token
        - name: name
          stored_days: ""
          id: id
          retention_period: retention_period
          token: token
        leql:
          statement: statement
        patterns:
        - patterns
        - patterns
        name: name
        description: description
        id: id
        user_data: "{}"
        type: type
        priority: 1
        actions:
        - min_matches_count: 0
          min_report_count: 6
          min_report_period: min_report_period
          id: id
          type: type
          min_matches_period: min_matches_period
          targets:
          - alert_content_set:
              le_trigger_event:
              - le_trigger_event
              - le_trigger_event
              le_context: le_context
            name: name
            description: description
            params_set:
              direct: direct
            id: id
            user_data: "{}"
            type: type
          - alert_content_set:
              le_trigger_event:
              - le_trigger_event
              - le_trigger_event
              le_context: le_context
            name: name
            description: description
            params_set:
              direct: direct
            id: id
            user_data: "{}"
            type: type
          enabled: true
        - min_matches_count: 0
          min_report_count: 6
          min_report_period: min_report_period
          id: id
          type: type
          min_matches_period: min_matches_period
          targets:
          - alert_content_set:
              le_trigger_event:
              - le_trigger_event
              - le_trigger_event
              le_context: le_context
            name: name
            description: description
            params_set:
              direct: direct
            id: id
            user_data: "{}"
            type: type
          - alert_content_set:
              le_trigger_event:
              - le_trigger_event
              - le_trigger_event
              le_context: le_context
            name: name
            description: description
            params_set:
              direct: direct
            id: id
            user_data: "{}"
            type: type
          enabled: true
        labels:
        - color: color
          reserved: true
          name: name
          id: id
          sn: 5
        - color: color
          reserved: true
          name: name
          id: id
          sn: 5
      properties:
        type:
          description: Always set to "Alert".
          type: string
        id:
          description: The unique id of the detection rule.
          type: string
        name:
          description: The name of the detection rule.
          type: string
        description:
          description: The description of the detection rule.
          type: string
        sources:
          description: The collection of logs the detection rule operates on.
          items:
            $ref: '#/components/schemas/tag_source_response'
          type: array
        actions:
          description: The notifications attached to the detection rule.
          items:
            $ref: '#/components/schemas/action_response'
          type: array
        patterns:
          deprecated: true
          description: Use the `leql` parameter instead of this parameter.
          items:
            type: string
          title: patterns
          type: array
        leql:
          $ref: '#/components/schemas/basic_leql'
        priority:
          description: This ensures investigations are ordered by priority in Investigation
            Management. Must be >=0
          type: integer
        user_data:
          description: A list of key-value pairs that may indicate some auxiliary
            information about the change detection rule.
          type: object
        labels:
          description: The labels attached to the detection rule.
          items:
            $ref: '#/components/schemas/label_response'
          type: array
      title: Pattern Detection
      type: object
    name_def:
      description: The name of the detection rule.
      type: string
    description_def:
      description: The description of the detection rule.
      type: string
    sources_array:
      description: The collection of logs the detection rule operates on.
      items:
        $ref: '#/components/schemas/tag_source_response'
      type: array
    tag_source_response:
      example:
        name: name
        stored_days: ""
        id: id
        retention_period: retention_period
        token: token
      properties:
        id:
          description: The UUID of the log.
          type: string
        retention_period:
          $ref: '#/components/schemas/retention_period_enum'
        token:
          description: The log token(s) used for writing to the log. This only applies
            to token type logs (view the `source_type` parameter).
          type: string
        name:
          description: The name of the log.
          type: string
        stored_days:
          description: The number of days stored.
      type: object
    actions_array:
      description: The notifications attached to the detection rule.
      items:
        $ref: '#/components/schemas/action_response'
      type: array
    action_response:
      example:
        min_matches_count: 0
        min_report_count: 6
        min_report_period: min_report_period
        id: id
        type: type
        min_matches_period: min_matches_period
        targets:
        - alert_content_set:
            le_trigger_event:
            - le_trigger_event
            - le_trigger_event
            le_context: le_context
          name: name
          description: description
          params_set:
            direct: direct
          id: id
          user_data: "{}"
          type: type
        - alert_content_set:
            le_trigger_event:
            - le_trigger_event
            - le_trigger_event
            le_context: le_context
          name: name
          description: description
          params_set:
            direct: direct
          id: id
          user_data: "{}"
          type: type
        enabled: true
      properties:
        id:
          description: The ID of the notification.
          type: string
        min_matches_count:
          default: 0
          description: "The number of log entries that the pattern detection rule\
            \ needs to match for a notification to be triggered (within a window of\
            \ time, controlled by the `min_matches_period` parameter)."
          type: integer
        min_matches_period:
          description: "The time window used in combination with the `min_matches_count`\
            \ parameter to determine if enough log entries have matched a pattern\
            \ detection rule for an alert notification to be sent. For example, if\
            \ `min_matches_count=2`, and `min_matches_period=\"5Minute\"`, then this\
            \ notification will be triggered whenever two log entries match the pattern\
            \ detection rule within 5 Minutes."
          type: string
        min_report_count:
          default: 1
          description: "The maximum number of notifications that will be triggered\
            \ within a window of time, controlled by the `min_report_period` parameter."
          type: integer
        min_report_period:
          $ref: '#/components/schemas/period_enum'
        targets:
          description: The list of notification targets for this notification.
          items:
            $ref: '#/components/schemas/target_response'
          type: array
        enabled:
          description: |
            \
            When set to true, the notification is enabled. When set to false, the notification is disabled.
          type: boolean
        type:
          description: Always set to "Alert".
          type: string
      type: object
    period_enum:
      default: Hour
      enum:
      - Hour
      - Day
      - Minute
      - 5Minute
      - 10Minute
      - 15Minute
      - 30Minute
      type: string
    target_response:
      example:
        alert_content_set:
          le_trigger_event:
          - le_trigger_event
          - le_trigger_event
          le_context: le_context
        name: name
        description: description
        params_set:
          direct: direct
        id: id
        user_data: "{}"
        type: type
      properties:
        id:
          description: The id of the notification target.
          type: string
        name:
          description: The name of the notification target.
          type: string
        description:
          description: The description of the notification target.
          type: string
        type:
          $ref: '#/components/schemas/notification_type_enum'
        params_set:
          $ref: '#/components/schemas/target_response_params_set'
        user_data:
          description: A list of key-value pairs that may indicate some auxiliary
            information about the notification target.
          properties: {}
          type: object
        alert_content_set:
          $ref: '#/components/schemas/target_alert_content_set'
      required:
      - alert_content_set
      - description
      - id
      - name
      - params_set
      - type
      - user_data
      type: object
    notification_type_enum:
      enum:
      - mailto
      - pagerduty
      - webhook
      - slack
      - sqs
      type: string
    target_params_set_mailto:
      description: The list of key values that are defined for target type **mailto**.
      example:
        direct: direct
      properties:
        direct:
          description: The list of emails to send the notification to. The emails
            are separated by commas.
          type: string
      required:
      - direct
      title: mailto
      type: object
    target_params_set_pagerduty:
      description: The list of key values that are defined for the **pagerduty** target
        type.
      properties:
        service_key:
          description: The service key of the PagerDuty.
          type: string
        description:
          description: The description of the PagerDuty target.
          type: string
      required:
      - service_key
      title: pagerduty
      type: object
    target_params_set_slack:
      description: The list of key values that are defined for target type **slack**.
      properties:
        url:
          description: The URL to the hook to send the notification to.
          type: string
      required:
      - url
      title: slack
      type: object
    target_params_set_webhook:
      description: The list of key values that are defined for target type **webhook***.
      properties:
        url:
          description: The URL to the hook to send the notification to.
          type: string
      required:
      - url
      title: webhook
      type: object
    target_params_set_sqs:
      description: The list of key values that are defined for target type **webhook***.
      properties:
        destination_app:
          description: "The product code for any license with LOG_SEARCH e.g. OPS,\
            \ IDR."
          type: string
        destination_queue:
          description: The name for the destination queue e.g. IDR_investigation_queue.
            This is not the URL.
          type: string
      required:
      - destination_app
      - destination_queue
      title: sqs
      type: object
    target_params_set_iconworkflow:
      description: InsightConnect Workflow.
      properties:
        workflow_id:
          description: The ID of the basic detection rule trigger type of workflow
            in InsightConnect.
          type: string
      required:
      - workflow_id
      title: insight_connect
      type: object
    target_user_data:
      description: A list of key-value pairs that may indicate some auxiliary information
        about the notification target.
      properties: {}
      type: object
    target_alert_content_set:
      description: The list of key-value pairs to modify the content of the notification.
      example:
        le_trigger_event:
        - le_trigger_event
        - le_trigger_event
        le_context: le_context
      properties:
        le_context:
          description: "When set to \"true\", the log context is set to appear in\
            \ the notification. When set to \"false\", the log context is set to not\
            \ appear in the notification."
          type: string
        le_trigger_event:
          description: "When set to \"true\", the log entry which triggered the alert\
            \ will appear in the notification. When set to \"false\", the log entry\
            \ which triggered the alert will not appear in the notification."
          items:
            description: TODO default missing array inner type to string
            type: string
          type: array
      type: object
    patterns_string_array:
      deprecated: true
      description: Use the `leql` parameter instead of this parameter.
      items:
        type: string
      title: patterns
      type: array
    basic_leql:
      description: "The [LEQL](https://docs.rapid7.com/insightidr/log-search/#write-a-leql-query)\
        \ query used by this pattern detection rule to identify matching log entries."
      example:
        statement: statement
      properties:
        statement:
          description: "The `where()` clause of the [LEQL](https://docs.rapid7.com/insightidr/log-search/#write-a-leql-query)\
            \ query, for example, `where(foo)`. If empty, the query matches all log\
            \ entries."
          type: string
      required:
      - statement
      title: leql
      type: object
    priority_def:
      description: This ensures investigations are ordered by priority in Investigation
        Management. Must be >=0
      type: integer
    tag_user_data:
      description: A list of key-value pairs that may indicate some auxiliary information
        about the change detection rule.
      type: object
    labels_array:
      description: The labels attached to the detection rule.
      items:
        $ref: '#/components/schemas/label_response'
      type: array
    label_response:
      example:
        color: color
        reserved: true
        name: name
        id: id
        sn: 5
      properties:
        id:
          description: The id of the label.
          type: string
        sn:
          description: A property which exists for legacy reasons and is no longer
            used for anything.
          type: integer
        name:
          description: The name of the label.
          type: string
        color:
          description: The color of the label in HEX code.
          type: string
        reserved:
          description: "When set to true, the label is read-only and cannot be modified."
          type: boolean
      required:
      - color
      - id
      - name
      - reserved
      - sn
      type: object
    tag_inactivity_alert_response:
      properties:
        type:
          description: Always set to "AlertNotify".
          type: string
        id:
          description: The unique ID of the detection rule.
          type: string
        name:
          description: The name of the detection rule.
          type: string
        description:
          description: The description of the detection rule.
          type: string
        sources:
          description: The collection of logs the detection rule operates on.
          items:
            $ref: '#/components/schemas/tag_source_response'
          type: array
        actions:
          description: The notifications attached to the detection rule.
          items:
            $ref: '#/components/schemas/action_response_inactivity'
          type: array
        patterns:
          deprecated: true
          description: Use the `leql` parameter instead of this parameter.
          items:
            type: string
          title: patterns
          type: array
        leql:
          $ref: '#/components/schemas/inactivity_leql'
        user_data:
          description: A list of key-value pairs that may indicate some auxiliary
            information about the change detection rule.
          type: object
        timeframe_value:
          description: Defines the duration of inactivity before an alert triggers
            along with the `timeframe_period` parameter.
          type: integer
        timeframe_period:
          $ref: '#/components/schemas/timeframe_period'
        priority:
          description: This ensures investigations are ordered by priority in Investigation
            Management. Must be >=0
          type: integer
        sub_type:
          description: Always set to "InactivityAlert".
          type: string
      title: Inactivity Detection
      type: object
    actions_array_inactivity:
      description: The notifications attached to the detection rule.
      items:
        $ref: '#/components/schemas/action_response_inactivity'
      type: array
    action_response_inactivity:
      properties:
        id:
          description: The ID of the notification.
          type: string
        min_report_count:
          default: 1
          description: "The maximum number of notifications that will be triggered\
            \ within a window of time, controlled by the `min_report_period` parameter."
          type: integer
        min_report_period:
          $ref: '#/components/schemas/period_enum'
        targets:
          description: The list of notification targets for this notification.
          items:
            $ref: '#/components/schemas/target_response'
          type: array
        enabled:
          description: |
            \
            When set to true, the notification is enabled. When set to false, the notification is disabled.
          type: boolean
        type:
          description: Always set to "Alert".
          type: string
      type: object
    inactivity_leql:
      description: "The [LEQL](https://docs.rapid7.com/insightidr/log-search/#write-a-leql-query)\
        \ query used by this inactivity detection rule to identify matching log entries.\
        \ Notifications will be triggered when no matches have been identified for\
        \ the amount of time configured for this detection rule."
      properties:
        statement:
          description: "The `where()` clause of the [LEQL](https://docs.rapid7.com/insightidr/log-search/#write-a-leql-query)\
            \ query, for example, `where(foo)`. If empty, the detection rule matches\
            \ all log entries."
          type: string
      required:
      - statement
      title: leql
      type: object
    timeframe_value:
      description: Defines the duration of inactivity before an alert triggers along
        with the `timeframe_period` parameter.
      type: integer
    timeframe_period:
      description: |
        Defines the unit of time to use along with the `timeframe_value` parameter.
      enum:
      - Week
      - Day
      - Hour
      - Minute
      type: string
    tag_anomaly_alert_response:
      properties:
        type:
          description: Always set to "AlertNotify".
          type: string
        id:
          description: The unique ID of the detection rule.
          type: string
        name:
          description: The name of the detection rule.
          type: string
        description:
          description: The description of the detection rule.
          type: string
        sources:
          description: The collection of logs the detection rule operates on.
          items:
            $ref: '#/components/schemas/tag_source_response'
          type: array
        actions:
          description: The notifications attached to the detection rule.
          items:
            $ref: '#/components/schemas/action_response_anomaly'
          type: array
        patterns:
          deprecated: true
          description: Use the `leql` parameter instead of this parameter.
          items:
            type: string
          title: patterns
          type: array
        user_data:
          description: A list of key-value pairs that may indicate some auxiliary
            information about the change detection rule.
          type: object
        scheduled_query_id:
          description: ID of the scheduled query associated with this change detection
            rule.
          type: string
        sub_type:
          description: Always set to "AnomalyAlert".
          type: string
        scheduled_query:
          $ref: '#/components/schemas/scheduled_query_response'
        threshold_value:
          description: "The percentage that defines when to trigger notifications.\
            \ The percentage can be positive or negative. For example, if the percentage\
            \ is set to -50, then notifications will be triggered when the query result\
            \ for the time range defined by the `time_value` and `time_period` parameters\
            \ is 50% smaller when compared to the same query over the time range defined\
            \ by the `timeframe_value` and `timeframe_period` parameters."
          type: integer
        priority:
          description: This ensures investigations are ordered by priority in Investigation
            Management. Must be >=0
          type: integer
      title: Change Detection
      type: object
    actions_array_anomaly:
      description: The notifications attached to the detection rule.
      items:
        $ref: '#/components/schemas/action_response_anomaly'
      type: array
    action_response_anomaly:
      properties:
        id:
          description: The ID of the notification.
          type: string
        min_report_count:
          default: 1
          description: "The maximum number of notifications that will be triggered\
            \ within a window of time, controlled by the `min_report_period` parameter."
          type: integer
        min_report_period:
          $ref: '#/components/schemas/period_enum'
        targets:
          description: The list of notification targets for this notification.
          items:
            $ref: '#/components/schemas/target_response'
          type: array
        enabled:
          description: |
            \
            When set to true, the notification is enabled. When set to false, the notification is disabled.
          type: boolean
        type:
          description: Always set to "Alert".
          type: string
      type: object
    scheduled_query_id:
      description: ID of the scheduled query associated with this change detection
        rule.
      type: string
    scheduled_query_response:
      description: The configurations for the two queries that are executed at regular
        10-minute intervals. Notifications will be triggered when there is a large
        enough difference between the two (defined by the `threshold_value` parameter).
      properties:
        id:
          description: ID of the scheduled query associated with this change detection
            rule.
          type: string
        name:
          description: The name of the scheduled query.
          type: string
        leql:
          $ref: '#/components/schemas/anomaly_leql'
        time_value:
          description: "Defines the timerange for the two queries, along with the\
            \ `time_period` parameter. \nTwo queries will be run: the timerange of\
            \ the first, more recent query, will end at the current system time; \n\
            the timerange of the older query will end at the current system time minus\
            \ the time specified by the `timeframe_value` & `timeframe_period` parameters.\n"
          type: integer
        time_period:
          description: "Defines the timerange for the two queries, along with the\
            \ `time_value` parameter."
          enum:
          - Week
          - Day
          - Hour
          - Minute
          type: string
        timeframe_value:
          description: "Defines the \"offset\" for the older of the two queries along\
            \ with the `timeframe_period` parameter. For example, if the `timeframe_value`\
            \ is set to 1 and `timeframe_period` is set to `Week`, then the time range\
            \ for the older of the two queries will end at the current system time\
            \ minus 1 week."
          type: integer
        timeframe_period:
          description: "Defines the \"offset\" for the older of the two queries, along\
            \ with the `timeframe_value` parameter."
          enum:
          - Week
          - Day
          - Hour
          - Minute
          type: string
      required:
      - id
      type: object
    anomaly_leql:
      description: "The [LEQL](https://docs.rapid7.com/insightidr/log-search/#write-a-leql-query)\
        \ query used by this change detection rule to compute results."
      properties:
        statement:
          description: "The `where()` clause of the [LEQL](https://docs.rapid7.com/insightidr/log-search/#write-a-leql-query)\
            \ query, for example, `where(foo)`. If empty, the query matches all log\
            \ entries."
          type: string
        function:
          $ref: '#/components/schemas/function_def'
      required:
      - function
      title: leql
      type: object
    function_def:
      properties:
        calculate:
          type: string
      type: object
    threshold_value:
      description: "The percentage that defines when to trigger notifications. The\
        \ percentage can be positive or negative. For example, if the percentage is\
        \ set to -50, then notifications will be triggered when the query result for\
        \ the time range defined by the `time_value` and `time_period` parameters\
        \ is 50% smaller when compared to the same query over the time range defined\
        \ by the `timeframe_value` and `timeframe_period` parameters."
      type: integer
    create_basic_tag:
      properties:
        tag:
          $ref: '#/components/schemas/create_basic_tag_tag'
      title: Pattern Detection
      type: object
    sources_id_array:
      description: The IDs of the logs that the detection rule operates on.
      items:
        $ref: '#/components/schemas/sources_id_array_inner'
      type: array
    create_actions_array:
      description: The notifications attached to the detection rule.
      items:
        $ref: '#/components/schemas/create_tag_action'
      type: array
    create_tag_action:
      properties:
        enabled:
          description: |
            \
            When set to true, the notification is enabled. When set to false, the notification is disabled.
          type: boolean
        min_matches_count:
          default: 0
          description: "The number of log entries that the pattern detection rule\
            \ needs to match for a notification to be triggered (within a window of\
            \ time, controlled by the `min_matches_period` parameter)."
          type: integer
        min_matches_period:
          description: "The time window used in combination with the `min_matches_count`\
            \ parameter to determine if enough log entries have matched a pattern\
            \ detection rule for an alert notification to be sent. For example, if\
            \ `min_matches_count=2`, and `min_matches_period=\"5Minute\"`, then this\
            \ notification will be triggered whenever two log entries match the pattern\
            \ detection rule within 5 minutes."
          type: string
        min_report_count:
          default: 1
          description: "The maximum number of notifications that will be triggered\
            \ within a window of time, controlled by the `min_report_period` parameter."
          type: integer
        min_report_period:
          $ref: '#/components/schemas/period_enum'
        targets:
          description: The list of notification targets for this notification.
          items:
            $ref: '#/components/schemas/create_tag_target'
          type: array
        type:
          description: Always set to "Alert".
          type: string
      required:
      - enabled
      - min_matches_count
      - min_matches_period
      - min_report_count
      - min_report_period
      - targets
      type: object
    create_tag_target:
      properties:
        alert_content_set:
          $ref: '#/components/schemas/target_alert_content_set'
        params_set:
          $ref: '#/components/schemas/target_response_params_set'
        type:
          $ref: '#/components/schemas/notification_type_enum'
      required:
      - params_set
      - type
      type: object
    create_or_put_tag_inactivity_alert:
      properties:
        tag:
          $ref: '#/components/schemas/create_or_put_tag_inactivity_alert_tag'
      title: Inactivity Detection
      type: object
    create_actions_array_inactivity:
      description: The notifications attached to the detection rule.
      items:
        $ref: '#/components/schemas/create_tag_action_inactivity'
      type: array
    create_tag_action_inactivity:
      properties:
        enabled:
          description: |
            \
            When set to true, the notification is enabled. When set to false, the notification is disabled.
          type: boolean
        min_report_count:
          default: 1
          description: "The maximum number of notifications that will be triggered\
            \ within a window of time, controlled by the `min_report_period` parameter."
          type: integer
        min_report_period:
          $ref: '#/components/schemas/period_enum'
        targets:
          description: The list of notification targets for this notification.
          items:
            $ref: '#/components/schemas/create_tag_target'
          type: array
        type:
          description: Always set to "Alert".
          type: string
      required:
      - enabled
      - min_matches_count
      - min_matches_period
      - min_report_count
      - min_report_period
      - targets
      type: object
    create_tag_anomaly_alert:
      properties:
        tag:
          $ref: '#/components/schemas/create_tag_anomaly_alert_tag'
      title: Change Detection
      type: object
    create_actions_array_anomaly:
      description: The notifications attached to the detection rule.
      items:
        $ref: '#/components/schemas/create_tag_action_anomaly'
      type: array
    create_tag_action_anomaly:
      properties:
        enabled:
          description: |
            \
            When set to true, the notification is enabled. When set to false, the notification is disabled.
          type: boolean
        min_report_count:
          default: 1
          description: "The maximum number of notifications that will be triggered\
            \ within a window of time, controlled by the `min_report_period` parameter."
          type: integer
        min_report_period:
          $ref: '#/components/schemas/period_enum'
        targets:
          description: The list of notification targets for this notification.
          items:
            $ref: '#/components/schemas/create_tag_target'
          type: array
        type:
          description: Always set to "Alert".
          type: string
      required:
      - enabled
      - min_matches_count
      - min_matches_period
      - min_report_count
      - min_report_period
      - targets
      type: object
    create_scheduled_query:
      description: The configurations for the two queries that are executed at regular
        10-minute intervals. Notifications will be triggered when there is a large
        enough difference between the two (defined by the `threshold_value` parameter).
      properties:
        name:
          description: The name of the scheduled query.
          type: string
        leql:
          $ref: '#/components/schemas/anomaly_leql'
        time_value:
          description: |
            Defines the time range for the two queries, along with the `time_period` parameter.
            Two queries will run: the time range of the first, more recent query, will end at the current system time;
            the time range of the older query will end at the current system time minus the time specified by the `timeframe_value` and `timeframe_period` parameters.
          type: integer
        time_period:
          description: "Defines the time range for the two queries, along with the\
            \ `time_value` parameter."
          enum:
          - Week
          - Day
          - Hour
          - Minute
          type: string
        timeframe_value:
          description: "Defines the \"offset\" for the older of the two queries along\
            \ with the `timeframe_period` parameter. For example, if the `timeframe_value`\
            \ is set to 1 and `timeframe_period` is set to `Week`, then the time range\
            \ for the older of the two queries will end at the current system time\
            \ minus 1 week."
          type: integer
        timeframe_period:
          description: "Defines the \"offset\" for the older of the two queries, along\
            \ with the `timeframe_value` parameter."
          enum:
          - Week
          - Day
          - Hour
          - Minute
          type: string
      required:
      - leql
      - name
      - time_period
      - time_value
      - timeframe_period
      - timeframe_value
      type: object
    put_basic_tag:
      properties:
        tag:
          $ref: '#/components/schemas/put_basic_tag_tag'
      title: Pattern Detection
      type: object
    put_tag_anomaly_alert:
      properties:
        tag:
          $ref: '#/components/schemas/put_tag_anomaly_alert_tag'
      title: Change Detection
      type: object
    patch_basic_tag:
      properties:
        tag:
          $ref: '#/components/schemas/patch_basic_tag_tag'
      title: Pattern Detection
      type: object
    patch_tag_with_inactivity_alert:
      properties:
        tag:
          $ref: '#/components/schemas/patch_tag_with_inactivity_alert_tag'
      title: Inactivity Detection
      type: object
    patch_tag_with_anomaly_alert:
      properties:
        tag:
          $ref: '#/components/schemas/patch_tag_with_anomaly_alert_tag'
      title: Change Detection
      type: object
    alert_notification_setting:
      description: A notification that may be attached to a basic detection rule.
      example:
        min_matches_count: 0
        min_report_count: 6
        min_report_period: min_report_period
        id: id
        type: type
        min_matches_period: min_matches_period
        targets:
        - alert_content_set:
            le_trigger_event:
            - le_trigger_event
            - le_trigger_event
            le_context: le_context
          name: name
          description: description
          params_set:
            direct: direct
          id: id
          user_data: "{}"
          type: type
        - alert_content_set:
            le_trigger_event:
            - le_trigger_event
            - le_trigger_event
            le_context: le_context
          name: name
          description: description
          params_set:
            direct: direct
          id: id
          user_data: "{}"
          type: type
        enabled: true
      properties:
        id:
          description: The ID of the notification.
          type: string
        min_matches_count:
          default: 0
          description: "The number of log entries that the pattern detection rule\
            \ needs to match for a notification to be triggered (within a window of\
            \ time, controlled by the `min_matches_period` parameter). Only for pattern\
            \ detection rules. This parameter is ignored when used with change detection\
            \ rules or inactivity detection rules."
          type: integer
        min_matches_period:
          description: "The time window used in combination with the `min_matches_count`\
            \ parameter to determine if enough log entries have matched a pattern\
            \ detection rule for an alert notification to be sent. For example, if\
            \ `min_matches_count=2`, and `min_matches_period=\"5Minute\"`, then this\
            \ notification will be triggered whenever two log entries match the pattern\
            \ detection rule within 5 minutes. Only for pattern detection rules. This\
            \ parameter is ignored when used with change detection rules or inactivity\
            \ detection rules."
          type: string
        min_report_count:
          default: 1
          description: "The maximum number of notifications that will be triggered\
            \ within a window of time, controlled by the `min_report_period` parameter."
          type: integer
        min_report_period:
          $ref: '#/components/schemas/period_enum'
        targets:
          description: The list of targets for the action.
          items:
            $ref: '#/components/schemas/target_response'
          type: array
        enabled:
          description: |
            \
            When set to true, the action is enabled. When set to false, the action is disabled.
          type: boolean
        type:
          description: Always set to "Alert".
          type: string
      type: object
    alert_notification_setting_request:
      description: A notification that may be attached to a basic detection rule.
      properties:
        min_matches_count:
          default: 0
          description: "The number of log entries that the pattern detection rule\
            \ needs to match for a notification to be triggered (within a window of\
            \ time, controlled by the `min_matches_period` parameter). Only for pattern\
            \ detection rules. This parameter is ignored when used with change detection\
            \ rules or inactivity detection rules."
          type: integer
        min_matches_period:
          description: "The time window used in combination with the `min_matches_count`\
            \ parameter to determine if enough log entries have matched a pattern\
            \ detection rule for an alert notification to be sent. For example, if\
            \ `min_matches_count=2`, and `min_matches_period=\"5Minute\"`, then this\
            \ notification will be triggered whenever two log entries match the pattern\
            \ detection rule within 5 minutes. Only for pattern detection rules. This\
            \ parameter is ignored when used with change detection rules or inactivity\
            \ detection rules."
          type: string
        min_report_count:
          default: 1
          description: "The maximum number of notifications that will be triggered\
            \ within a window of time, controlled by the `min_report_period` parameter."
          type: integer
        min_report_period:
          $ref: '#/components/schemas/period_enum'
        targets:
          description: The list of targets for the action.
          items:
            $ref: '#/components/schemas/target_response'
          type: array
        enabled:
          description: |
            \
            When set to true, the action is enabled. When set to false, the action is disabled.
          type: boolean
        type:
          description: Always set to "Alert".
          type: string
      required:
      - enabled
      - min_matches_count
      - min_matches_period
      - min_report_count
      - min_report_period
      - targets
      - type
      type: object
    get_target_action:
      example:
        alert_content_set:
          le_trigger_event:
          - le_trigger_event
          - le_trigger_event
          le_context: le_context
        name: name
        description: description
        params_set:
          direct: direct
        user_data: "{}"
        type: type
      properties:
        name:
          description: The name of the notification target.
          type: string
        description:
          description: The description of the notifiaction target.
          type: string
        type:
          $ref: '#/components/schemas/notification_type_enum'
        params_set:
          $ref: '#/components/schemas/target_response_params_set'
        alert_content_set:
          $ref: '#/components/schemas/target_alert_content_set'
        user_data:
          description: A list of key-value pairs that may indicate some auxiliary
            information about the notification target.
          properties: {}
          type: object
      title: target
      type: object
    create_patch_target:
      example:
        alert_content_set:
          le_trigger_event:
          - le_trigger_event
          - le_trigger_event
          le_context: le_context
        name: name
        description: description
        params_set:
          direct: direct
        user_data: "{}"
        type: type
      properties:
        name:
          description: The name of the notification target.
          type: string
        description:
          description: The description of the notification target.
          type: string
        type:
          $ref: '#/components/schemas/notification_type_enum'
        params_set:
          $ref: '#/components/schemas/create_patch_target_params_set'
        alert_content_set:
          $ref: '#/components/schemas/target_alert_content_set'
        user_data:
          description: A list of key-value pairs that may indicate some auxiliary
            information about the notification target.
          properties: {}
          type: object
      required:
      - alert_content_set
      - description
      - name
      - params_set
      - type
      - user_data
      title: target
      type: object
    create_put_target:
      properties:
        target:
          $ref: '#/components/schemas/create_put_target_target'
      title: target
      type: object
    logs_response:
      example:
        logs:
        - logsets_info:
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          name: ""
          structures:
          - structures
          - structures
          tokens:
          - tokens
          - tokens
          source_type: token
          links:
          - rel: rel
            href: href
          - rel: rel
            href: href
          id: id
          ip_address: ip_address
          user_data:
            key: user_data
          token_seed: ""
          retention_period: retention_period
          rrn: rrn
        - logsets_info:
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          name: ""
          structures:
          - structures
          - structures
          tokens:
          - tokens
          - tokens
          source_type: token
          links:
          - rel: rel
            href: href
          - rel: rel
            href: href
          id: id
          ip_address: ip_address
          user_data:
            key: user_data
          token_seed: ""
          retention_period: retention_period
          rrn: rrn
      properties:
        logs:
          items:
            $ref: '#/components/schemas/log_info_response'
          type: array
      required:
      - logs
      type: object
    create_or_put_log:
      properties:
        log:
          $ref: '#/components/schemas/create_or_put_log_log'
      required:
      - log
      type: object
    log_response:
      example:
        logsets_info:
        - name: name
          links:
          - rel: rel
            href: href
          - rel: rel
            href: href
          id: id
          rrn: rrn
        - name: name
          links:
          - rel: rel
            href: href
          - rel: rel
            href: href
          id: id
          rrn: rrn
        name: ""
        structures:
        - structures
        - structures
        tokens:
        - tokens
        - tokens
        source_type: token
        links:
        - rel: rel
          href: href
        - rel: rel
          href: href
        id: id
        ip_address: ip_address
        user_data:
          key: user_data
        token_seed: ""
        retention_period: retention_period
        rrn: rrn
      properties:
        id:
          description: The UUID of the log.
          type: string
        name:
          description: The name of the log.
        tokens:
          description: The log token(s) used for writing to the log. This only applies
            to token type logs (view `source_type` parameter).
          items:
            type: string
          type: array
        structures:
          description: |
            Structures are internal entities which may apply some additional processing to log entries written to this this log.
          items:
            type: string
          type: array
        ip_address:
          description: |
            The IP address that the Log Search system receives log entries from. This only applies to syslog type logs (view the `source_type` parameter).
          type: string
        logsets_info:
          description: |
            The information on each log set that this log is part of.
          items:
            $ref: '#/components/schemas/member_info_inner'
          type: array
        user_data:
          additionalProperties:
            type: string
            x-additionalPropertiesName: <key>
          description: A list of key-values pairs that may indicate some auxiliary
            information about the log.
          type: object
        source_type:
          default: token
          description: |
            A categorization of logs which defines how log entries are received by a server.
            * Syslog type logs are associated with an IP address and a port (the values appear in the `user_data` field). Any log entries received by the server on that port and from that IP address will belong to that log.
            * Token type logs are associated with a log token. Any log entries received by the server on one of the [standard ports](https://docs.rapid7.com/insightops/token-tcp) containing that log token will belong to that log (with the log token removed from the log entry).
            * Internal type logs use internal mechanisms to receive log entries, for example any of the logs in the Internal Logs log set.
          enum:
          - syslog
          - token
          - internal
          type: string
        rrn:
          description: The Rapid7 Resource Name (RRN) of the log. The RRN is a unique
            identifier across the Rapid7 Platform.
          type: string
        token_seed:
          description: The seed used to generate the log token if the log's `source_type`
            is `token`.
        retention_period:
          $ref: '#/components/schemas/retention_period_enum'
        links:
          items:
            $ref: '#/components/schemas/links_inner'
          type: array
      required:
      - id
      - links
      - logsets_info
      - name
      - retention_period
      - rrn
      - source_type
      - structures
      - token_seed
      - tokens
      - user_data
      type: object
    log_topkeys_response:
      example:
        topkeys:
        - weight: 0.8008281904610115
          key: key
        - weight: 0.8008281904610115
          key: key
      properties:
        topkeys:
          description: The list of commonly occurring keys for this log.
          items:
            $ref: '#/components/schemas/log_topkeys_response_topkeys_inner'
          type: array
      required:
      - topkeys
      type: object
    logset_response:
      example:
        logsets:
        - logs_info:
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          name: ""
          description: description
          id: id
          user_data: "{}"
          rrn: ""
        - logs_info:
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          name: ""
          description: description
          id: id
          user_data: "{}"
          rrn: ""
      properties:
        logsets:
          description: |
            A list of the log sets.
          items:
            $ref: '#/components/schemas/logset_info'
          type: array
      title: log set
      type: object
    create_logset:
      properties:
        logset:
          $ref: '#/components/schemas/create_logset_logset'
      title: logset
      type: object
    MetricsResponseList:
      example:
        metrics:
        - metric:
            leql:
              function: function
              statement: statement
            created: created
            retention_secs: 6
            name: ""
            description: ""
            logsets:
            - logs_info:
              - name: name
                links:
                - rel: rel
                  href: href
                - rel: rel
                  href: href
                id: id
                rrn: rrn
              - name: name
                links:
                - rel: rel
                  href: href
                - rel: rel
                  href: href
                id: id
                rrn: rrn
              name: ""
              description: description
              id: id
              user_data: "{}"
              rrn: ""
            - logs_info:
              - name: name
                links:
                - rel: rel
                  href: href
                - rel: rel
                  href: href
                id: id
                rrn: rrn
              - name: name
                links:
                - rel: rel
                  href: href
                - rel: rel
                  href: href
                id: id
                rrn: rrn
              name: ""
              description: description
              id: id
              user_data: "{}"
              rrn: ""
            id: id
            logs:
            - logsets_info:
              - name: name
                links:
                - rel: rel
                  href: href
                - rel: rel
                  href: href
                id: id
                rrn: rrn
              - name: name
                links:
                - rel: rel
                  href: href
                - rel: rel
                  href: href
                id: id
                rrn: rrn
              name: ""
              structures:
              - structures
              - structures
              tokens:
              - tokens
              - tokens
              source_type: token
              links:
              - rel: rel
                href: href
              - rel: rel
                href: href
              id: id
              ip_address: ip_address
              user_data:
                key: user_data
              token_seed: ""
              retention_period: retention_period
              rrn: rrn
            - logsets_info:
              - name: name
                links:
                - rel: rel
                  href: href
                - rel: rel
                  href: href
                id: id
                rrn: rrn
              - name: name
                links:
                - rel: rel
                  href: href
                - rel: rel
                  href: href
                id: id
                rrn: rrn
              name: ""
              structures:
              - structures
              - structures
              tokens:
              - tokens
              - tokens
              source_type: token
              links:
              - rel: rel
                href: href
              - rel: rel
                href: href
              id: id
              ip_address: ip_address
              user_data:
                key: user_data
              token_seed: ""
              retention_period: retention_period
              rrn: rrn
            enabled: ""
            resolution_secs: 0
            enabled_since: enabled_since
        - metric:
            leql:
              function: function
              statement: statement
            created: created
            retention_secs: 6
            name: ""
            description: ""
            logsets:
            - logs_info:
              - name: name
                links:
                - rel: rel
                  href: href
                - rel: rel
                  href: href
                id: id
                rrn: rrn
              - name: name
                links:
                - rel: rel
                  href: href
                - rel: rel
                  href: href
                id: id
                rrn: rrn
              name: ""
              description: description
              id: id
              user_data: "{}"
              rrn: ""
            - logs_info:
              - name: name
                links:
                - rel: rel
                  href: href
                - rel: rel
                  href: href
                id: id
                rrn: rrn
              - name: name
                links:
                - rel: rel
                  href: href
                - rel: rel
                  href: href
                id: id
                rrn: rrn
              name: ""
              description: description
              id: id
              user_data: "{}"
              rrn: ""
            id: id
            logs:
            - logsets_info:
              - name: name
                links:
                - rel: rel
                  href: href
                - rel: rel
                  href: href
                id: id
                rrn: rrn
              - name: name
                links:
                - rel: rel
                  href: href
                - rel: rel
                  href: href
                id: id
                rrn: rrn
              name: ""
              structures:
              - structures
              - structures
              tokens:
              - tokens
              - tokens
              source_type: token
              links:
              - rel: rel
                href: href
              - rel: rel
                href: href
              id: id
              ip_address: ip_address
              user_data:
                key: user_data
              token_seed: ""
              retention_period: retention_period
              rrn: rrn
            - logsets_info:
              - name: name
                links:
                - rel: rel
                  href: href
                - rel: rel
                  href: href
                id: id
                rrn: rrn
              - name: name
                links:
                - rel: rel
                  href: href
                - rel: rel
                  href: href
                id: id
                rrn: rrn
              name: ""
              structures:
              - structures
              - structures
              tokens:
              - tokens
              - tokens
              source_type: token
              links:
              - rel: rel
                href: href
              - rel: rel
                href: href
              id: id
              ip_address: ip_address
              user_data:
                key: user_data
              token_seed: ""
              retention_period: retention_period
              rrn: rrn
            enabled: ""
            resolution_secs: 0
            enabled_since: enabled_since
      properties:
        metrics:
          items:
            $ref: '#/components/schemas/MetricsResponseSingle'
          type: array
      type: object
    MetricsResponseSingle:
      example:
        metric:
          leql:
            function: function
            statement: statement
          created: created
          retention_secs: 6
          name: ""
          description: ""
          logsets:
          - logs_info:
            - name: name
              links:
              - rel: rel
                href: href
              - rel: rel
                href: href
              id: id
              rrn: rrn
            - name: name
              links:
              - rel: rel
                href: href
              - rel: rel
                href: href
              id: id
              rrn: rrn
            name: ""
            description: description
            id: id
            user_data: "{}"
            rrn: ""
          - logs_info:
            - name: name
              links:
              - rel: rel
                href: href
              - rel: rel
                href: href
              id: id
              rrn: rrn
            - name: name
              links:
              - rel: rel
                href: href
              - rel: rel
                href: href
              id: id
              rrn: rrn
            name: ""
            description: description
            id: id
            user_data: "{}"
            rrn: ""
          id: id
          logs:
          - logsets_info:
            - name: name
              links:
              - rel: rel
                href: href
              - rel: rel
                href: href
              id: id
              rrn: rrn
            - name: name
              links:
              - rel: rel
                href: href
              - rel: rel
                href: href
              id: id
              rrn: rrn
            name: ""
            structures:
            - structures
            - structures
            tokens:
            - tokens
            - tokens
            source_type: token
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            ip_address: ip_address
            user_data:
              key: user_data
            token_seed: ""
            retention_period: retention_period
            rrn: rrn
          - logsets_info:
            - name: name
              links:
              - rel: rel
                href: href
              - rel: rel
                href: href
              id: id
              rrn: rrn
            - name: name
              links:
              - rel: rel
                href: href
              - rel: rel
                href: href
              id: id
              rrn: rrn
            name: ""
            structures:
            - structures
            - structures
            tokens:
            - tokens
            - tokens
            source_type: token
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            ip_address: ip_address
            user_data:
              key: user_data
            token_seed: ""
            retention_period: retention_period
            rrn: rrn
          enabled: ""
          resolution_secs: 0
          enabled_since: enabled_since
      properties:
        metric:
          $ref: '#/components/schemas/MetricsResponseSingle_metric'
      type: object
    leql_metrics_endpoints:
      description: The LEQL statement of the pre-computed query.
      example:
        function: function
        statement: statement
      properties:
        statement:
          description: "The 'where' statement of the pre-computed query, for example,\
            \ `\"where(foo>10 AND bar!=0 OR /some_reg[ex]*/)\"`."
          type: string
        function:
          description: |
            The 'calculate' statement of the pre-computed query.
            Possible values:
            * `"calculate(count)"`
            * `"calculate(min: <key>)"`
            * `"calculate(max: <key>)"`
            * `"calculate(sum: <key>)"`
            * `"calculate(average: <key>)"`
            * `"calculate(bytes)"`
          type: string
      type: object
    MetricsInput:
      properties:
        metric:
          $ref: '#/components/schemas/MetricsInput_metric'
      title: Using Log ID(s)
      type: object
    MetricsInputLogsetsById:
      properties:
        metric:
          $ref: '#/components/schemas/MetricsInputLogsetsById_metric'
      title: Using Log Set ID(s)
      type: object
    MetricsInputLogsetsByName:
      properties:
        metric:
          $ref: '#/components/schemas/MetricsInputLogsetsByName_metric'
      title: Using Log Set Name(s)
      type: object
    s3_archiving_setup:
      example:
        s3setup:
          bucket_name: bucket_name
          id: id
          compression: compression
          enabled: true
      properties:
        s3setup:
          $ref: '#/components/schemas/s3_archiving_setup_s3setup'
      type: object
    create_s3_archiving_setup:
      properties:
        s3setup:
          $ref: '#/components/schemas/create_s3_archiving_setup_s3setup'
      type: object
    patch_s3_archiving_setup:
      properties:
        s3setup:
          $ref: '#/components/schemas/patch_s3_archiving_setup_s3setup'
      type: object
    accounts_usage_response:
      example:
        period:
          from: from
          to: to
        daily_usage:
          usage: ""
          day: day
        name: name
        id: id
        period_usage: ""
      properties:
        daily_usage:
          $ref: '#/components/schemas/accounts_usage_response_daily_usage'
        period_usage:
          description: "The total number of bytes written to every log, for the entire\
            \ time range."
          type: int
        period:
          $ref: '#/components/schemas/accounts_usage_response_period'
        id:
          description: The account resource ID (UUID). A unique identifier for your
            organization.
          type: string
        name:
          description: The name of your organization.
          type: string
      type: object
    logs_usage_response:
      example:
        per_day_usage:
          usage_units: usage_units
          period:
            from: from
            to: to
          report_interval: report_interval
          usage:
          - log_usage:
            - usage: ""
              id: id
            - usage: ""
              id: id
            interval: interval
          - log_usage:
            - usage: ""
              id: id
            - usage: ""
              id: id
            interval: interval
      properties:
        per_day_usage:
          $ref: '#/components/schemas/logs_usage_response_per_day_usage'
      type: object
    log_usage_response:
      example:
        usage:
          period:
            from: from
            to: to
          daily_usage:
            usage: ""
            day: day
          id: id
      properties:
        usage:
          $ref: '#/components/schemas/log_usage_response_usage'
      type: object
    export_jobs_response:
      example:
        export_jobs:
        - expires: 1
          created: 0
          percentage: 6
          format: csv
          links:
          - rel: Self
            href: href
          - rel: Self
            href: href
          id: id
          status: Started
        - expires: 1
          created: 0
          percentage: 6
          format: csv
          links:
          - rel: Self
            href: href
          - rel: Self
            href: href
          id: id
          status: Started
      properties:
        export_jobs:
          items:
            $ref: '#/components/schemas/export_job'
          type: array
      required:
      - export_jobs
      type: object
    export_job:
      example:
        expires: 1
        created: 0
        percentage: 6
        format: csv
        links:
        - rel: Self
          href: href
        - rel: Self
          href: href
        id: id
        status: Started
      properties:
        id:
          description: The UUID of the job.
          type: string
        created:
          description: The Unix timestamp of when the job was created in milliseconds.
          type: integer
        format:
          description: The export format. This can only be 'csv'.
          enum:
          - csv
          type: string
        percentage:
          description: The percentage progress of the export job.
          type: integer
        status:
          description: |
            The status of the export job.
              * `Started`: The job has been accepted and registered.
              * `Retrieving`: The query is being executed and the events are being retrieved and streamed to disk.
              * `Converting`: The events are being run through the converter pipeline.
              * `Uploading`: The results are being uploaded to the S3 bucket.
              * `Completed`: The job has been completed and the direct download link is available.
              * `Failed`: The export job has failed. Report this to support for analysis and resolution.
          enum:
          - Started
          - Retrieving
          - Converting
          - Uploading
          - Completed
          - Failed
          type: string
        expires:
          description: The Unix timestamp of when the job result will be deleted.
          type: integer
        links:
          items:
            $ref: '#/components/schemas/export_job_links_inner'
          type: array
      required:
      - created
      - expires
      - format
      - id
      - links
      - percentage
      - status
      type: object
    export_job_response:
      example:
        export_job:
          expires: 1
          created: 0
          percentage: 6
          format: csv
          links:
          - rel: Self
            href: href
          - rel: Self
            href: href
          id: id
          status: Started
      properties:
        export_job:
          $ref: '#/components/schemas/export_job'
      required:
      - export_job
      type: object
    labels_response:
      example:
        labels:
        - color: color
          reserved: true
          name: name
          id: id
          sn: 5
        - color: color
          reserved: true
          name: name
          id: id
          sn: 5
      properties:
        labels:
          description: The labels attached to the detection rule.
          items:
            $ref: '#/components/schemas/label_response'
          type: array
      type: object
    create_label:
      properties:
        label:
          $ref: '#/components/schemas/create_label_label'
      title: label
      type: object
    put_label:
      properties:
        label:
          $ref: '#/components/schemas/create_label_label'
      title: label
      type: object
    patch_label:
      properties:
        label:
          $ref: '#/components/schemas/patch_label_label'
      title: label
      type: object
    search-stats:
      items:
        $ref: '#/components/schemas/search_stats_inner'
      type: array
    audit_log_list:
      description: The list of log sets.
      example:
        logs:
        - logsets_info:
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          name: name
          id: id
          rrn: rrn
        - logsets_info:
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          name: name
          id: id
          rrn: rrn
      properties:
        logs:
          items:
            $ref: '#/components/schemas/audit_log'
          type: array
      type: object
    audit_log:
      description: The object describing a log.
      example:
        logsets_info:
        - name: name
          links:
          - rel: rel
            href: href
          - rel: rel
            href: href
          id: id
          rrn: rrn
        - name: name
          links:
          - rel: rel
            href: href
          - rel: rel
            href: href
          id: id
          rrn: rrn
        name: name
        id: id
        rrn: rrn
      properties:
        id:
          description: The ID of the log.
          type: string
        name:
          description: The name of the log.
          type: string
        rrn:
          description: The Rapid7 Resource Name of the log (unique identifier across
            the Rapid7 Platform).
          type: string
        logsets_info:
          description: |
            The information on each log set that this log is part of.
          items:
            $ref: '#/components/schemas/member_info_inner'
          type: array
      type: object
    audit_log_single:
      description: A single Log.
      example:
        log:
          logsets_info:
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          name: name
          id: id
          rrn: rrn
      properties:
        log:
          $ref: '#/components/schemas/audit_log'
      type: object
    getQueryLogs_200_response:
      oneOf:
      - $ref: '#/components/schemas/EventsResponse'
      - $ref: '#/components/schemas/StatisticalResponse'
    getQueryLogs_202_response:
      oneOf:
      - $ref: '#/components/schemas/EventsContinuation'
      - $ref: '#/components/schemas/StatisticalContinuation'
    postQueryLogs_request:
      example:
        logs:
        - 565c1b7b-c08b-4c87-a42a-ab08bad56071
        - c78579a8-8b20-4e6a-d4c0-5287198a263b
        leql:
          during:
            time_range: last 1 hour
          statement: where(931dde6c60>=800)
      properties:
        logs:
          description: The log keys of the logs which the query is run against.
          example:
          - 565c1b7b-c08b-4c87-a42a-ab08bad56071
          - c78579a8-8b20-4e6a-d4c0-5287198a263b
          items:
            type: string
          type: array
        leql:
          $ref: '#/components/schemas/leql'
      type: object
    pollQuery_200_response:
      oneOf:
      - $ref: '#/components/schemas/EventsContinuation'
      - $ref: '#/components/schemas/EventsResponse'
      - $ref: '#/components/schemas/StatisticalContinuation'
      - $ref: '#/components/schemas/StatisticalResponse'
    listSavedQueries_200_response:
      example:
        saved_queries:
        - leql:
            statement: statement
            during:
              time_range: time_range
              from: 0
              to: 6
          name: name
          id: id
          logs:
          - 565c1b7b-c08b-4c87-a42a-ab08bad56071
          - c78579a8-8b20-4e6a-d4c0-5287198a263b
        - leql:
            statement: statement
            during:
              time_range: time_range
              from: 0
              to: 6
          name: name
          id: id
          logs:
          - 565c1b7b-c08b-4c87-a42a-ab08bad56071
          - c78579a8-8b20-4e6a-d4c0-5287198a263b
      properties:
        saved_queries:
          description: All the saved queries for this account.
          items:
            $ref: '#/components/schemas/saved_query'
          type: array
      type: object
    listVariables_200_response:
      example:
        variables:
        - reserved: false
          created: 2022-10-21T11:51:53.971784
          name: BadIPs
          description: List of banned IP addresses
          id: 123e4567-e89b-12d3-a456-426614174000
          value: "IP(10.0.0.0/8), IP(5.0.0.0/8)"
          userId: 00000000-0000-0000-0000-000000000001
          updated: 2022-10-21T11:51:53.971784
        - reserved: false
          created: 2022-10-21T11:51:53.971784
          name: BadIPs
          description: List of banned IP addresses
          id: 123e4567-e89b-12d3-a456-426614174000
          value: "IP(10.0.0.0/8), IP(5.0.0.0/8)"
          userId: 00000000-0000-0000-0000-000000000001
          updated: 2022-10-21T11:51:53.971784
      properties:
        variables:
          items:
            $ref: '#/components/schemas/leql_variable_response'
          type: array
      type: object
    createVariable_request:
      properties:
        variable:
          $ref: '#/components/schemas/leql_variable_request'
      type: object
    createVariable_201_response:
      example:
        variable:
          reserved: false
          created: 2022-10-21T11:51:53.971784
          name: BadIPs
          description: List of banned IP addresses
          id: 123e4567-e89b-12d3-a456-426614174000
          value: "IP(10.0.0.0/8), IP(5.0.0.0/8)"
          userId: 00000000-0000-0000-0000-000000000001
          updated: 2022-10-21T11:51:53.971784
      properties:
        variable:
          $ref: '#/components/schemas/leql_variable_response'
      type: object
    postLiveLogs_request:
      example:
        logs:
        - 565c1b7b-c08b-4c87-a42a-ab08bad56071
        - c78579a8-8b20-4e6a-d4c0-5287198a263b
        leql:
          statement: where(/f9697e0/)
      properties:
        logs:
          description: The log keys of the logs for the live tail feed.
          example:
          - 565c1b7b-c08b-4c87-a42a-ab08bad56071
          - c78579a8-8b20-4e6a-d4c0-5287198a263b
          items:
            type: string
          type: array
        leql:
          $ref: '#/components/schemas/leql_live_tail'
      required:
      - logs
      type: object
    getManagementTags_200_response_tags_inner:
      oneOf:
      - $ref: '#/components/schemas/basic_tag_response'
      - $ref: '#/components/schemas/tag_inactivity_alert_response'
      - $ref: '#/components/schemas/tag_anomaly_alert_response'
    getManagementTags_200_response:
      example:
        tags:
        - sources:
          - name: name
            stored_days: ""
            id: id
            retention_period: retention_period
            token: token
          - name: name
            stored_days: ""
            id: id
            retention_period: retention_period
            token: token
          leql:
            statement: statement
          patterns:
          - patterns
          - patterns
          name: name
          description: description
          id: id
          user_data: "{}"
          type: type
          priority: 1
          actions:
          - min_matches_count: 0
            min_report_count: 6
            min_report_period: min_report_period
            id: id
            type: type
            min_matches_period: min_matches_period
            targets:
            - alert_content_set:
                le_trigger_event:
                - le_trigger_event
                - le_trigger_event
                le_context: le_context
              name: name
              description: description
              params_set:
                direct: direct
              id: id
              user_data: "{}"
              type: type
            - alert_content_set:
                le_trigger_event:
                - le_trigger_event
                - le_trigger_event
                le_context: le_context
              name: name
              description: description
              params_set:
                direct: direct
              id: id
              user_data: "{}"
              type: type
            enabled: true
          - min_matches_count: 0
            min_report_count: 6
            min_report_period: min_report_period
            id: id
            type: type
            min_matches_period: min_matches_period
            targets:
            - alert_content_set:
                le_trigger_event:
                - le_trigger_event
                - le_trigger_event
                le_context: le_context
              name: name
              description: description
              params_set:
                direct: direct
              id: id
              user_data: "{}"
              type: type
            - alert_content_set:
                le_trigger_event:
                - le_trigger_event
                - le_trigger_event
                le_context: le_context
              name: name
              description: description
              params_set:
                direct: direct
              id: id
              user_data: "{}"
              type: type
            enabled: true
          labels:
          - color: color
            reserved: true
            name: name
            id: id
            sn: 5
          - color: color
            reserved: true
            name: name
            id: id
            sn: 5
        - sources:
          - name: name
            stored_days: ""
            id: id
            retention_period: retention_period
            token: token
          - name: name
            stored_days: ""
            id: id
            retention_period: retention_period
            token: token
          leql:
            statement: statement
          patterns:
          - patterns
          - patterns
          name: name
          description: description
          id: id
          user_data: "{}"
          type: type
          priority: 1
          actions:
          - min_matches_count: 0
            min_report_count: 6
            min_report_period: min_report_period
            id: id
            type: type
            min_matches_period: min_matches_period
            targets:
            - alert_content_set:
                le_trigger_event:
                - le_trigger_event
                - le_trigger_event
                le_context: le_context
              name: name
              description: description
              params_set:
                direct: direct
              id: id
              user_data: "{}"
              type: type
            - alert_content_set:
                le_trigger_event:
                - le_trigger_event
                - le_trigger_event
                le_context: le_context
              name: name
              description: description
              params_set:
                direct: direct
              id: id
              user_data: "{}"
              type: type
            enabled: true
          - min_matches_count: 0
            min_report_count: 6
            min_report_period: min_report_period
            id: id
            type: type
            min_matches_period: min_matches_period
            targets:
            - alert_content_set:
                le_trigger_event:
                - le_trigger_event
                - le_trigger_event
                le_context: le_context
              name: name
              description: description
              params_set:
                direct: direct
              id: id
              user_data: "{}"
              type: type
            - alert_content_set:
                le_trigger_event:
                - le_trigger_event
                - le_trigger_event
                le_context: le_context
              name: name
              description: description
              params_set:
                direct: direct
              id: id
              user_data: "{}"
              type: type
            enabled: true
          labels:
          - color: color
            reserved: true
            name: name
            id: id
            sn: 5
          - color: color
            reserved: true
            name: name
            id: id
            sn: 5
      properties:
        tags:
          description: All the basic detection rules for this account.
          items:
            $ref: '#/components/schemas/getManagementTags_200_response_tags_inner'
          type: array
      type: object
    postManagementTags_request:
      oneOf:
      - $ref: '#/components/schemas/create_basic_tag'
      - $ref: '#/components/schemas/create_or_put_tag_inactivity_alert'
      - $ref: '#/components/schemas/create_tag_anomaly_alert'
    postManagementTags_201_response:
      example:
        tag:
          sources:
          - name: name
            stored_days: ""
            id: id
            retention_period: retention_period
            token: token
          - name: name
            stored_days: ""
            id: id
            retention_period: retention_period
            token: token
          leql:
            statement: statement
          patterns:
          - patterns
          - patterns
          name: name
          description: description
          id: id
          user_data: "{}"
          type: type
          priority: 1
          actions:
          - min_matches_count: 0
            min_report_count: 6
            min_report_period: min_report_period
            id: id
            type: type
            min_matches_period: min_matches_period
            targets:
            - alert_content_set:
                le_trigger_event:
                - le_trigger_event
                - le_trigger_event
                le_context: le_context
              name: name
              description: description
              params_set:
                direct: direct
              id: id
              user_data: "{}"
              type: type
            - alert_content_set:
                le_trigger_event:
                - le_trigger_event
                - le_trigger_event
                le_context: le_context
              name: name
              description: description
              params_set:
                direct: direct
              id: id
              user_data: "{}"
              type: type
            enabled: true
          - min_matches_count: 0
            min_report_count: 6
            min_report_period: min_report_period
            id: id
            type: type
            min_matches_period: min_matches_period
            targets:
            - alert_content_set:
                le_trigger_event:
                - le_trigger_event
                - le_trigger_event
                le_context: le_context
              name: name
              description: description
              params_set:
                direct: direct
              id: id
              user_data: "{}"
              type: type
            - alert_content_set:
                le_trigger_event:
                - le_trigger_event
                - le_trigger_event
                le_context: le_context
              name: name
              description: description
              params_set:
                direct: direct
              id: id
              user_data: "{}"
              type: type
            enabled: true
          labels:
          - color: color
            reserved: true
            name: name
            id: id
            sn: 5
          - color: color
            reserved: true
            name: name
            id: id
            sn: 5
      properties:
        tag:
          $ref: '#/components/schemas/getManagementTags_200_response_tags_inner'
      type: object
    putManagementTagById_request:
      oneOf:
      - $ref: '#/components/schemas/put_basic_tag'
      - $ref: '#/components/schemas/create_or_put_tag_inactivity_alert'
      - $ref: '#/components/schemas/put_tag_anomaly_alert'
    patchManagementTagById_request_tag:
      oneOf:
      - $ref: '#/components/schemas/patch_basic_tag'
      - $ref: '#/components/schemas/patch_tag_with_inactivity_alert'
      - $ref: '#/components/schemas/patch_tag_with_anomaly_alert'
    patchManagementTagById_request:
      properties:
        tag:
          $ref: '#/components/schemas/patchManagementTagById_request_tag'
      type: object
    getManagementAlertNotificationSettings_200_response:
      example:
        actions:
        - min_matches_count: 0
          min_report_count: 6
          min_report_period: min_report_period
          id: id
          type: type
          min_matches_period: min_matches_period
          targets:
          - alert_content_set:
              le_trigger_event:
              - le_trigger_event
              - le_trigger_event
              le_context: le_context
            name: name
            description: description
            params_set:
              direct: direct
            id: id
            user_data: "{}"
            type: type
          - alert_content_set:
              le_trigger_event:
              - le_trigger_event
              - le_trigger_event
              le_context: le_context
            name: name
            description: description
            params_set:
              direct: direct
            id: id
            user_data: "{}"
            type: type
          enabled: true
        - min_matches_count: 0
          min_report_count: 6
          min_report_period: min_report_period
          id: id
          type: type
          min_matches_period: min_matches_period
          targets:
          - alert_content_set:
              le_trigger_event:
              - le_trigger_event
              - le_trigger_event
              le_context: le_context
            name: name
            description: description
            params_set:
              direct: direct
            id: id
            user_data: "{}"
            type: type
          - alert_content_set:
              le_trigger_event:
              - le_trigger_event
              - le_trigger_event
              le_context: le_context
            name: name
            description: description
            params_set:
              direct: direct
            id: id
            user_data: "{}"
            type: type
          enabled: true
      properties:
        actions:
          description: All the notifications for this account that can be attached
            to basic detection rules.
          items:
            $ref: '#/components/schemas/alert_notification_setting'
          type: array
      type: object
    postManagementTagActions_request:
      properties:
        action:
          $ref: '#/components/schemas/alert_notification_setting_request'
      type: object
    postManagementTagActions_201_response:
      example:
        action:
          min_matches_count: 0
          min_report_count: 6
          min_report_period: min_report_period
          id: id
          type: type
          min_matches_period: min_matches_period
          targets:
          - alert_content_set:
              le_trigger_event:
              - le_trigger_event
              - le_trigger_event
              le_context: le_context
            name: name
            description: description
            params_set:
              direct: direct
            id: id
            user_data: "{}"
            type: type
          - alert_content_set:
              le_trigger_event:
              - le_trigger_event
              - le_trigger_event
              le_context: le_context
            name: name
            description: description
            params_set:
              direct: direct
            id: id
            user_data: "{}"
            type: type
          enabled: true
      properties:
        action:
          $ref: '#/components/schemas/alert_notification_setting'
      type: object
    getManagementTagActionTargets_200_response:
      example:
        targets:
        - alert_content_set:
            le_trigger_event:
            - le_trigger_event
            - le_trigger_event
            le_context: le_context
          name: name
          description: description
          params_set:
            direct: direct
          user_data: "{}"
          type: type
        - alert_content_set:
            le_trigger_event:
            - le_trigger_event
            - le_trigger_event
            le_context: le_context
          name: name
          description: description
          params_set:
            direct: direct
          user_data: "{}"
          type: type
      properties:
        targets:
          description: All the notification targets for this account.
          items:
            $ref: '#/components/schemas/get_target_action'
          type: array
      type: object
    patchManagementTagActionTargetById_request:
      example:
        target:
          alert_content_set:
            le_trigger_event:
            - le_trigger_event
            - le_trigger_event
            le_context: le_context
          name: name
          description: description
          params_set:
            direct: direct
          user_data: "{}"
          type: type
      properties:
        target:
          $ref: '#/components/schemas/create_patch_target'
      type: object
    metrics_create_request:
      oneOf:
      - $ref: '#/components/schemas/MetricsInput'
      - $ref: '#/components/schemas/MetricsInputLogsetsById'
      - $ref: '#/components/schemas/MetricsInputLogsetsByName'
    ListEndpointsResponse_value:
      properties:
        path:
          type: string
        verbs:
          items:
            type: string
          type: array
      type: object
      x-additionalPropertiesName: endpoint
    leql_during:
      example:
        time_range: time_range
        from: 0
        to: 6
      properties:
        from:
          description: "The start of the time range for the query, as a UNIX timestamp\
            \ in milliseconds."
          type: integer
        to:
          description: "The end of the time range for the query, as a UNIX timestamp\
            \ in milliseconds."
          type: integer
        time_range:
          description: |
            \
            Relative time range (instead of absolute `from` + `to` time range). Possible values:
            * `yesterday`
            * `today`
            * `last x timeunits` where x is the number of time unit back from the current server time. Supported time units (case insensitive):
                - min(s) or minute(s)
                - hr(s) or hour(s)
                - day(s)
                - week(s)
                - month(s)
                - year(s)
          type: string
      type: object
    labels_inner:
      example:
        links:
        - rel: rel
          href: href
        - rel: rel
          href: href
        id: id
      properties:
        links:
          items:
            $ref: '#/components/schemas/links_inner'
          type: array
        id:
          type: string
      type: object
    links_inner:
      example:
        rel: rel
        href: href
      properties:
        rel:
          type: string
        href:
          type: string
      required:
      - href
      - rel
      type: object
    kvp_info_inner_key:
      example:
        start: 5
        end: 2
        text: text
      properties:
        text:
          description: the identifier of the key.
          type: string
        start:
          description: the position in the log entry of the first character of the
            key (the first character in the log entry is at position 0).
          type: integer
        end:
          description: the position in the log entry of the next character after the
            last character of the key.
          type: integer
      required:
      - end
      - start
      - text
      type: object
    kvp_info_inner_value:
      example:
        start: 7
        end: 9
        text: text
      properties:
        text:
          description: the data associated with the key.
          type: string
        start:
          description: the position in the log entry of the first character of the
            value (first character in the log entry is at position 0).
          type: integer
        end:
          description: the position in the log entry of the next character after the
            last character of the value.
          type: integer
      required:
      - end
      - start
      - text
      type: object
    kvp_info_inner:
      example:
        value:
          start: 7
          end: 9
          text: text
        key:
          start: 5
          end: 2
          text: text
      properties:
        key:
          $ref: '#/components/schemas/kvp_info_inner_key'
        value:
          $ref: '#/components/schemas/kvp_info_inner_value'
      required:
      - key
      - value
      type: object
    query_api_links_inner:
      example:
        rel: rel
        href: href
      properties:
        rel:
          description: |
            If equal to "Self", then href contains a link to poll the in-progress query.
            If equal to "Next", then href contains a link to retrieve the next page of results.
          type: string
        href:
          description: A http link to which a `GET` request can be made.
          type: string
      required:
      - href
      - rel
      type: object
    groups_timeseries_inner_value:
      properties:
        group_timeseries:
          description: "For 'groupby' queries, holds the timeseries object for each\
            \ group."
          items:
            additionalProperties:
              $ref: '#/components/schemas/groups_timeseries_inner_value'
            type: object
          type: array
        series:
          items:
            $ref: '#/components/schemas/stats'
          type: array
        totals:
          $ref: '#/components/schemas/stats'
      required:
      - group_timeseries
      - series
      - totals
      type: object
      x-additionalPropertiesName: <group key>
    create_saved_query_saved_query:
      properties:
        name:
          description: The name for the Saved Query (doesn't need to be unique).
          type: string
        leql:
          $ref: '#/components/schemas/leql'
        logs:
          description: The log keys of the logs which the query is run against.
          example:
          - 565c1b7b-c08b-4c87-a42a-ab08bad56071
          - c78579a8-8b20-4e6a-d4c0-5287198a263b
          items:
            type: string
          type: array
      required:
      - name
      type: object
    patch_saved_query_saved_query:
      properties:
        name:
          description: The name for the Saved Query (doesn't need to be unique).
          type: string
        leql:
          $ref: '#/components/schemas/leql_PATCH'
        logs:
          description: The log keys of the logs which the query is run against.
          example:
          - 565c1b7b-c08b-4c87-a42a-ab08bad56071
          - c78579a8-8b20-4e6a-d4c0-5287198a263b
          items:
            type: string
          type: array
      type: object
    leql_PATCH_during:
      description: The time range for the query. Either absolute or relative to the
        current time.
      properties:
        from:
          description: "The start of the time range for the query, as a UNIX timestamp\
            \ in milliseconds."
          type: integer
        to:
          description: "The end of the time range for the query, as a UNIX timestamp\
            \ in milliseconds."
          type: integer
        time_range:
          description: |
            \
            Relative time range (instead of absolute `from` + `to` time range). Possible values:
            * `yesterday`
            * `today`
            * `last x timeunits` where x is the number of time unit back from the current server time. Supported time units (case insensitive):
                - min(s) or minute(s)
                - hr(s) or hour(s)
                - day(s)
                - week(s)
                - month(s)
                - year(s)
          type: string
      type: object
    leql_context_during:
      example:
        from: 0
        to: 6
      properties:
        from:
          description: The timestamp of the first (earliest) log entry on the current
            page.
          type: integer
        to:
          description: The timestamp of the last (latest) log entry on the current
            page.
          type: integer
      type: object
    context_api_links_inner:
      example:
        rel: rel
        href: href
      properties:
        rel:
          description: |
            If equal to **Self**, then href contains a link to poll the query that's in progress.
            If equal to **Next**, then href contains a link to retrieve the next page of results.
            If equal to **Prev**, then href contains a link to retrieve the previous page of results.
          type: string
        href:
          description: A http link to which a `GET` request can be made.
          type: string
      required:
      - href
      - rel
      type: object
    member_info_inner:
      example:
        name: name
        links:
        - rel: rel
          href: href
        - rel: rel
          href: href
        id: id
        rrn: rrn
      properties:
        id:
          description: The UUID of the log set.
          type: string
        name:
          description: The name of the log set.
          type: string
        rrn:
          description: The Rapid7 Resource Name (RRN) of the Log Set. The RRN is a
            unique identifier across the Rapid7 Platform.
          type: string
        links:
          items:
            $ref: '#/components/schemas/links_inner'
          type: array
      required:
      - id
      - name
      type: object
    member_info_logset_inner:
      example:
        name: name
        links:
        - rel: rel
          href: href
        - rel: rel
          href: href
        id: id
        rrn: rrn
      properties:
        id:
          description: The UUID of the log.
          type: string
        name:
          description: The name of the log.
          type: string
        rrn:
          description: The Rapid7 Resource Name (RRN) of the log. The RRN is a unique
            identifier across the Rapid7 Platform.
          type: string
        links:
          items:
            $ref: '#/components/schemas/links_inner'
          type: array
      required:
      - id
      - name
      type: object
    statistics_metrics_timeseries_inner:
      example:
        time: 6
        value: 1.4658129805029452
      properties:
        time:
          description: The end of the time range that the pre-computed query is applied
            to. The time is displayed as a UNIX timestamp in milliseconds.
          type: integer
        value:
          description: The pre-computed query value for this slice of the time range.
          type: number
      type: object
    target_response_params_set:
      description: The list of key values that are defined depending on the notification
        target type.
      oneOf:
      - $ref: '#/components/schemas/target_params_set_mailto'
      - $ref: '#/components/schemas/target_params_set_pagerduty'
      - $ref: '#/components/schemas/target_params_set_slack'
      - $ref: '#/components/schemas/target_params_set_webhook'
      - $ref: '#/components/schemas/target_params_set_sqs'
      - $ref: '#/components/schemas/target_params_set_iconworkflow'
    create_basic_tag_tag:
      properties:
        name:
          description: The name of the detection rule.
          type: string
        patterns:
          deprecated: true
          description: Use the `leql` parameter instead of this parameter.
          items:
            type: string
          title: patterns
          type: array
        sources:
          description: The IDs of the logs that the detection rule operates on.
          items:
            $ref: '#/components/schemas/sources_id_array_inner'
          type: array
        type:
          description: Always set to "Alert".
          type: string
        description:
          description: The description of the detection rule.
          type: string
        actions:
          description: The notifications attached to the detection rule.
          items:
            $ref: '#/components/schemas/create_tag_action'
          type: array
        labels:
          description: The labels attached to the detection rule.
          items:
            $ref: '#/components/schemas/label_response'
          type: array
        user_data:
          description: A list of key-value pairs that may indicate some auxiliary
            information about the change detection rule.
          type: object
        leql:
          $ref: '#/components/schemas/basic_leql'
        priority:
          description: This ensures investigations are ordered by priority in Investigation
            Management. Must be >=0
          type: integer
      required:
      - leql
      - name
      - sources
      type: object
    sources_id_array_inner:
      properties:
        id:
          description: The UUID of the log.
          type: string
      type: object
    create_or_put_tag_inactivity_alert_tag:
      properties:
        name:
          description: The name of the detection rule.
          type: string
        patterns:
          deprecated: true
          description: Use the `leql` parameter instead of this parameter.
          items:
            type: string
          title: patterns
          type: array
        sources:
          description: The IDs of the logs that the detection rule operates on.
          items:
            $ref: '#/components/schemas/sources_id_array_inner'
          type: array
        type:
          description: The Always set to "AlertNotify".
          type: string
        sub_type:
          description: Always set to "InactivityAlert".
          type: string
        description:
          description: The description of the detection rule.
          type: string
        actions:
          description: The notifications attached to the detection rule.
          items:
            $ref: '#/components/schemas/create_tag_action_inactivity'
          type: array
        user_data:
          description: A list of key-value pairs that may indicate some auxiliary
            information about the change detection rule.
          type: object
        timeframe_value:
          description: Defines the duration of inactivity before an alert triggers
            along with the `timeframe_period` parameter.
          type: integer
        timeframe_period:
          $ref: '#/components/schemas/timeframe_period'
        leql:
          $ref: '#/components/schemas/inactivity_leql'
        priority:
          description: This ensures investigations are ordered by priority in Investigation
            Management. Must be >=0
          type: integer
      required:
      - leql
      - name
      - sources
      - sub_type
      - type
      type: object
    create_tag_anomaly_alert_tag:
      properties:
        name:
          description: The name of the detection rule.
          type: string
        sources:
          description: The IDs of the logs that the detection rule operates on.
          items:
            $ref: '#/components/schemas/sources_id_array_inner'
          type: array
        type:
          description: Always set to "AlertNotify".
          type: string
        sub_type:
          description: Always set to "AnomalyAlert".
          type: string
        description:
          description: The description of the detection rule.
          type: string
        actions:
          description: The notifications attached to the detection rule.
          items:
            $ref: '#/components/schemas/create_tag_action_anomaly'
          type: array
        user_data:
          description: A list of key-value pairs that may indicate some auxiliary
            information about the change detection rule.
          type: object
        scheduled_query:
          $ref: '#/components/schemas/create_scheduled_query'
        threshold_value:
          description: "The percentage that defines when to trigger notifications.\
            \ The percentage can be positive or negative. For example, if the percentage\
            \ is set to -50, then notifications will be triggered when the query result\
            \ for the time range defined by the `time_value` and `time_period` parameters\
            \ is 50% smaller when compared to the same query over the time range defined\
            \ by the `timeframe_value` and `timeframe_period` parameters."
          type: integer
        priority:
          description: This ensures investigations are ordered by priority in Investigation
            Management. Must be >=0
          type: integer
      required:
      - name
      - scheduled_query
      - sources
      - sub_type
      - threshold_value
      - type
      type: object
    put_basic_tag_tag:
      properties:
        name:
          description: The name of the detection rule.
          type: string
        patterns:
          deprecated: true
          description: Use the `leql` parameter instead of this parameter.
          items:
            type: string
          title: patterns
          type: array
        leql:
          $ref: '#/components/schemas/basic_leql'
        sources:
          description: The IDs of the logs that the detection rule operates on.
          items:
            $ref: '#/components/schemas/sources_id_array_inner'
          type: array
        type:
          description: Always set to "Alert".
          type: string
        description:
          description: The description of the detection rule.
          type: string
        actions:
          description: The notifications attached to the detection rule.
          items:
            $ref: '#/components/schemas/create_tag_action'
          type: array
        labels:
          description: The labels attached to the detection rule.
          items:
            $ref: '#/components/schemas/label_response'
          type: array
        user_data:
          description: A list of key-value pairs that may indicate some auxiliary
            information about the change detection rule.
          type: object
        priority:
          description: This ensures investigations are ordered by priority in Investigation
            Management. Must be >=0
          type: integer
      required:
      - leql
      - name
      - sources
      type: object
    put_tag_anomaly_alert_tag:
      properties:
        name:
          description: The name of the detection rule.
          type: string
        sources:
          description: The IDs of the logs that the detection rule operates on.
          items:
            $ref: '#/components/schemas/sources_id_array_inner'
          type: array
        type:
          description: Always set to "AlertNotify".
          type: string
        sub_type:
          description: Always set to "AnomalyAlert".
          type: string
        description:
          description: The description of the detection rule.
          type: string
        actions:
          description: The notifications attached to the detection rule.
          items:
            $ref: '#/components/schemas/create_tag_action_anomaly'
          type: array
        user_data:
          description: A list of key-value pairs that may indicate some auxiliary
            information about the change detection rule.
          type: object
        scheduled_query_id:
          description: ID of the scheduled query associated with this change detection
            rule.
          type: string
        scheduled_query:
          $ref: '#/components/schemas/scheduled_query_response'
        threshold_value:
          description: "The percentage that defines when to trigger notifications.\
            \ The percentage can be positive or negative. For example, if the percentage\
            \ is set to -50, then notifications will be triggered when the query result\
            \ for the time range defined by the `time_value` and `time_period` parameters\
            \ is 50% smaller when compared to the same query over the time range defined\
            \ by the `timeframe_value` and `timeframe_period` parameters."
          type: integer
        priority:
          description: This ensures investigations are ordered by priority in Investigation
            Management. Must be >=0
          type: integer
      required:
      - name
      - scheduled_query
      - sources
      - sub_type
      - threshold_value
      - type
      type: object
    patch_basic_tag_tag:
      properties:
        name:
          description: The name of the detection rule.
          type: string
        patterns:
          deprecated: true
          description: Use the `leql` parameter instead of this parameter.
          items:
            type: string
          title: patterns
          type: array
        leql:
          $ref: '#/components/schemas/basic_leql'
        sources:
          description: The IDs of the logs that the detection rule operates on.
          items:
            $ref: '#/components/schemas/sources_id_array_inner'
          type: array
        type:
          description: Always set to "Alert".
          type: string
        description:
          description: The description of the detection rule.
          type: string
        actions:
          description: The notifications attached to the detection rule.
          items:
            $ref: '#/components/schemas/create_tag_action'
          type: array
        labels:
          description: The labels attached to the detection rule.
          items:
            $ref: '#/components/schemas/label_response'
          type: array
        user_data:
          description: A list of key-value pairs that may indicate some auxiliary
            information about the change detection rule.
          type: object
        priority:
          description: This ensures investigations are ordered by priority in Investigation
            Management. Must be >=0
          type: integer
      type: object
    patch_tag_with_inactivity_alert_tag:
      properties:
        name:
          description: The name of the detection rule.
          type: string
        patterns:
          deprecated: true
          description: Use the `leql` parameter instead of this parameter.
          items:
            type: string
          title: patterns
          type: array
        leql:
          $ref: '#/components/schemas/inactivity_leql'
        sources:
          description: The IDs of the logs that the detection rule operates on.
          items:
            $ref: '#/components/schemas/sources_id_array_inner'
          type: array
        type:
          description: Always set to "AlertNotify".
          type: string
        sub_type:
          description: Always set to "InactivityAlert".
          type: string
        description:
          description: The description of the detection rule.
          type: string
        actions:
          description: The notifications attached to the detection rule.
          items:
            $ref: '#/components/schemas/create_tag_action_inactivity'
          type: array
        user_data:
          description: A list of key-value pairs that may indicate some auxiliary
            information about the change detection rule.
          type: object
        timeframe_value:
          description: Defines the duration of inactivity before an alert triggers
            along with the `timeframe_period` parameter.
          type: integer
        timeframe_period:
          $ref: '#/components/schemas/timeframe_period'
        priority:
          description: This ensures investigations are ordered by priority in Investigation
            Management. Must be >=0
          type: integer
      required:
      - type
      type: object
    patch_tag_with_anomaly_alert_tag:
      properties:
        name:
          description: The name of the detection rule.
          type: string
        sources:
          description: The IDs of the logs that the detection rule operates on.
          items:
            $ref: '#/components/schemas/sources_id_array_inner'
          type: array
        type:
          description: Always set to "AlertNotify".
          type: string
        sub_type:
          description: Always set to "AnomalyAlert".
          type: string
        description:
          description: The description of the detection rule.
          type: string
        actions:
          description: The notifications attached to the detection rule.
          items:
            $ref: '#/components/schemas/create_tag_action_anomaly'
          type: array
        user_data:
          description: A list of key-value pairs that may indicate some auxiliary
            information about the change detection rule.
          type: object
        scheduled_query:
          $ref: '#/components/schemas/create_scheduled_query'
        threshold_value:
          description: "The percentage that defines when to trigger notifications.\
            \ The percentage can be positive or negative. For example, if the percentage\
            \ is set to -50, then notifications will be triggered when the query result\
            \ for the time range defined by the `time_value` and `time_period` parameters\
            \ is 50% smaller when compared to the same query over the time range defined\
            \ by the `timeframe_value` and `timeframe_period` parameters."
          type: integer
        priority:
          description: This ensures investigations are ordered by priority in Investigation
            Management. Must be >=0
          type: integer
      required:
      - type
      type: object
    create_patch_target_params_set:
      description: The list of key values that are defined depending on the target
        type.
      oneOf:
      - $ref: '#/components/schemas/target_params_set_mailto'
      - $ref: '#/components/schemas/target_params_set_pagerduty'
      - $ref: '#/components/schemas/target_params_set_slack'
      - $ref: '#/components/schemas/target_params_set_webhook'
      - $ref: '#/components/schemas/target_params_set_sqs'
      - $ref: '#/components/schemas/target_params_set_iconworkflow'
    create_put_target_target:
      description: |
        This creates a target.
      properties:
        name:
          description: The name of the target.
          type: string
        description:
          description: The description of the target.
          type: string
        type:
          $ref: '#/components/schemas/notification_type_enum'
        params_set:
          $ref: '#/components/schemas/create_patch_target_params_set'
        alert_content_set:
          $ref: '#/components/schemas/target_alert_content_set'
        user_data:
          description: A list of key-value pairs that may indicate some auxiliary
            information about the notification target.
          properties: {}
          type: object
      required:
      - alert_content_set
      - name
      - params_set
      - type
      - user_data
      type: object
    create_or_put_log_log_logsets_info_inner:
      properties:
        id:
          description: The UUID of the log set.
          type: string
        name:
          description: The name of the log set.
          type: string
      required:
      - id
      - name
      type: object
    create_or_put_log_log:
      properties:
        name:
          description: The name of the log.
        tokens:
          description: The log token(s) used for writing to the log. This only applies
            to token type logs (view the `source_type` parameter).
          items:
            type: string
          type: array
        structures:
          description: |
            Structures are internal entities which may apply some additional processing to log entries written to this this log.
          items:
            type: string
          type: array
        ip_address:
          description: The IP address that the Log Search system receives log entries
            from. This only applies to syslog type logs (view the `source_type` parameter).
          type: string
        logsets_info:
          description: |
            The information on each log set that this log is part of.
          items:
            $ref: '#/components/schemas/create_or_put_log_log_logsets_info_inner'
          type: array
        user_data:
          description: A list of key-value pairs that may indicate some auxiliary
            information about the log.
          type: object
        source_type:
          default: token
          description: |
            A categorization of logs that defines how log entries are received by servers.
            * `syslog` type logs are associated with an IP address and a port (the values appear in the `user_data` field). Any log entries received by the server on that port and from that IP address will belong to that log.
            * `token` type logs are associated with a log token. Any log entries received by the server on one of the [standard ports](https://docs.rapid7.com/insightops/token-tcp) containing that log token will belong to that log (with the log token removed from the log entry).
            * `internal` type logs use internal mechanisms to receive log entries, for example any of the logs in the Internal Logs log set.
          enum:
          - syslog
          - token
          - internal
          type: string
        token_seed:
          description: The seed used to generate the log token (for token type logs).
          type: string
      required:
      - name
      type: object
    log_topkeys_response_topkeys_inner:
      example:
        weight: 0.8008281904610115
        key: key
      properties:
        key:
          description: The key.
          type: string
        weight:
          description: The weight to denote the popularity of this key.
          type: number
      required:
      - key
      - weight
      type: object
    create_logset_logset:
      description: The log set.
      properties:
        id:
          description: The UUID of the log set.
          type: string
        name:
          description: The name of the log set.
        description:
          description: The description of the log set.
          type: string
        user_data:
          description: A list of key-value pairs that may indicate some auxiliary
            information about the log set.
          type: object
        logs_info:
          description: |
            Information on each log that this log set contains.
          items:
            $ref: '#/components/schemas/member_info_logset_inner'
          type: array
        token_seed:
          description: The string that will be used in combination with the log set
            name to generate the log set ID.
          type: string
        rrn:
          description: The Rapid7 Resource Name (RRN) of the log set. The RRN is a
            unique identifier across the Rapid7 Platform.
      required:
      - name
      type: object
    MetricsResponseSingle_metric:
      example:
        leql:
          function: function
          statement: statement
        created: created
        retention_secs: 6
        name: ""
        description: ""
        logsets:
        - logs_info:
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          name: ""
          description: description
          id: id
          user_data: "{}"
          rrn: ""
        - logs_info:
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          name: ""
          description: description
          id: id
          user_data: "{}"
          rrn: ""
        id: id
        logs:
        - logsets_info:
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          name: ""
          structures:
          - structures
          - structures
          tokens:
          - tokens
          - tokens
          source_type: token
          links:
          - rel: rel
            href: href
          - rel: rel
            href: href
          id: id
          ip_address: ip_address
          user_data:
            key: user_data
          token_seed: ""
          retention_period: retention_period
          rrn: rrn
        - logsets_info:
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          - name: name
            links:
            - rel: rel
              href: href
            - rel: rel
              href: href
            id: id
            rrn: rrn
          name: ""
          structures:
          - structures
          - structures
          tokens:
          - tokens
          - tokens
          source_type: token
          links:
          - rel: rel
            href: href
          - rel: rel
            href: href
          id: id
          ip_address: ip_address
          user_data:
            key: user_data
          token_seed: ""
          retention_period: retention_period
          rrn: rrn
        enabled: ""
        resolution_secs: 0
        enabled_since: enabled_since
      properties:
        id:
          description: The UUID of the pre-computed query.
          type: string
        name:
          description: The name of the pre-computed query.
          type: String
        description:
          description: The description of the pre-computed query.
          type: String
        enabled:
          description: This indicates whether the pre-computed query is enabled or
            not.
        logs:
          description: The information of the logs used in the pre-computed query.
          items:
            $ref: '#/components/schemas/log_info_response'
          type: array
        logsets:
          description: The information on the log sets used in the pre-computed query.
          items:
            $ref: '#/components/schemas/logset_info'
          type: array
        leql:
          $ref: '#/components/schemas/leql_metrics_endpoints'
        resolution_secs:
          description: "The time window in seconds, that each PCQ datapoint corresponds\
            \ to."
          type: integer
        retention_secs:
          description: "The length of time in seconds, that the PCQ will be stored\
            \ for."
          type: integer
        enabled_since:
          description: The time the PCQ was enabled.
          type: string
        created:
          description: The time the PCQ was created.
          type: string
      type: object
    MetricsInput_metric_logs:
      description: The logs to use in the pre-computed query.
      properties:
        id:
          description: The UUID of the logs.
          type: String
      type: object
    MetricsInput_metric:
      properties:
        name:
          description: The name of the pre-computed query.
          type: String
        description:
          description: The description of the pre-computed query.
          type: String
        enabled:
          description: This indicates whether the pre-computed query is enabled or
            not.
        logs:
          $ref: '#/components/schemas/MetricsInput_metric_logs'
        leql:
          $ref: '#/components/schemas/leql_metrics'
        resolution:
          description: "The time window in seconds, that each PCQ datapoint corresponds\
            \ to."
          type: integer
        retention:
          description: "The length of time in seconds, that the PCQ will be stored\
            \ for."
          type: integer
      type: object
    MetricsInputLogsetsById_metric_logsets:
      description: The log sets to use in the pre-computed query.
      properties:
        id:
          description: The UUID of the log set.
          type: String
      type: object
    MetricsInputLogsetsById_metric:
      properties:
        name:
          description: The name of the pre-computed query.
          type: String
        description:
          description: The description of the pre-computed query.
          type: String
        enabled:
          description: This indicates whether the pre-computed query is enabled or
            not.
        logsets:
          $ref: '#/components/schemas/MetricsInputLogsetsById_metric_logsets'
        leql:
          $ref: '#/components/schemas/leql_metrics_endpoints'
        resolution:
          description: "The time window in seconds, that each PCQ datapoint corresponds\
            \ to."
          type: integer
        retention:
          description: "The length of time in seconds, that the PCQ will be stored\
            \ for."
          type: integer
      type: object
    MetricsInputLogsetsByName_metric_logsets:
      description: The log sets to use in the pre-computed query.
      properties:
        name:
          description: The name of the log set.
          type: String
      type: object
    MetricsInputLogsetsByName_metric:
      properties:
        name:
          description: The name of the pre-computed query.
          type: String
        description:
          description: The description of the pre-computed query.
          type: String
        enabled:
          description: This indicates whether the pre-computed query is enabled or
            not.
        logsets:
          $ref: '#/components/schemas/MetricsInputLogsetsByName_metric_logsets'
        leql:
          $ref: '#/components/schemas/leql_metrics'
        resolution:
          description: "The time window in seconds, that each PCQ datapoint corresponds\
            \ to."
          type: integer
        retention:
          description: "The length of time in seconds, that the PCQ will be stored\
            \ for."
          type: integer
      type: object
    s3_archiving_setup_s3setup:
      example:
        bucket_name: bucket_name
        id: id
        compression: compression
        enabled: true
      properties:
        id:
          description: The unique id of the S3 Archiving Setup.
          type: string
        bucket_name:
          description: The name of the AWS S3 Bucket.
          type: string
        enabled:
          description: Boolean indicating whether the S3 setup is enabled.
          type: boolean
        compression:
          description: The type of compression used for archiving. This is either
            "GZIP" or "BZIP2".
          type: string
      required:
      - bucket_name
      - compression
      - enabled
      - id
      type: object
    create_s3_archiving_setup_s3setup:
      properties:
        bucket_name:
          description: The name of the S3 Bucket.
          type: string
        enabled:
          description: Boolean indicating whether the S3 setup is enabled.
          type: boolean
        compression:
          description: The type of compression used for archiving. This is either
            "GZIP" or "BZIP2".
          type: string
      required:
      - bucket_name
      - compression
      - enabled
      type: object
    patch_s3_archiving_setup_s3setup:
      properties:
        bucket_name:
          description: The name of the S3 Bucket.
          type: string
        enabled:
          description: Boolean indicating whether the S3 setup is enabled.
          type: boolean
        compression:
          description: The type of compression used for archiving. This is either
            "GZIP" or "BZIP2".
          type: string
      type: object
    accounts_usage_response_daily_usage:
      description: The total number of bytes written to every log each day.
      example:
        usage: ""
        day: day
      properties:
        usage:
          description: The number of bytes.
          type: int
        day:
          description: The date in the format "YYYY-MM-DD".
          type: string
    accounts_usage_response_period:
      description: The time range.
      example:
        from: from
        to: to
      properties:
        from:
          description: The start date of the time range in the format "YYYY-MM-DD".
          type: string
        to:
          description: The end date of the time range in the format "YYYY-MM-DD".
          type: string
    logs_usage_response_per_day_usage_usage_inner_log_usage_inner:
      example:
        usage: ""
        id: id
      properties:
        id:
          description: The ID of the log (UUID).
          type: string
        usage:
          description: The total number of bytes written to the log.
          type: int
    logs_usage_response_per_day_usage_usage_inner:
      example:
        log_usage:
        - usage: ""
          id: id
        - usage: ""
          id: id
        interval: interval
      properties:
        interval:
          description: The date in the format "YYYY-MM-DD".
          type: string
        log_usage:
          description: The total number of bytes written to each log.
          items:
            $ref: '#/components/schemas/logs_usage_response_per_day_usage_usage_inner_log_usage_inner'
          type: array
    logs_usage_response_per_day_usage:
      description: The total number of bytes written to each log each day.
      example:
        usage_units: usage_units
        period:
          from: from
          to: to
        report_interval: report_interval
        usage:
        - log_usage:
          - usage: ""
            id: id
          - usage: ""
            id: id
          interval: interval
        - log_usage:
          - usage: ""
            id: id
          - usage: ""
            id: id
          interval: interval
      properties:
        period:
          $ref: '#/components/schemas/accounts_usage_response_period'
        report_interval:
          description: Always set to "day"
          type: string
        usage_units:
          description: Always set to "bytes".
          type: string
        usage:
          description: The total number of bytes written to each log each day.
          items:
            $ref: '#/components/schemas/logs_usage_response_per_day_usage_usage_inner'
          type: array
      type: object
    log_usage_response_usage_daily_usage:
      description: The total number of bytes written to each log each day.
      example:
        usage: ""
        day: day
      properties:
        usage:
          description: The total number of bytes written to the log.
          type: ints
        day:
          description: The date in the format "YYYY-MM-DD".
          type: string
    log_usage_response_usage:
      description: The total number of bytes written to the log each day.
      example:
        period:
          from: from
          to: to
        daily_usage:
          usage: ""
          day: day
        id: id
      properties:
        id:
          description: The ID of the log (UUID).
          type: string
        period:
          $ref: '#/components/schemas/accounts_usage_response_period'
        daily_usage:
          $ref: '#/components/schemas/log_usage_response_usage_daily_usage'
      type: object
    export_job_links_inner:
      example:
        rel: Self
        href: href
      properties:
        rel:
          enum:
          - Self
          - Download
          type: string
        href:
          type: string
      required:
      - href
      - rel
      type: object
    create_label_label:
      description: The created label.
      properties:
        name:
          description: The name of the label.
          type: string
        color:
          description: The color of the label in HEX code.
          type: string
      required:
      - color
      - name
      type: object
    patch_label_label:
      description: The created label.
      properties:
        name:
          description: The name of the label.
          type: string
        color:
          description: The color of the label in HEX code.
          type: string
      type: object
    search_stats_inner_leql:
      description: "The LEQL statement of the query, along with the time range."
      example:
        statement: statement
        num_of_logs: 5
        from: 6
        to: 1
      properties:
        statement:
          description: "The LEQL query run against the log(s), for example, `where(foo>10\
            \ AND bar!=0 OR /some_reg[ex]*/)`. If empty, the query retrieves all log\
            \ entries in the specified time range."
          type: string
        from:
          description: "The start of the time range for the query, as a UNIX timestamp\
            \ in milliseconds."
          type: integer
        to:
          description: "The end of the time range for the query, as a UNIX timestamp\
            \ in milliseconds."
          type: integer
        num_of_logs:
          description: The number of logs searched by this query.
          type: integer
    search_stats_inner_statistics:
      example:
        duration_ms: 5
        bytes_all: 2
        bytes_checked: 7
        events_checked: 3
        events_all: 9
        events_matched: 2
      properties:
        duration_ms:
          description: "The time taken to complete the query, in milliseconds."
          type: integer
        bytes_all:
          description: The total amount of log data queried in bytes.
          type: integer
        bytes_checked:
          description: The amount of log data that was scanned by this query in bytes.
            This amount may be much less than the total amount of log data that is
            queried. This is a result of data indexing performed by Log Search when
            the LEQL statement matches a small subset of the data.
          type: integer
        events_all:
          description: The total number of log entries queried.
          type: integer
        events_checked:
          description: The number of log entries that were scanned by this query.
            This amount may be much less than the total amount of log data that is
            queried. This is a result of data indexing performed by Log Search when
            the LEQL statement matches a small subset of the data.
          type: integer
        events_matched:
          description: The number of log entries that matched the LEQL statement of
            the query.
          type: integer
    search_stats_inner:
      example:
        date: 0
        query_id: query_id
        leql:
          statement: statement
          num_of_logs: 5
          from: 6
          to: 1
        source: source
        statistics:
          duration_ms: 5
          bytes_all: 2
          bytes_checked: 7
          events_checked: 3
          events_all: 9
          events_matched: 2
      properties:
        query_id:
          description: The unique ID of the query.
          type: string
        date:
          description: "The date when the query was started, as a UNIX timestamp in\
            \ milliseconds."
          type: integer
        source:
          description: "May contain some information on the source of the query. For\
            \ example, if the value is `\"dashboard\"`, then the query was launched\
            \ by a Log Search dashboard rather than explicitly by a user through the\
            \ Log Search UI."
          type: string
        leql:
          $ref: '#/components/schemas/search_stats_inner_leql'
        statistics:
          $ref: '#/components/schemas/search_stats_inner_statistics'
      type: object
  securitySchemes:
    Api Key Authentication:
      description: |
        There are three categories for API Keys:
          * Read-Only
          * Read-Write
          * Admin

        They can be created on the [API Keys Management](https://docs.rapid7.com/insight/managing-platform-api-keys) page of your Insight Platform account. Make sure to copy the key afterwards because you
        will not be able to view it again.
      in: header
      name: x-api-key
      type: apiKey
