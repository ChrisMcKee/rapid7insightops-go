/*
InsightOps REST API

### Overview  Our REST API lets you use InsightOps through HTTP requests. Currently, the REST API allows you to perform the majority of the actions available through the UI, and has some additional functionality that is not available through the UI. You may use this API to automate common tasks (for example, via shell scripts), and to generally interact with InsightOps programmatically.  This page precisely describes the REST API and serves as a reference for the API. Each HTTP method and each URL endpoint is documented in a self-contained unit so that users only need to read about the HTTP methods relevant to them.  ### Terminology  * A **log entry** is an individual log event. * A **log** is a collection of log entries, or a single log stream. * A **log set** is a logical-only collection of logs, i.e. logs can be in multiple logsets and deleting a logset only deletes the relation between logs, not the logs themselves. * [Log Entry Query Language](https://docs.rapid7.com/insightops/log-search) (**LEQL**) is the query language used in Insight Ops to search log data.

API version: latest
Contact: support@rapid7.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package insightops

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// ExploreTheSizeOfYourLogDataAPIService ExploreTheSizeOfYourLogDataAPI service
type ExploreTheSizeOfYourLogDataAPIService service

type ApiGetOrganizationsLogUsageRequest struct {
	ctx        context.Context
	ApiService *ExploreTheSizeOfYourLogDataAPIService
	logKey     string
	from       *string
	to         *string
}

// \\ The start of the time range as a string in the format \&quot;YYYY-MM-DD\&quot;.
func (r ApiGetOrganizationsLogUsageRequest) From(from string) ApiGetOrganizationsLogUsageRequest {
	r.from = &from
	return r
}

// \\ The end of the time range as a string in the format \&quot;YYYY-MM-DD\&quot;.
func (r ApiGetOrganizationsLogUsageRequest) To(to string) ApiGetOrganizationsLogUsageRequest {
	r.to = &to
	return r
}

func (r ApiGetOrganizationsLogUsageRequest) Execute() (*LogUsageResponse, *http.Response, error) {
	return r.ApiService.GetOrganizationsLogUsageExecute(r)
}

/*
GetOrganizationsLogUsage Data Size For a Specific Log

Returns the total number bytes written to the specified log for each day in the specified time range. The timerange must be within the last 30 days.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param logKey \\ The key of the log to be queried.
	@return ApiGetOrganizationsLogUsageRequest
*/
func (a *ExploreTheSizeOfYourLogDataAPIService) GetOrganizationsLogUsage(ctx context.Context, logKey string) ApiGetOrganizationsLogUsageRequest {
	return ApiGetOrganizationsLogUsageRequest{
		ApiService: a,
		ctx:        ctx,
		logKey:     logKey,
	}
}

// Execute executes the request
//
//	@return LogUsageResponse
func (a *ExploreTheSizeOfYourLogDataAPIService) GetOrganizationsLogUsageExecute(r ApiGetOrganizationsLogUsageRequest) (*LogUsageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LogUsageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExploreTheSizeOfYourLogDataAPIService.GetOrganizationsLogUsage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/usage/organizations/logs/{log_key}"
	localVarPath = strings.Replace(localVarPath, "{"+"log key"+"}", url.PathEscape(parameterValueTostring(r.logKey, "logKey")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.from == nil {
		return localVarReturnValue, nil, reportError("from is required and must be specified")
	}
	if r.to == nil {
		return localVarReturnValue, nil, reportError("to is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrganizationsLogsUsageRequest struct {
	ctx        context.Context
	ApiService *ExploreTheSizeOfYourLogDataAPIService
	from       *string
	to         *string
	timeRange  *string
}

// \\ The start of the time range as a string in the format \&quot;YYYY-MM-DD\&quot;.
func (r ApiGetOrganizationsLogsUsageRequest) From(from string) ApiGetOrganizationsLogsUsageRequest {
	r.from = &from
	return r
}

// \\ The end of the time range as a string in the format \&quot;YYYY-MM-DD\&quot;.
func (r ApiGetOrganizationsLogsUsageRequest) To(to string) ApiGetOrganizationsLogsUsageRequest {
	r.to = &to
	return r
}

// \\ An alternative to the &#x60;from&#x60; and &#x60;to&#x60; query parameters. Supported values: * &#x60;yesterday&#x60; * &#x60;today&#x60; * &#x60;last x timeunits&#x60; where x is the number of time unit back from the current server time. Supported time units (case insensitive):     - min(s) or minute(s)     - hr(s) or hour(s)     - day(s)     - week(s)     - month(s)     - year(s)  If &#x60;time_range&#x60; is used, then the &#x60;from&#x60; and &#x60;to&#x60; query parameters must not be used.
func (r ApiGetOrganizationsLogsUsageRequest) TimeRange(timeRange string) ApiGetOrganizationsLogsUsageRequest {
	r.timeRange = &timeRange
	return r
}

func (r ApiGetOrganizationsLogsUsageRequest) Execute() (*LogsUsageResponse, *http.Response, error) {
	return r.ApiService.GetOrganizationsLogsUsageExecute(r)
}

/*
GetOrganizationsLogsUsage Data Size Broken Down By Log

Returns the total number bytes written to each log in your account for each day in the specified time range. The timerange must be within the last 30 days.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetOrganizationsLogsUsageRequest
*/
func (a *ExploreTheSizeOfYourLogDataAPIService) GetOrganizationsLogsUsage(ctx context.Context) ApiGetOrganizationsLogsUsageRequest {
	return ApiGetOrganizationsLogsUsageRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return LogsUsageResponse
func (a *ExploreTheSizeOfYourLogDataAPIService) GetOrganizationsLogsUsageExecute(r ApiGetOrganizationsLogsUsageRequest) (*LogsUsageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LogsUsageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExploreTheSizeOfYourLogDataAPIService.GetOrganizationsLogsUsage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/usage/organizations/logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.from == nil {
		return localVarReturnValue, nil, reportError("from is required and must be specified")
	}
	if r.to == nil {
		return localVarReturnValue, nil, reportError("to is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "", "")
	if r.timeRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_range", r.timeRange, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrganizationsUsageRequest struct {
	ctx        context.Context
	ApiService *ExploreTheSizeOfYourLogDataAPIService
	from       *string
	to         *string
}

// \\ The start of the time range as a string in the format \&quot;YYYY-MM-DD\&quot;.
func (r ApiGetOrganizationsUsageRequest) From(from string) ApiGetOrganizationsUsageRequest {
	r.from = &from
	return r
}

// \\ The end of the time range as a string in the format \&quot;YYYY-MM-DD\&quot;.
func (r ApiGetOrganizationsUsageRequest) To(to string) ApiGetOrganizationsUsageRequest {
	r.to = &to
	return r
}

func (r ApiGetOrganizationsUsageRequest) Execute() (*AccountsUsageResponse, *http.Response, error) {
	return r.ApiService.GetOrganizationsUsageExecute(r)
}

/*
GetOrganizationsUsage Total Data Size Across All Logs

Returns the total number bytes written to every log in your account for the specified time range (including logs that may have been deleted since that time). There is no restriction on the timerange.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetOrganizationsUsageRequest
*/
func (a *ExploreTheSizeOfYourLogDataAPIService) GetOrganizationsUsage(ctx context.Context) ApiGetOrganizationsUsageRequest {
	return ApiGetOrganizationsUsageRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AccountsUsageResponse
func (a *ExploreTheSizeOfYourLogDataAPIService) GetOrganizationsUsageExecute(r ApiGetOrganizationsUsageRequest) (*AccountsUsageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AccountsUsageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExploreTheSizeOfYourLogDataAPIService.GetOrganizationsUsage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/usage/organizations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.from == nil {
		return localVarReturnValue, nil, reportError("from is required and must be specified")
	}
	if r.to == nil {
		return localVarReturnValue, nil, reportError("to is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
