/*
InsightOps REST API

### Overview  Our REST API lets you use InsightOps through HTTP requests. Currently, the REST API allows you to perform the majority of the actions available through the UI, and has some additional functionality that is not available through the UI. You may use this API to automate common tasks (for example, via shell scripts), and to generally interact with InsightOps programmatically.  This page precisely describes the REST API and serves as a reference for the API. Each HTTP method and each URL endpoint is documented in a self-contained unit so that users only need to read about the HTTP methods relevant to them.  ### Terminology  * A **log entry** is an individual log event. * A **log** is a collection of log entries, or a single log stream. * A **log set** is a logical-only collection of logs, i.e. logs can be in multiple logsets and deleting a logset only deletes the relation between logs, not the logs themselves. * [Log Entry Query Language](https://docs.rapid7.com/insightops/log-search) (**LEQL**) is the query language used in Insight Ops to search log data.

API version: latest
Contact: support@rapid7.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package insightops

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// DownloadLogDataAPIService DownloadLogDataAPI service
type DownloadLogDataAPIService service

type ApiGetDownloadLogsRequest struct {
	ctx        context.Context
	ApiService *DownloadLogDataAPIService
	ids        string
	from       *int32
	to         *int32
	timeRange  *string
	query      *string
	limit      *int32
}

// \\ The start of the time range for the query, as a UNIX timestamp in milliseconds.
func (r ApiGetDownloadLogsRequest) From(from int32) ApiGetDownloadLogsRequest {
	r.from = &from
	return r
}

// \\ The end of the time range for the query, as a UNIX timestamp in milliseconds.
func (r ApiGetDownloadLogsRequest) To(to int32) ApiGetDownloadLogsRequest {
	r.to = &to
	return r
}

// \\ An alternative to the &#x60;from&#x60; and &#x60;to&#x60; query parameters. Supported values: * &#x60;yesterday&#x60; * &#x60;today&#x60; * &#x60;last x timeunits&#x60; where x is the number of time unit back from the current server time. Supported time units (case insensitive):     - min(s) or minute(s)     - hr(s) or hour(s)     - day(s)     - week(s)     - month(s)     - year(s)  If &#x60;time_range&#x60; is used, then the &#x60;from&#x60; and &#x60;to&#x60; query parameters must not be used.
func (r ApiGetDownloadLogsRequest) TimeRange(timeRange string) ApiGetDownloadLogsRequest {
	r.timeRange = &timeRange
	return r
}

// \\ A valid LEQL query to run against the log. If omitted, the query retrieves all log entries in the specified time range.
func (r ApiGetDownloadLogsRequest) Query(query string) ApiGetDownloadLogsRequest {
	r.query = &query
	return r
}

// \\ The maximum, and default, number of log entries to download is 500,000,000 log entries. You can specify this parameter to limit the number of log entries in the download.
func (r ApiGetDownloadLogsRequest) Limit(limit int32) ApiGetDownloadLogsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetDownloadLogsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetDownloadLogsExecute(r)
}

/*
GetDownloadLogs Download Log Data

Returns the raw log entries in the response body. Each log entry is on a new line.
Data can be downloaded from a maximum of 10 Logs per download request.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param ids \\ The UUIDs of the logs separated by colons \":\" or semicolons \";\". For example \"UUID1:UUID2:UUID3\" or \"UUID1;UUID2;UUID3\".
	@return ApiGetDownloadLogsRequest
*/
func (a *DownloadLogDataAPIService) GetDownloadLogs(ctx context.Context, ids string) ApiGetDownloadLogsRequest {
	return ApiGetDownloadLogsRequest{
		ApiService: a,
		ctx:        ctx,
		ids:        ids,
	}
}

// Execute executes the request
func (a *DownloadLogDataAPIService) GetDownloadLogsExecute(r ApiGetDownloadLogsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DownloadLogDataAPIService.GetDownloadLogs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/download/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"ids"+"}", url.PathEscape(parameterValueTostring(r.ids, "ids")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.from == nil {
		return nil, reportError("from is required and must be specified")
	}
	if r.to == nil {
		return nil, reportError("to is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "", "")
	if r.timeRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_range", r.timeRange, "", "")
	}
	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
