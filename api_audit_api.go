/*
InsightOps REST API

### Overview  Our REST API lets you use InsightOps through HTTP requests. Currently, the REST API allows you to perform the majority of the actions available through the UI, and has some additional functionality that is not available through the UI. You may use this API to automate common tasks (for example, via shell scripts), and to generally interact with InsightOps programmatically.  This page precisely describes the REST API and serves as a reference for the API. Each HTTP method and each URL endpoint is documented in a self-contained unit so that users only need to read about the HTTP methods relevant to them.  ### Terminology  * A **log entry** is an individual log event. * A **log** is a collection of log entries, or a single log stream. * A **log set** is a logical-only collection of logs, i.e. logs can be in multiple logsets and deleting a logset only deletes the relation between logs, not the logs themselves. * [Log Entry Query Language](https://docs.rapid7.com/insightops/log-search) (**LEQL**) is the query language used in Insight Ops to search log data.

API version: latest
Contact: support@rapid7.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package insightops

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// AuditAPIAPIService AuditAPIAPI service
type AuditAPIAPIService service

type ApiAuditGetExportJobRequest struct {
	ctx        context.Context
	ApiService *AuditAPIAPIService
	id         *string
}

// \\ The UUID of the export job.
func (r ApiAuditGetExportJobRequest) Id(id string) ApiAuditGetExportJobRequest {
	r.id = &id
	return r
}

func (r ApiAuditGetExportJobRequest) Execute() (*ExportJobResponse, *http.Response, error) {
	return r.ApiService.AuditGetExportJobExecute(r)
}

/*
AuditGetExportJob Retrieve An Export Job By Id

This endpoint is available as a convenient way to search for audit logs. It operates the same way as the [/exports/{id}](#operation/getExportJob) endpoints, which can be used to search for both audit logs and regular logs.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAuditGetExportJobRequest
*/
func (a *AuditAPIAPIService) AuditGetExportJob(ctx context.Context) ApiAuditGetExportJobRequest {
	return ApiAuditGetExportJobRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ExportJobResponse
func (a *AuditAPIAPIService) AuditGetExportJobExecute(r ApiAuditGetExportJobRequest) (*ExportJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExportJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuditAPIAPIService.AuditGetExportJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audit/exports/{id}"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuditGetExportJobsRequest struct {
	ctx        context.Context
	ApiService *AuditAPIAPIService
}

func (r ApiAuditGetExportJobsRequest) Execute() (*ExportJobsResponse, *http.Response, error) {
	return r.ApiService.AuditGetExportJobsExecute(r)
}

/*
AuditGetExportJobs Retrieve All Export Jobs

This endpoint is available as a convenient way to search for audit logs. It operates the same way as the [/exports](#operation/getExportJobs) endpoints, which can be used to search for both audit logs and regular logs.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAuditGetExportJobsRequest
*/
func (a *AuditAPIAPIService) AuditGetExportJobs(ctx context.Context) ApiAuditGetExportJobsRequest {
	return ApiAuditGetExportJobsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ExportJobsResponse
func (a *AuditAPIAPIService) AuditGetExportJobsExecute(r ApiAuditGetExportJobsRequest) (*ExportJobsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ExportJobsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuditAPIAPIService.AuditGetExportJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audit/exports"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuditGetQueryEndpointsRequest struct {
	ctx        context.Context
	ApiService *AuditAPIAPIService
}

func (r ApiAuditGetQueryEndpointsRequest) Execute() (*map[string]ListEndpointsResponseValue, *http.Response, error) {
	return r.ApiService.AuditGetQueryEndpointsExecute(r)
}

/*
AuditGetQueryEndpoints List All Endpoints

This endpoint is available as a convenient way to search for audit logs. It operates the same way as the [/query](#operation/getQueryEndpoints) endpoints, which can be used to search for both audit logs and regular logs.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAuditGetQueryEndpointsRequest
*/
func (a *AuditAPIAPIService) AuditGetQueryEndpoints(ctx context.Context) ApiAuditGetQueryEndpointsRequest {
	return ApiAuditGetQueryEndpointsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]ListEndpointsResponseValue
func (a *AuditAPIAPIService) AuditGetQueryEndpointsExecute(r ApiAuditGetQueryEndpointsRequest) (*map[string]ListEndpointsResponseValue, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *map[string]ListEndpointsResponseValue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuditAPIAPIService.AuditGetQueryEndpoints")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audit/query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuditGetQueryLogsRequest struct {
	ctx             context.Context
	ApiService      *AuditAPIAPIService
	logKeys         string
	from            *int32
	to              *int32
	query           *string
	timeRange       *string
	label           *string
	labels          *string
	perPage         *int32
	exportFormat    *string
	kvpInfo         *bool
	mostRecentFirst *bool
	sequenceNumber  *int32
}

// \\ The start of the time range for the query, as a UNIX timestamp in milliseconds.
func (r ApiAuditGetQueryLogsRequest) From(from int32) ApiAuditGetQueryLogsRequest {
	r.from = &from
	return r
}

// \\ The end of the time range for the query, as a UNIX timestamp in milliseconds.
func (r ApiAuditGetQueryLogsRequest) To(to int32) ApiAuditGetQueryLogsRequest {
	r.to = &to
	return r
}

// \\ A valid LEQL query to run against the log. If omitted, the query retrieves all log entries in the specified time range.
func (r ApiAuditGetQueryLogsRequest) Query(query string) ApiAuditGetQueryLogsRequest {
	r.query = &query
	return r
}

// \\ An alternative to the &#x60;from&#x60; and &#x60;to&#x60; query parameters. Supported values: * &#x60;yesterday&#x60; * &#x60;today&#x60; * &#x60;last x timeunits&#x60; where x is the number of time unit back from the current server time. Supported time units (case insensitive):     - min(s) or minute(s)     - hr(s) or hour(s)     - day(s)     - week(s)     - month(s)     - year(s)  If &#x60;time_range&#x60; is used, then the &#x60;from&#x60; and &#x60;to&#x60; query parameters must not be used.
func (r ApiAuditGetQueryLogsRequest) TimeRange(timeRange string) ApiAuditGetQueryLogsRequest {
	r.timeRange = &timeRange
	return r
}

// \\ Only entries which have a label with this UUID will be returned. This only works with non-statistical queries (i.e. no &#39;groupby&#39; or &#39;calculate&#39; clauses).
func (r ApiAuditGetQueryLogsRequest) Label(label string) ApiAuditGetQueryLogsRequest {
	r.label = &label
	return r
}

// \\ A set of &#39;:&#39; separated label UUIDs. Only entries which have a label matching one of these UUIDs will be returned. This only works with non-statistical queries (i.e. no &#39;groupby&#39; or &#39;calculate&#39; clauses). Takes precedence over the &#39;label&#39; parameter.
func (r ApiAuditGetQueryLogsRequest) Labels(labels string) ApiAuditGetQueryLogsRequest {
	r.labels = &labels
	return r
}

// \\ Number of log entries to return per page, up to 500(the maximum allowed).
func (r ApiAuditGetQueryLogsRequest) PerPage(perPage int32) ApiAuditGetQueryLogsRequest {
	r.perPage = &perPage
	return r
}

// \\ If included, the query results will be exported to the given format.  * Currently only &#x60;csv&#x60; is supported. * This parameter is only for non-statistical search queries (i.e. no &#39;calculate&#39; and/or &#39;groupby&#39; clauses). * Results are limited to the first 1 million log entries, and only one export job may run per account at a time.  The response will be a 202, and the response body will contain a link for polling the export job (on the **_/exports/{id}** endpoint).
func (r ApiAuditGetQueryLogsRequest) ExportFormat(exportFormat string) ApiAuditGetQueryLogsRequest {
	r.exportFormat = &exportFormat
	return r
}

// \\ When set to true, the &#x60;events&#x60; object that is returned will additionally contain information about all the key-value pairs in each returned log entry.
func (r ApiAuditGetQueryLogsRequest) KvpInfo(kvpInfo bool) ApiAuditGetQueryLogsRequest {
	r.kvpInfo = &kvpInfo
	return r
}

// \\ When set to &#x60;true&#x60;, the query returns the most recent events first. When set to &#x60;false&#x60;, it returns the oldest events first.
func (r ApiAuditGetQueryLogsRequest) MostRecentFirst(mostRecentFirst bool) ApiAuditGetQueryLogsRequest {
	r.mostRecentFirst = &mostRecentFirst
	return r
}

// \\ If this query parameter is included, the query results will additionally include all log entries received in the &#x60;from&#x60; millisecond which have sequence numbers larger than the one specified.  Sequence numbers are identifiers used to distinguish between log entries received in the same millisecond. If a log entry was split up into several log entries during ingestion, then those chunks are ordered by sequence number.
func (r ApiAuditGetQueryLogsRequest) SequenceNumber(sequenceNumber int32) ApiAuditGetQueryLogsRequest {
	r.sequenceNumber = &sequenceNumber
	return r
}

func (r ApiAuditGetQueryLogsRequest) Execute() (*GetQueryLogs200Response, *http.Response, error) {
	return r.ApiService.AuditGetQueryLogsExecute(r)
}

/*
AuditGetQueryLogs Query Individual Logs Using LEQL

This endpoint is available as a convenient way to search for audit logs. It operates the same way as the [/query/logs/{log_keys}](#operation/getQueryLogs) endpoints, which can be used to search for both audit logs and regular logs.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param logKeys \\ The key of the log to be queried.  Supplying multiple ':' separated log keys is deprecated; users should instead 'POST' the query as a JSON payload to [/query/logs](#operation/postQueryLogs).
	@return ApiAuditGetQueryLogsRequest
*/
func (a *AuditAPIAPIService) AuditGetQueryLogs(ctx context.Context, logKeys string) ApiAuditGetQueryLogsRequest {
	return ApiAuditGetQueryLogsRequest{
		ApiService: a,
		ctx:        ctx,
		logKeys:    logKeys,
	}
}

// Execute executes the request
//
//	@return GetQueryLogs200Response
func (a *AuditAPIAPIService) AuditGetQueryLogsExecute(r ApiAuditGetQueryLogsRequest) (*GetQueryLogs200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetQueryLogs200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuditAPIAPIService.AuditGetQueryLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audit/logs/{log_keys}"
	localVarPath = strings.Replace(localVarPath, "{"+"log_keys"+"}", url.PathEscape(parameterValueTostring(r.logKeys, "logKeys")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.from == nil {
		return localVarReturnValue, nil, reportError("from is required and must be specified")
	}
	if r.to == nil {
		return localVarReturnValue, nil, reportError("to is required and must be specified")
	}

	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "", "")
	if r.timeRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_range", r.timeRange, "", "")
	}
	if r.label != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label", r.label, "", "")
	}
	if r.labels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "labels", r.labels, "", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "", "")
	} else {
		var defaultValue int32 = 50
		r.perPage = &defaultValue
	}
	if r.exportFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "export_format", r.exportFormat, "", "")
	}
	if r.kvpInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "kvp_info", r.kvpInfo, "", "")
	}
	if r.mostRecentFirst != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "most_recent_first", r.mostRecentFirst, "", "")
	} else {
		var defaultValue bool = false
		r.mostRecentFirst = &defaultValue
	}
	if r.sequenceNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sequence_number", r.sequenceNumber, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuditPollQueryRequest struct {
	ctx        context.Context
	ApiService *AuditAPIAPIService
	id         string
	timeRange  *string
}

// \\ An alternative to the &#x60;from&#x60; and &#x60;to&#x60; query parameters. Supported values: * &#x60;yesterday&#x60; * &#x60;today&#x60; * &#x60;last x timeunits&#x60; where x is the number of time unit back from the current server time. Supported time units (case insensitive):     - min(s) or minute(s)     - hr(s) or hour(s)     - day(s)     - week(s)     - month(s)     - year(s)  If &#x60;time_range&#x60; is used, then the &#x60;from&#x60; and &#x60;to&#x60; query parameters must not be used.
func (r ApiAuditPollQueryRequest) TimeRange(timeRange string) ApiAuditPollQueryRequest {
	r.timeRange = &timeRange
	return r
}

func (r ApiAuditPollQueryRequest) Execute() (*PollQuery200Response, *http.Response, error) {
	return r.ApiService.AuditPollQueryExecute(r)
}

/*
AuditPollQuery Poll a Query In Progress

This endpoint is available as a convenient way to search for audit logs. It operates the same way as the [/query/{id}](#operation/pollQuery) endpoints, which can be used to search for both audit logs and regular logs.

Links must be polled at least once **every 20 seconds** to avoid expiration. Be cautious of polling too frequently as that can lead to rate limiting.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id \\ The continuation id generated when the query started.
	@return ApiAuditPollQueryRequest
*/
func (a *AuditAPIAPIService) AuditPollQuery(ctx context.Context, id string) ApiAuditPollQueryRequest {
	return ApiAuditPollQueryRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return PollQuery200Response
func (a *AuditAPIAPIService) AuditPollQueryExecute(r ApiAuditPollQueryRequest) (*PollQuery200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PollQuery200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuditAPIAPIService.AuditPollQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audit/query/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueTostring(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_range", r.timeRange, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAuditPostQueryLogsRequest struct {
	ctx                  context.Context
	ApiService           *AuditAPIAPIService
	postQueryLogsRequest *PostQueryLogsRequest
	perPage              *int32
	exportFormat         *string
	kvpInfo              *bool
	mostRecentFirst      *bool
	labels               *string
	sequenceNumber       *int32
}

// The JSON payload must contain: * a non-empty array of the log keys for the logs that will be queried * a &#x60;leql&#x60; object, containing a value for either of the following (but **not** for both):   - &#x60;leql.during.time_range&#x60;   - &#x60;leql.during.from&#x60; and &#x60;leql.during.to&#x60;  The &#x60;leql.statement&#x60; can be empty or omitted.
func (r ApiAuditPostQueryLogsRequest) PostQueryLogsRequest(postQueryLogsRequest PostQueryLogsRequest) ApiAuditPostQueryLogsRequest {
	r.postQueryLogsRequest = &postQueryLogsRequest
	return r
}

// \\ Number of log entries to return per page, up to 500(the maximum allowed).
func (r ApiAuditPostQueryLogsRequest) PerPage(perPage int32) ApiAuditPostQueryLogsRequest {
	r.perPage = &perPage
	return r
}

// \\ If included, the query results will be exported to the given format.  * Currently only &#x60;csv&#x60; is supported. * This parameter is only for non-statistical search queries (i.e. no &#39;calculate&#39; and/or &#39;groupby&#39; clauses). * Results are limited to the first 1 million log entries, and only one export job may run per account at a time.  The response will be a 202, and the response body will contain a link for polling the export job (on the **_/exports/{id}** endpoint).
func (r ApiAuditPostQueryLogsRequest) ExportFormat(exportFormat string) ApiAuditPostQueryLogsRequest {
	r.exportFormat = &exportFormat
	return r
}

// \\ When set to true, the &#x60;events&#x60; object that is returned will additionally contain information about all the key-value pairs in each returned log entry.
func (r ApiAuditPostQueryLogsRequest) KvpInfo(kvpInfo bool) ApiAuditPostQueryLogsRequest {
	r.kvpInfo = &kvpInfo
	return r
}

// \\ When set to &#x60;true&#x60;, the query returns the most recent events first. When set to &#x60;false&#x60;, it returns the oldest events first.
func (r ApiAuditPostQueryLogsRequest) MostRecentFirst(mostRecentFirst bool) ApiAuditPostQueryLogsRequest {
	r.mostRecentFirst = &mostRecentFirst
	return r
}

// \\ A set of &#39;:&#39; separated label UUIDs. Only entries which have a label matching one of these UUIDs will be returned. This only works with non-statistical queries (i.e. no &#39;groupby&#39; or &#39;calculate&#39; clauses). Takes precedence over the &#39;label&#39; parameter.
func (r ApiAuditPostQueryLogsRequest) Labels(labels string) ApiAuditPostQueryLogsRequest {
	r.labels = &labels
	return r
}

// \\ If this query parameter is included, the query results will additionally include all log entries received in the &#x60;from&#x60; millisecond which have sequence numbers larger than the one specified.  Sequence numbers are identifiers used to distinguish between log entries received in the same millisecond. If a log entry was split up into several log entries during ingestion, then those chunks are ordered by sequence number.
func (r ApiAuditPostQueryLogsRequest) SequenceNumber(sequenceNumber int32) ApiAuditPostQueryLogsRequest {
	r.sequenceNumber = &sequenceNumber
	return r
}

func (r ApiAuditPostQueryLogsRequest) Execute() (*GetQueryLogs200Response, *http.Response, error) {
	return r.ApiService.AuditPostQueryLogsExecute(r)
}

/*
AuditPostQueryLogs Query Multiple Logs Using LEQL

This endpoint is available as a convenient way to search for audit logs. It operates the same way as the [/query/logs](#operation/postQueryLogs) endpoints, which can be used to search for both audit logs and regular logs.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAuditPostQueryLogsRequest
*/
func (a *AuditAPIAPIService) AuditPostQueryLogs(ctx context.Context) ApiAuditPostQueryLogsRequest {
	return ApiAuditPostQueryLogsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetQueryLogs200Response
func (a *AuditAPIAPIService) AuditPostQueryLogsExecute(r ApiAuditPostQueryLogsRequest) (*GetQueryLogs200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetQueryLogs200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuditAPIAPIService.AuditPostQueryLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audit/query/logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postQueryLogsRequest == nil {
		return localVarReturnValue, nil, reportError("postQueryLogsRequest is required and must be specified")
	}

	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "", "")
	} else {
		var defaultValue int32 = 50
		r.perPage = &defaultValue
	}
	if r.exportFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "export_format", r.exportFormat, "", "")
	}
	if r.kvpInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "kvp_info", r.kvpInfo, "", "")
	}
	if r.mostRecentFirst != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "most_recent_first", r.mostRecentFirst, "", "")
	} else {
		var defaultValue bool = false
		r.mostRecentFirst = &defaultValue
	}
	if r.labels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "labels", r.labels, "", "")
	}
	if r.sequenceNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sequence_number", r.sequenceNumber, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postQueryLogsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllAuditLogsRequest struct {
	ctx        context.Context
	ApiService *AuditAPIAPIService
}

func (r ApiGetAllAuditLogsRequest) Execute() (*AuditLogList, *http.Response, error) {
	return r.ApiService.GetAllAuditLogsExecute(r)
}

/*
GetAllAuditLogs Retrieve All Audit Logs

Returns all "audit" logs for this account. The "audit" logs are a subset of all the logs, and include the logs
inside the "Internal Logs" logset, e.g., "Web Access Log", which report on activity within Log Search itself.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAllAuditLogsRequest
*/
func (a *AuditAPIAPIService) GetAllAuditLogs(ctx context.Context) ApiGetAllAuditLogsRequest {
	return ApiGetAllAuditLogsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AuditLogList
func (a *AuditAPIAPIService) GetAllAuditLogsExecute(r ApiGetAllAuditLogsRequest) (*AuditLogList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuditLogList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuditAPIAPIService.GetAllAuditLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audit/management/logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAuditLogRequest struct {
	ctx        context.Context
	ApiService *AuditAPIAPIService
	id         string
}

func (r ApiGetAuditLogRequest) Execute() (*AuditLogSingle, *http.Response, error) {
	return r.ApiService.GetAuditLogExecute(r)
}

/*
GetAuditLog Retrieve An Audit Log

Returns the "audit" log with that **{id}**. The "audit" logs are a subset of all the logs, and include the logs
inside the "Internal Logs" logset, e.g., "Web Access Log", which report on activity within Log Search itself.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id \\ The id of the log to be queried.
	@return ApiGetAuditLogRequest
*/
func (a *AuditAPIAPIService) GetAuditLog(ctx context.Context, id string) ApiGetAuditLogRequest {
	return ApiGetAuditLogRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AuditLogSingle
func (a *AuditAPIAPIService) GetAuditLogExecute(r ApiGetAuditLogRequest) (*AuditLogSingle, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuditLogSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuditAPIAPIService.GetAuditLog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audit/management/logs/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueTostring(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
