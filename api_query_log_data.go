/*
InsightOps REST API

### Overview  Our REST API lets you use InsightOps through HTTP requests. Currently, the REST API allows you to perform the majority of the actions available through the UI, and has some additional functionality that is not available through the UI. You may use this API to automate common tasks (for example, via shell scripts), and to generally interact with InsightOps programmatically.  This page precisely describes the REST API and serves as a reference for the API. Each HTTP method and each URL endpoint is documented in a self-contained unit so that users only need to read about the HTTP methods relevant to them.  ### Terminology  * A **log entry** is an individual log event. * A **log** is a collection of log entries, or a single log stream. * A **log set** is a logical-only collection of logs, i.e. logs can be in multiple logsets and deleting a logset only deletes the relation between logs, not the logs themselves. * [Log Entry Query Language](https://docs.rapid7.com/insightops/log-search) (**LEQL**) is the query language used in Insight Ops to search log data.

API version: latest
Contact: support@rapid7.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package insightops

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// QueryLogDataAPIService QueryLogDataAPI service
type QueryLogDataAPIService service

type ApiGetContextEventsRequest struct {
	ctx              context.Context
	ApiService       *QueryLogDataAPIService
	idSequenceNumber int32
	timestamp        *string
	logKeys          *string
	contextType      *string
	perPage          *int32
	kvpInfo          *bool
	mostRecentFirst  *bool
}

// \\ The timestamp of the log entry to fetch contextual events for.
func (r ApiGetContextEventsRequest) Timestamp(timestamp string) ApiGetContextEventsRequest {
	r.timestamp = &timestamp
	return r
}

// \\ The key of the log containing the log entry to fetch the contextual events for.
func (r ApiGetContextEventsRequest) LogKeys(logKeys string) ApiGetContextEventsRequest {
	r.logKeys = &logKeys
	return r
}

// Possible values: * &#x60;AFTER&#x60;  -  returns the log entries immediately *after* the given log entry (doesn&#39;t include the given log entry). * &#x60;BEFORE&#x60; -  returns the log entries immediately *before* the given log entry (doesn&#39;t include the given log entry). * &#x60;SURROUND&#x60; -  returns the log entries immediately *before and after* the given log entry(*does* include the given log entry).
func (r ApiGetContextEventsRequest) ContextType(contextType string) ApiGetContextEventsRequest {
	r.contextType = &contextType
	return r
}

// \\ Number of log entries to return per page, up to 500(the maximum allowed).
func (r ApiGetContextEventsRequest) PerPage(perPage int32) ApiGetContextEventsRequest {
	r.perPage = &perPage
	return r
}

// \\ When set to true, the &#x60;events&#x60; object that is returned will additionally contain information about all the key-value pairs in each returned log entry.
func (r ApiGetContextEventsRequest) KvpInfo(kvpInfo bool) ApiGetContextEventsRequest {
	r.kvpInfo = &kvpInfo
	return r
}

// \\ When set to &#x60;true&#x60;, the query returns the most recent events first. When set to &#x60;false&#x60;, it returns the oldest events first.
func (r ApiGetContextEventsRequest) MostRecentFirst(mostRecentFirst bool) ApiGetContextEventsRequest {
	r.mostRecentFirst = &mostRecentFirst
	return r
}

func (r ApiGetContextEventsRequest) Execute() (*ContextResponse, *http.Response, error) {
	return r.ApiService.GetContextEventsExecute(r)
}

/*
GetContextEvents Retrieve The Log Data Immediately Before And After A Specific Log Line

Submit a query to retrieve the log entries immediately before, after, or both, a specific
log entry, which is identified by the log key, the timestamp of the log entry, and its sequence number
(a number used to distinguish between log entries received within the same millisecond).

The log entries included in the query result are those before, after, or both, the specified the log entry,
until there is a gap of 60 seconds between log entries. For example:
1. an entry "entry1" is ingested,
2. 61 seconds later, entries "entry2", "entry3", and "entry4" are ingested,
3. 61 seconds later, an entry "entry5" is ingested,

then the events that are "immediately before or after" (or both) "entry3" will consist of {"entry2", "entry3", "entry4"}.

For instructions on polling a query until it is completed, handling pagination, and handling rate limits, consult
[this section's introduction](#tag/Query-Log-Data). However, note that this endpoint is unique in that it also supports

	backwards pagination through the **Prev** link in the `links` array of the response, which behaves in the same way
	as regular pagination which uses the **Next** link.


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param idSequenceNumber \\ The sequence number of the log entry to fetch contextual log entries for (a unique identifier used to distinguish between log entries received in the same millisecond).  The sequence number can be found next to the log entry in the response body for an Event Search query. For more context on creating an Event Search query [view the introduction to this section](#tag/Query-Log-Data).
	@return ApiGetContextEventsRequest
*/
func (a *QueryLogDataAPIService) GetContextEvents(ctx context.Context, idSequenceNumber int32) ApiGetContextEventsRequest {
	return ApiGetContextEventsRequest{
		ApiService:       a,
		ctx:              ctx,
		idSequenceNumber: idSequenceNumber,
	}
}

// Execute executes the request
//
//	@return ContextResponse
func (a *QueryLogDataAPIService) GetContextEventsExecute(r ApiGetContextEventsRequest) (*ContextResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ContextResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueryLogDataAPIService.GetContextEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query/context/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id (sequence number)"+"}", url.PathEscape(parameterValueTostring(r.idSequenceNumber, "idSequenceNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.logKeys == nil {
		return localVarReturnValue, nil, reportError("logKeys is required and must be specified")
	}
	if r.contextType == nil {
		return localVarReturnValue, nil, reportError("contextType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "log_keys", r.logKeys, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "context_type", r.contextType, "", "")
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "", "")
	} else {
		var defaultValue int32 = 50
		r.perPage = &defaultValue
	}
	if r.kvpInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "kvp_info", r.kvpInfo, "", "")
	}
	if r.mostRecentFirst != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "most_recent_first", r.mostRecentFirst, "", "")
	} else {
		var defaultValue bool = false
		r.mostRecentFirst = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetQueryEndpointsRequest struct {
	ctx        context.Context
	ApiService *QueryLogDataAPIService
}

func (r ApiGetQueryEndpointsRequest) Execute() (*map[string]ListEndpointsResponseValue, *http.Response, error) {
	return r.ApiService.GetQueryEndpointsExecute(r)
}

/*
GetQueryEndpoints List All Endpoints

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetQueryEndpointsRequest
*/
func (a *QueryLogDataAPIService) GetQueryEndpoints(ctx context.Context) ApiGetQueryEndpointsRequest {
	return ApiGetQueryEndpointsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return map[string]ListEndpointsResponseValue
func (a *QueryLogDataAPIService) GetQueryEndpointsExecute(r ApiGetQueryEndpointsRequest) (*map[string]ListEndpointsResponseValue, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *map[string]ListEndpointsResponseValue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueryLogDataAPIService.GetQueryEndpoints")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetQueryLogsRequest struct {
	ctx             context.Context
	ApiService      *QueryLogDataAPIService
	logKeys         string
	from            *int32
	to              *int32
	query           *string
	timeRange       *string
	label           *string
	labels          *string
	perPage         *int32
	exportFormat    *string
	kvpInfo         *bool
	mostRecentFirst *bool
	sequenceNumber  *int32
}

// \\ The start of the time range for the query, as a UNIX timestamp in milliseconds.
func (r ApiGetQueryLogsRequest) From(from int32) ApiGetQueryLogsRequest {
	r.from = &from
	return r
}

// \\ The end of the time range for the query, as a UNIX timestamp in milliseconds.
func (r ApiGetQueryLogsRequest) To(to int32) ApiGetQueryLogsRequest {
	r.to = &to
	return r
}

// \\ A valid LEQL query to run against the log. If omitted, the query retrieves all log entries in the specified time range.
func (r ApiGetQueryLogsRequest) Query(query string) ApiGetQueryLogsRequest {
	r.query = &query
	return r
}

// \\ An alternative to the &#x60;from&#x60; and &#x60;to&#x60; query parameters. Supported values: * &#x60;yesterday&#x60; * &#x60;today&#x60; * &#x60;last x timeunits&#x60; where x is the number of time unit back from the current server time. Supported time units (case insensitive):     - min(s) or minute(s)     - hr(s) or hour(s)     - day(s)     - week(s)     - month(s)     - year(s)  If &#x60;time_range&#x60; is used, then the &#x60;from&#x60; and &#x60;to&#x60; query parameters must not be used.
func (r ApiGetQueryLogsRequest) TimeRange(timeRange string) ApiGetQueryLogsRequest {
	r.timeRange = &timeRange
	return r
}

// \\ Only entries which have a label with this UUID will be returned. This only works with non-statistical queries (i.e. no &#39;groupby&#39; or &#39;calculate&#39; clauses).
func (r ApiGetQueryLogsRequest) Label(label string) ApiGetQueryLogsRequest {
	r.label = &label
	return r
}

// \\ A set of &#39;:&#39; separated label UUIDs. Only entries which have a label matching one of these UUIDs will be returned. This only works with non-statistical queries (i.e. no &#39;groupby&#39; or &#39;calculate&#39; clauses). Takes precedence over the &#39;label&#39; parameter.
func (r ApiGetQueryLogsRequest) Labels(labels string) ApiGetQueryLogsRequest {
	r.labels = &labels
	return r
}

// \\ Number of log entries to return per page, up to 500(the maximum allowed).
func (r ApiGetQueryLogsRequest) PerPage(perPage int32) ApiGetQueryLogsRequest {
	r.perPage = &perPage
	return r
}

// \\ If included, the query results will be exported to the given format.  * Currently only &#x60;csv&#x60; is supported. * This parameter is only for non-statistical search queries (i.e. no &#39;calculate&#39; and/or &#39;groupby&#39; clauses). * Results are limited to the first 1 million log entries, and only one export job may run per account at a time.  The response will be a 202, and the response body will contain a link for polling the export job (on the **_/exports/{id}** endpoint).
func (r ApiGetQueryLogsRequest) ExportFormat(exportFormat string) ApiGetQueryLogsRequest {
	r.exportFormat = &exportFormat
	return r
}

// \\ When set to true, the &#x60;events&#x60; object that is returned will additionally contain information about all the key-value pairs in each returned log entry.
func (r ApiGetQueryLogsRequest) KvpInfo(kvpInfo bool) ApiGetQueryLogsRequest {
	r.kvpInfo = &kvpInfo
	return r
}

// \\ When set to &#x60;true&#x60;, the query returns the most recent events first. When set to &#x60;false&#x60;, it returns the oldest events first.
func (r ApiGetQueryLogsRequest) MostRecentFirst(mostRecentFirst bool) ApiGetQueryLogsRequest {
	r.mostRecentFirst = &mostRecentFirst
	return r
}

// \\ If this query parameter is included, the query results will additionally include all log entries received in the &#x60;from&#x60; millisecond which have sequence numbers larger than the one specified.  Sequence numbers are identifiers used to distinguish between log entries received in the same millisecond. If a log entry was split up into several log entries during ingestion, then those chunks are ordered by sequence number.
func (r ApiGetQueryLogsRequest) SequenceNumber(sequenceNumber int32) ApiGetQueryLogsRequest {
	r.sequenceNumber = &sequenceNumber
	return r
}

func (r ApiGetQueryLogsRequest) Execute() (*GetQueryLogs200Response, *http.Response, error) {
	return r.ApiService.GetQueryLogsExecute(r)
}

/*
GetQueryLogs Query Individual Logs

Submit the query specified in the query parameters for the log with that **{log_key}**.
For instructions on polling a query until it is completed, handling pagination, and handling rate limits, consult
[this section's introduction](#tag/Query-Log-Data).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param logKeys \\ The key of the log to be queried.  Supplying multiple ':' separated log keys is deprecated; users should instead 'POST' the query as a JSON payload to [/query/logs](#operation/postQueryLogs).
	@return ApiGetQueryLogsRequest
*/
func (a *QueryLogDataAPIService) GetQueryLogs(ctx context.Context, logKeys string) ApiGetQueryLogsRequest {
	return ApiGetQueryLogsRequest{
		ApiService: a,
		ctx:        ctx,
		logKeys:    logKeys,
	}
}

// Execute executes the request
//
//	@return GetQueryLogs200Response
func (a *QueryLogDataAPIService) GetQueryLogsExecute(r ApiGetQueryLogsRequest) (*GetQueryLogs200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetQueryLogs200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueryLogDataAPIService.GetQueryLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query/logs/{log_keys}"
	localVarPath = strings.Replace(localVarPath, "{"+"log_keys"+"}", url.PathEscape(parameterValueTostring(r.logKeys, "logKeys")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.from == nil {
		return localVarReturnValue, nil, reportError("from is required and must be specified")
	}
	if r.to == nil {
		return localVarReturnValue, nil, reportError("to is required and must be specified")
	}

	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "", "")
	if r.timeRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_range", r.timeRange, "", "")
	}
	if r.label != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label", r.label, "", "")
	}
	if r.labels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "labels", r.labels, "", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "", "")
	} else {
		var defaultValue int32 = 50
		r.perPage = &defaultValue
	}
	if r.exportFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "export_format", r.exportFormat, "", "")
	}
	if r.kvpInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "kvp_info", r.kvpInfo, "", "")
	}
	if r.mostRecentFirst != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "most_recent_first", r.mostRecentFirst, "", "")
	} else {
		var defaultValue bool = false
		r.mostRecentFirst = &defaultValue
	}
	if r.sequenceNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sequence_number", r.sequenceNumber, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSearchStatsRequest struct {
	ctx        context.Context
	ApiService *QueryLogDataAPIService
}

func (r ApiGetSearchStatsRequest) Execute() ([]SearchStatsInner, *http.Response, error) {
	return r.ApiService.GetSearchStatsExecute(r)
}

/*
GetSearchStats View Statistics On Past Queries

Retrieve information about your queries such as:
* Time taken to complete the query.
* Amount of data searched.
* Number of log lines in your data which matched the query.
* LEQL statement used for the query.

For context and information about Log Search queries, consult this [this section's introduction](#tag/Query-Log-Data).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetSearchStatsRequest
*/
func (a *QueryLogDataAPIService) GetSearchStats(ctx context.Context) ApiGetSearchStatsRequest {
	return ApiGetSearchStatsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []SearchStatsInner
func (a *QueryLogDataAPIService) GetSearchStatsExecute(r ApiGetSearchStatsRequest) ([]SearchStatsInner, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []SearchStatsInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueryLogDataAPIService.GetSearchStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/search-stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPollQueryRequest struct {
	ctx        context.Context
	ApiService *QueryLogDataAPIService
	id         string
	timeRange  *string
}

// \\ An alternative to the &#x60;from&#x60; and &#x60;to&#x60; query parameters. Supported values: * &#x60;yesterday&#x60; * &#x60;today&#x60; * &#x60;last x timeunits&#x60; where x is the number of time unit back from the current server time. Supported time units (case insensitive):     - min(s) or minute(s)     - hr(s) or hour(s)     - day(s)     - week(s)     - month(s)     - year(s)  If &#x60;time_range&#x60; is used, then the &#x60;from&#x60; and &#x60;to&#x60; query parameters must not be used.
func (r ApiPollQueryRequest) TimeRange(timeRange string) ApiPollQueryRequest {
	r.timeRange = &timeRange
	return r
}

func (r ApiPollQueryRequest) Execute() (*PollQuery200Response, *http.Response, error) {
	return r.ApiService.PollQueryExecute(r)
}

/*
PollQuery Poll a Query In Progress

Checks the status of the query with the **{continuation_id}** generated when the query started.
If the query is complete, the result is returned.
Otherwise: the progress (in percent) is reported, and a partial calculation or some partial search results may be returned.

It is important to note that if there are more than `per_page` events which match the query, then the response will only contain `per_page` events.
The remaining events can be returned by following the `Next` link in the response body.

Therefore to get all results for a specific time-range you will need to create a query, poll it to completion, create a new query using the `Next` link for next page, poll etc.
There are two types of links in poll requests:
- `Self`: current query/page of results isn't done, continue polling
- `Next`: Current query/page is done, but if you wish to get the next/remaining events, create a new query for more events with this link
There is a code example below for polling logic.

The `time_range` metadata information for the query can only be tracked by the client,
by providing it as a query parameter with every polling request, which will be returned as given in the response
(does not affect the query execution - only metadata information).

Links must be polled at least once **every 20 seconds** to avoid expiration. Be cautious of polling too frequently as that can lead to rate limiting.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id \\ The continuation id generated when the query started.
	@return ApiPollQueryRequest
*/
func (a *QueryLogDataAPIService) PollQuery(ctx context.Context, id string) ApiPollQueryRequest {
	return ApiPollQueryRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return PollQuery200Response
func (a *QueryLogDataAPIService) PollQueryExecute(r ApiPollQueryRequest) (*PollQuery200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PollQuery200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueryLogDataAPIService.PollQuery")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueTostring(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_range", r.timeRange, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostQueryLogsRequest struct {
	ctx                  context.Context
	ApiService           *QueryLogDataAPIService
	postQueryLogsRequest *PostQueryLogsRequest
	perPage              *int32
	exportFormat         *string
	kvpInfo              *bool
	mostRecentFirst      *bool
	labels               *string
	sequenceNumber       *int32
}

// The JSON payload must contain: * a non-empty array of the log keys for the logs that will be queried * a &#x60;leql&#x60; object, containing a value for either of the following (but **not** for both):   - &#x60;leql.during.time_range&#x60;   - &#x60;leql.during.from&#x60; and &#x60;leql.during.to&#x60;    The &#x60;leql.statement&#x60; can be empty or omitted.
func (r ApiPostQueryLogsRequest) PostQueryLogsRequest(postQueryLogsRequest PostQueryLogsRequest) ApiPostQueryLogsRequest {
	r.postQueryLogsRequest = &postQueryLogsRequest
	return r
}

// \\ Number of log entries to return per page, up to 500(the maximum allowed).
func (r ApiPostQueryLogsRequest) PerPage(perPage int32) ApiPostQueryLogsRequest {
	r.perPage = &perPage
	return r
}

// \\ If included, the query results will be exported to the given format.  * Currently only &#x60;csv&#x60; is supported. * This parameter is only for non-statistical search queries (i.e. no &#39;calculate&#39; and/or &#39;groupby&#39; clauses). * Results are limited to the first 1 million log entries, and only one export job may run per account at a time.  The response will be a 202, and the response body will contain a link for polling the export job (on the **_/exports/{id}** endpoint).
func (r ApiPostQueryLogsRequest) ExportFormat(exportFormat string) ApiPostQueryLogsRequest {
	r.exportFormat = &exportFormat
	return r
}

// \\ When set to true, the &#x60;events&#x60; object that is returned will additionally contain information about all the key-value pairs in each returned log entry.
func (r ApiPostQueryLogsRequest) KvpInfo(kvpInfo bool) ApiPostQueryLogsRequest {
	r.kvpInfo = &kvpInfo
	return r
}

// \\ When set to &#x60;true&#x60;, the query returns the most recent events first. When set to &#x60;false&#x60;, it returns the oldest events first.
func (r ApiPostQueryLogsRequest) MostRecentFirst(mostRecentFirst bool) ApiPostQueryLogsRequest {
	r.mostRecentFirst = &mostRecentFirst
	return r
}

// \\ A set of &#39;:&#39; separated label UUIDs. Only entries which have a label matching one of these UUIDs will be returned. This only works with non-statistical queries (i.e. no &#39;groupby&#39; or &#39;calculate&#39; clauses). Takes precedence over the &#39;label&#39; parameter.
func (r ApiPostQueryLogsRequest) Labels(labels string) ApiPostQueryLogsRequest {
	r.labels = &labels
	return r
}

// \\ If this query parameter is included, the query results will additionally include all log entries received in the &#x60;from&#x60; millisecond which have sequence numbers larger than the one specified.  Sequence numbers are identifiers used to distinguish between log entries received in the same millisecond. If a log entry was split up into several log entries during ingestion, then those chunks are ordered by sequence number.
func (r ApiPostQueryLogsRequest) SequenceNumber(sequenceNumber int32) ApiPostQueryLogsRequest {
	r.sequenceNumber = &sequenceNumber
	return r
}

func (r ApiPostQueryLogsRequest) Execute() (*GetQueryLogs200Response, *http.Response, error) {
	return r.ApiService.PostQueryLogsExecute(r)
}

/*
PostQueryLogs Query Multiple Logs

Submit the query specified in the (JSON) request body and the URL query parameters.

An arbitrary collection of logs can be specified in the request body.

For instructions on polling a query until it is completed, handling pagination, and handling rate limits, consult
[this section's introduction](#tag/Query-Log-Data).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostQueryLogsRequest
*/
func (a *QueryLogDataAPIService) PostQueryLogs(ctx context.Context) ApiPostQueryLogsRequest {
	return ApiPostQueryLogsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetQueryLogs200Response
func (a *QueryLogDataAPIService) PostQueryLogsExecute(r ApiPostQueryLogsRequest) (*GetQueryLogs200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetQueryLogs200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueryLogDataAPIService.PostQueryLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query/logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postQueryLogsRequest == nil {
		return localVarReturnValue, nil, reportError("postQueryLogsRequest is required and must be specified")
	}

	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "", "")
	} else {
		var defaultValue int32 = 50
		r.perPage = &defaultValue
	}
	if r.exportFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "export_format", r.exportFormat, "", "")
	}
	if r.kvpInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "kvp_info", r.kvpInfo, "", "")
	}
	if r.mostRecentFirst != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "most_recent_first", r.mostRecentFirst, "", "")
	} else {
		var defaultValue bool = false
		r.mostRecentFirst = &defaultValue
	}
	if r.labels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "labels", r.labels, "", "")
	}
	if r.sequenceNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sequence_number", r.sequenceNumber, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postQueryLogsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQueryLogsetsByIdRequest struct {
	ctx             context.Context
	ApiService      *QueryLogDataAPIService
	logsetId        string
	from            *int32
	to              *int32
	query           *string
	timeRange       *string
	label           *string
	labels          *string
	perPage         *int32
	kvpInfo         *bool
	mostRecentFirst *bool
	sequenceNumber  *int32
}

// \\ The start of the time range for the query, as a UNIX timestamp in milliseconds.
func (r ApiQueryLogsetsByIdRequest) From(from int32) ApiQueryLogsetsByIdRequest {
	r.from = &from
	return r
}

// \\ The end of the time range for the query, as a UNIX timestamp in milliseconds.
func (r ApiQueryLogsetsByIdRequest) To(to int32) ApiQueryLogsetsByIdRequest {
	r.to = &to
	return r
}

// \\ A valid LEQL query to run against the log. If omitted, the query retrieves all log entries in the specified time range.
func (r ApiQueryLogsetsByIdRequest) Query(query string) ApiQueryLogsetsByIdRequest {
	r.query = &query
	return r
}

// \\ An alternative to the &#x60;from&#x60; and &#x60;to&#x60; query parameters. Supported values: * &#x60;yesterday&#x60; * &#x60;today&#x60; * &#x60;last x timeunits&#x60; where x is the number of time unit back from the current server time. Supported time units (case insensitive):     - min(s) or minute(s)     - hr(s) or hour(s)     - day(s)     - week(s)     - month(s)     - year(s)  If &#x60;time_range&#x60; is used, then the &#x60;from&#x60; and &#x60;to&#x60; query parameters must not be used.
func (r ApiQueryLogsetsByIdRequest) TimeRange(timeRange string) ApiQueryLogsetsByIdRequest {
	r.timeRange = &timeRange
	return r
}

// \\ Only entries which have a label with this UUID will be returned. This only works with non-statistical queries (i.e. no &#39;groupby&#39; or &#39;calculate&#39; clauses).
func (r ApiQueryLogsetsByIdRequest) Label(label string) ApiQueryLogsetsByIdRequest {
	r.label = &label
	return r
}

// \\ A set of &#39;:&#39; separated label UUIDs. Only entries which have a label matching one of these UUIDs will be returned. This only works with non-statistical queries (i.e. no &#39;groupby&#39; or &#39;calculate&#39; clauses). Takes precedence over the &#39;label&#39; parameter.
func (r ApiQueryLogsetsByIdRequest) Labels(labels string) ApiQueryLogsetsByIdRequest {
	r.labels = &labels
	return r
}

// \\ Number of log entries to return per page, up to 500(the maximum allowed).
func (r ApiQueryLogsetsByIdRequest) PerPage(perPage int32) ApiQueryLogsetsByIdRequest {
	r.perPage = &perPage
	return r
}

// \\ When set to true, the &#x60;events&#x60; object that is returned will additionally contain information about all the key-value pairs in each returned log entry.
func (r ApiQueryLogsetsByIdRequest) KvpInfo(kvpInfo bool) ApiQueryLogsetsByIdRequest {
	r.kvpInfo = &kvpInfo
	return r
}

// \\ When set to &#x60;true&#x60;, the query returns the most recent events first. When set to &#x60;false&#x60;, it returns the oldest events first.
func (r ApiQueryLogsetsByIdRequest) MostRecentFirst(mostRecentFirst bool) ApiQueryLogsetsByIdRequest {
	r.mostRecentFirst = &mostRecentFirst
	return r
}

// \\ If this query parameter is included, the query results will additionally include all log entries received in the &#x60;from&#x60; millisecond which have sequence numbers larger than the one specified.  Sequence numbers are identifiers used to distinguish between log entries received in the same millisecond. If a log entry was split up into several log entries during ingestion, then those chunks are ordered by sequence number.
func (r ApiQueryLogsetsByIdRequest) SequenceNumber(sequenceNumber int32) ApiQueryLogsetsByIdRequest {
	r.sequenceNumber = &sequenceNumber
	return r
}

func (r ApiQueryLogsetsByIdRequest) Execute() (*GetQueryLogs200Response, *http.Response, error) {
	return r.ApiService.QueryLogsetsByIdExecute(r)
}

/*
QueryLogsetsById Query Individual Log Sets

Submit the query specified in the query parameters for the log set with that **{logset_id}**.
Only one log set id may be provided.

For instructions on polling a query until it is completed, handling pagination, and handling rate limits, consult
[this section's introduction](#tag/Query-Log-Data).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param logsetId \\ The id of the log set to be queried.
	@return ApiQueryLogsetsByIdRequest
*/
func (a *QueryLogDataAPIService) QueryLogsetsById(ctx context.Context, logsetId string) ApiQueryLogsetsByIdRequest {
	return ApiQueryLogsetsByIdRequest{
		ApiService: a,
		ctx:        ctx,
		logsetId:   logsetId,
	}
}

// Execute executes the request
//
//	@return GetQueryLogs200Response
func (a *QueryLogDataAPIService) QueryLogsetsByIdExecute(r ApiQueryLogsetsByIdRequest) (*GetQueryLogs200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetQueryLogs200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueryLogDataAPIService.QueryLogsetsById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query/logsets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"logset_id"+"}", url.PathEscape(parameterValueTostring(r.logsetId, "logsetId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.from == nil {
		return localVarReturnValue, nil, reportError("from is required and must be specified")
	}
	if r.to == nil {
		return localVarReturnValue, nil, reportError("to is required and must be specified")
	}

	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "", "")
	if r.timeRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_range", r.timeRange, "", "")
	}
	if r.label != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label", r.label, "", "")
	}
	if r.labels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "labels", r.labels, "", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "", "")
	} else {
		var defaultValue int32 = 50
		r.perPage = &defaultValue
	}
	if r.kvpInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "kvp_info", r.kvpInfo, "", "")
	}
	if r.mostRecentFirst != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "most_recent_first", r.mostRecentFirst, "", "")
	} else {
		var defaultValue bool = false
		r.mostRecentFirst = &defaultValue
	}
	if r.sequenceNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sequence_number", r.sequenceNumber, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQueryLogsetsByNameRequest struct {
	ctx             context.Context
	ApiService      *QueryLogDataAPIService
	logsetName      *string
	from            *int32
	to              *int32
	query           *string
	timeRange       *string
	label           *string
	labels          *string
	perPage         *int32
	kvpInfo         *bool
	mostRecentFirst *bool
	sequenceNumber  *int32
}

// \\ The name of the log set to be queried. Multiple log sets can be queried by providing this parameter multiple times, which results in the query running on the *union* of all contained logs. If any of the provided log set names do not exist, a 404 error response is returned.
func (r ApiQueryLogsetsByNameRequest) LogsetName(logsetName string) ApiQueryLogsetsByNameRequest {
	r.logsetName = &logsetName
	return r
}

// \\ The start of the time range for the query, as a UNIX timestamp in milliseconds.
func (r ApiQueryLogsetsByNameRequest) From(from int32) ApiQueryLogsetsByNameRequest {
	r.from = &from
	return r
}

// \\ The end of the time range for the query, as a UNIX timestamp in milliseconds.
func (r ApiQueryLogsetsByNameRequest) To(to int32) ApiQueryLogsetsByNameRequest {
	r.to = &to
	return r
}

// \\ A valid LEQL query to run against the log. If omitted, the query retrieves all log entries in the specified time range.
func (r ApiQueryLogsetsByNameRequest) Query(query string) ApiQueryLogsetsByNameRequest {
	r.query = &query
	return r
}

// \\ An alternative to the &#x60;from&#x60; and &#x60;to&#x60; query parameters. Supported values: * &#x60;yesterday&#x60; * &#x60;today&#x60; * &#x60;last x timeunits&#x60; where x is the number of time unit back from the current server time. Supported time units (case insensitive):     - min(s) or minute(s)     - hr(s) or hour(s)     - day(s)     - week(s)     - month(s)     - year(s)  If &#x60;time_range&#x60; is used, then the &#x60;from&#x60; and &#x60;to&#x60; query parameters must not be used.
func (r ApiQueryLogsetsByNameRequest) TimeRange(timeRange string) ApiQueryLogsetsByNameRequest {
	r.timeRange = &timeRange
	return r
}

// \\ Only entries which have a label with this UUID will be returned. This only works with non-statistical queries (i.e. no &#39;groupby&#39; or &#39;calculate&#39; clauses).
func (r ApiQueryLogsetsByNameRequest) Label(label string) ApiQueryLogsetsByNameRequest {
	r.label = &label
	return r
}

// \\ A set of &#39;:&#39; separated label UUIDs. Only entries which have a label matching one of these UUIDs will be returned. This only works with non-statistical queries (i.e. no &#39;groupby&#39; or &#39;calculate&#39; clauses). Takes precedence over the &#39;label&#39; parameter.
func (r ApiQueryLogsetsByNameRequest) Labels(labels string) ApiQueryLogsetsByNameRequest {
	r.labels = &labels
	return r
}

// \\ Number of log entries to return per page, up to 500(the maximum allowed).
func (r ApiQueryLogsetsByNameRequest) PerPage(perPage int32) ApiQueryLogsetsByNameRequest {
	r.perPage = &perPage
	return r
}

// \\ When set to true, the &#x60;events&#x60; object that is returned will additionally contain information about all the key-value pairs in each returned log entry.
func (r ApiQueryLogsetsByNameRequest) KvpInfo(kvpInfo bool) ApiQueryLogsetsByNameRequest {
	r.kvpInfo = &kvpInfo
	return r
}

// \\ When set to &#x60;true&#x60;, the query returns the most recent events first. When set to &#x60;false&#x60;, it returns the oldest events first.
func (r ApiQueryLogsetsByNameRequest) MostRecentFirst(mostRecentFirst bool) ApiQueryLogsetsByNameRequest {
	r.mostRecentFirst = &mostRecentFirst
	return r
}

// \\ If this query parameter is included, the query results will additionally include all log entries received in the &#x60;from&#x60; millisecond which have sequence numbers larger than the one specified.  Sequence numbers are identifiers used to distinguish between log entries received in the same millisecond. If a log entry was split up into several log entries during ingestion, then those chunks are ordered by sequence number.
func (r ApiQueryLogsetsByNameRequest) SequenceNumber(sequenceNumber int32) ApiQueryLogsetsByNameRequest {
	r.sequenceNumber = &sequenceNumber
	return r
}

func (r ApiQueryLogsetsByNameRequest) Execute() (*GetQueryLogs200Response, *http.Response, error) {
	return r.ApiService.QueryLogsetsByNameExecute(r)
}

/*
QueryLogsetsByName Query Multiple Log Sets

Submit the query specified in the query parameters for the log sets matching the given names.

For instructions on polling a query until it is completed, handling pagination, and handling rate limits, consult
[this section's introduction](#tag/Query-Log-Data).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiQueryLogsetsByNameRequest
*/
func (a *QueryLogDataAPIService) QueryLogsetsByName(ctx context.Context) ApiQueryLogsetsByNameRequest {
	return ApiQueryLogsetsByNameRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetQueryLogs200Response
func (a *QueryLogDataAPIService) QueryLogsetsByNameExecute(r ApiQueryLogsetsByNameRequest) (*GetQueryLogs200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetQueryLogs200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "QueryLogDataAPIService.QueryLogsetsByName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/query/logsets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.logsetName == nil {
		return localVarReturnValue, nil, reportError("logsetName is required and must be specified")
	}
	if r.from == nil {
		return localVarReturnValue, nil, reportError("from is required and must be specified")
	}
	if r.to == nil {
		return localVarReturnValue, nil, reportError("to is required and must be specified")
	}

	if r.query != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "logset_name", r.logsetName, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "", "")
	if r.timeRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_range", r.timeRange, "", "")
	}
	if r.label != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "label", r.label, "", "")
	}
	if r.labels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "labels", r.labels, "", "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "", "")
	} else {
		var defaultValue int32 = 50
		r.perPage = &defaultValue
	}
	if r.kvpInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "kvp_info", r.kvpInfo, "", "")
	}
	if r.mostRecentFirst != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "most_recent_first", r.mostRecentFirst, "", "")
	} else {
		var defaultValue bool = false
		r.mostRecentFirst = &defaultValue
	}
	if r.sequenceNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sequence_number", r.sequenceNumber, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api Key Authentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
